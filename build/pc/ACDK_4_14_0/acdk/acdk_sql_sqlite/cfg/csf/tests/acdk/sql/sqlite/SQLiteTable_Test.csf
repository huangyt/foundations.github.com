
using acdk.sql.sqlite;
using acdk.io;
/**
  this tests does not use the acdk.sql.* classes, but goes directly to the LiteDb classes
*/

File f = new File("acdk_sql_sqlite_test2.sqlite3");
String fqFile = f.getCanonicalPath();
if (f.exists() == true)
{
  if (f.deleteFile() == false)
    out.println("cannot delete file: " + fqFile);
}
  
LiteDb db = LiteDb.openDb(f.getName());

db.execute(
  "CREATE TABLE ttable (intcol int, stringcol VARCHAR);
   INSERT INTO ttable (intcol, stringcol) VALUES (1, 'first');
   INSERT INTO ttable (intcol, stringcol) VALUES (2, 'second');
   INSERT INTO ttable (intcol, stringcol) VALUES (3, 'third');
  "
  );

LiteMemTable table = db.execDirect("SELECT * from ttable");
// just print it
table.printTable(out);

out.println("use iteration:\n");
// iterate throw rows
foreach (LiteMemTableIterator r in table.iterator())
{
  // iterates through cols
  foreach (String f in r.iterator())
  {
    out.print(f + "|");  
  }
  out.println("");
}

// call for each row the delegate function
// this may be a lambda expression or a dynamic/static object/class method

// first version without signature and implicit NamedRest rest parameter
db.execute("SELECT * from ttable", 
  lambda 
  {
    // first arg is __db for the database
    // folowing the columns named corresponding the column names in the SQL table
    out.println("intcol: " + intcol + "; stringcol: " + stringcol);
  }
  );
out.println("");

// second version with explicit method signature
// The fields of the row must be have the names of original SQL column names.
// The first argument must be LiteDb __db.
// The order of the arguments is irrelevant.
db.execute("SELECT * from ttable", 
  lambda int (LiteDb __db, String intcol, String stringcol)
  {
    out.println("intcol: " + intcol + "; stringcol: " + stringcol);
    return 0;
  }
  );
out.println("");

db.execute("CREATE VIEW tview AS SELECT intcol as numcol, stringcol as varcharcol from ttable;");
db.execute("CREATE INDEX ttable_first ON ttable (intcol);");
db.execute("CREATE TABLE sicttable (intcol int, stringcol VARCHAR);");
db.execute(
  "CREATE TRIGGER insert_ttable AFTER INSERT ON ttable
  BEGIN
    INSERT INTO sicttable (intcol, stringcol) VALUES (new.intcol, new.stringcol);
  END;
  ");



db.execDirect(
  "SELECT '' AS 'TABLE_CAT', 
	'' AS 'TABLE_SCHEM', 
	tbl_name AS 'TABLE_NAME', 
	upper(type) AS 'TABLE_TYPE', 
	'' AS REMARKS FROM sqlite_master 
  WHERE tbl_name like '%';"
  )
  .printTable(out);

out.println("");
db.execDirect("PRAGMA table_info(ttable);").printTable(out);


// rest is to print out the table
/* no longer needed because LiteMemTable provides this code
int cols = table.columnCount();
int rows = table.rowCount();
out.println("cols: " + cols + "; rows: " + rows);
intArray widths = new intArray(0);
int i;
int sumwidth = 0;
for (i = 0; i < cols; ++i)
{
  int w = table.getMaxColWidth(i + 1);
  sumwidth = sumwidth + w;
  widths.append(w);
}
for (i = 0; i < cols; ++i)
{
  if (i > 0)
    out << "|";
  out << table.getColumnName(i + 1).rightPad(widths.get(i));  
}
out.println("");
out.println("-".repeat(sumwidth + cols));
for (int r = 0; r < rows; ++r)
{
  for (i = 0; i < cols; ++i)
  {
    if (i > 0)
      out << "|";
    out << table.getField(r, i + 1).rightPad(widths.get(i)); 
  }
  out.println("");
}
*/

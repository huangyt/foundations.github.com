// -*- mode:C++; tab-width:2; c-basic-offset:2; indent-tabs-mode:nil -*- 
//
// Copyright (C) 2000-2005 by Roger Rene Kommer / artefaktur, Kassel, Germany.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License (LGPL).
// 
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the 
// License ACDK-FreeLicense document enclosed in the distribution
// for more for more details.

// This file is part of the Artefaktur Component Development Kit:
//                         ACDK
// 
// Please refer to
// - http://www.acdk.de
// - http://www.artefaktur.com
// - http://acdk.sourceforge.net
// for more information.
// 
// $Header: /cvsroot/acdk/acdk/acdk_lisp/src/acdk/lisp/LispObject_clazzinfo.cpp,v 1.10 2005/02/20 13:55:39 kommer Exp $

// Generated by ACDK Metacompiler, 
// Copyrighted by Roger Rene Kommer, artefaktur
// 
// Dont edit this file manually
// 
#include <acdk.h>

#include "LispObject.h"

#include <acdk/io/ObjectReader.h> // for instantiation purposes

namespace acdk { 
namespace lisp { 

using namespace acdk::lang;
::acdk::lang::dmi::ClazzFieldInfo* _LispObject_fields[] = 
{
  0
};



::acdk::lang::dmi::ClazzSuperInfo _LispObject_super_acdk__lang__Object =
{
  ::acdk::lang::dmi::MiPublic,
  0, // attributeRes
  acdk::lang::Object::clazzInfo()
};

::acdk::lang::dmi::ClazzSuperInfo* _LispObject_interfaces[] =
{
  &_LispObject_super_acdk__lang__Object,
  0
};

::acdk::lang::dmi::ClazzMethodArgInfo* LispObject_methods_GetClass__L_acdk_lang_RClass__args[] = 
{
  0
};

::acdk::lang::dmi::ClazzInfo* LispObject_methods_GetClass__L_acdk_lang_RClass__exceptions[] =
{
  0
};

::acdk::lang::dmi::ClazzMethodInfo LispObject_method_GetClass__L_acdk_lang_RClass_ = 
{
  ::acdk::lang::dmi::MiPublic | ::acdk::lang::dmi::MiStatic | ::acdk::lang::dmi::MiMethodInfo,// class flags, like static, Constructor
  0, // Meta Attribute
  "GetClass", // name of method
  -1, // nameHashCode
  "", 
  0, // _scopeParent
  0, // _nextScopeSibling
  ::acdk::lang::RClass::clazzInfo(), // return type
  0, // altname
  -1, // nameHashCode
  LispObject_methods_GetClass__L_acdk_lang_RClass__args, // return the arguments
  0, // args num
  LispObject_methods_GetClass__L_acdk_lang_RClass__exceptions, // the declared exceptions
  0 // address of method currently not supported
};

::acdk::lang::dmi::ClazzMethodArgInfo* LispObject_methods_getClass__L_acdk_lang_RClass__args[] = 
{
  0
};

::acdk::lang::dmi::ClazzInfo* LispObject_methods_getClass__L_acdk_lang_RClass__exceptions[] =
{
  0
};

::acdk::lang::dmi::ClazzMethodInfo LispObject_method_getClass__L_acdk_lang_RClass_ = 
{
  ::acdk::lang::dmi::MiPublic | ::acdk::lang::dmi::MiMiVirtual | ::acdk::lang::dmi::MiMethodInfo,// class flags, like static, Constructor
  0, // Meta Attribute
  "getClass", // name of method
  -1, // nameHashCode
  "", // ns
  0, // _scopeParent
  0, // _nextScopeSibling
  ::acdk::lang::RClass::clazzInfo(), // return type
  0, // altname
  -1, // nameHashCode
  LispObject_methods_getClass__L_acdk_lang_RClass__args, // return the arguments
  0, // args num
  LispObject_methods_getClass__L_acdk_lang_RClass__exceptions, // the declared exceptions
  0 // address of method currently not supported
};

::acdk::lang::dmi::ClazzMethodArgInfo* LispObject_methods_toString__LRString__args[] = 
{
  0
};

::acdk::lang::dmi::ClazzInfo* LispObject_methods_toString__LRString__exceptions[] =
{
  0
};

::acdk::lang::dmi::ClazzMethodInfo LispObject_method_toString__LRString_ = 
{
  ::acdk::lang::dmi::MiPublic | acdk::lang::dmi::MiMethodInfo,// class flags, like static, Constructor
  0, // Meta Attribute
  "toString", // name of method
  -1, // nameHashCode
  "", // ns
  0, // _scopeParent
  0, // _nextScopeSibling
  RString::clazzInfo(), // return type
  0, // altname
  -1, // nameHashCode
  LispObject_methods_toString__LRString__args, // return the arguments
  0, // args num
  LispObject_methods_toString__LRString__exceptions, // the declared exceptions
  0 // address of method currently not supported
};

::acdk::lang::dmi::ClazzMethodInfo* _LispObject_methods[] = 
{
  &LispObject_method_GetClass__L_acdk_lang_RClass_,
  &LispObject_method_getClass__L_acdk_lang_RClass_,
  &LispObject_method_toString__LRString_,
  0
};

::acdk::lang::dmi::ClazzInfo LispObject::_clazzInfo =
{
  ::acdk::lang::dmi::MiCiWeakBind | ::acdk::lang::dmi::MiResolved | ::acdk::lang::dmi::MiClazzInfo, // clazz-flags
  0, // Meta Attribute
  "LispObject", // name of class
  -1, // nameHashCode
  "acdk/lisp", // the namespace
  0, // _scopeParent
  0, // _nextScopeSibling
  &LispObject::_clazzInfo,
   0, // _firstChild
  _LispObject_interfaces, // pointer to Array of ClazzInfo references
  0, // count of Super / Interfaces
  _LispObject_fields, // pointer to Array of fields
  0, // count of Fields
  _LispObject_methods, // pointer to Array of fields
  0, // count of Fields
  0, // create-function for cloning/serializing
  &LispObject::create_array, // create-function for cloning/serializing arrays
  &LispObject::create_array_array, // create-function for cloning/serializing arrays
  0, // Class* thisClass; chaching instance
  0, // jlong serialVersionUID; for serialization
  &LispObject::dynamic_dispatch, //
  &LispObject::static_dispatch, //&LispObject::StandardDispatch, // static_dispatch
  0, // count off all collectable members in this class
  0 // user defined info
};
static ::acdk::lang::dmi::RegisterClazzInfo _register_LispObject(LispObject::clazzInfo());

/*
//static
::acdk::lang::RObject
LispObject::create_array(int length)
{
  return new ObjectArrayImpl<RLispObject>(length);
}

//static
::acdk::lang::RObject
LispObject::create_array_array(int firstLength, int secondLength)
{
  return Nil;//not implemented yet
}
*/
/**
//virtual
const ::acdk::lang::dmi::ClazzMethodInfo* 
LispObject::standardDispatch(  const char* fname, ::acdk::lang::dmi::ScriptVar& ret, ::acdk::lang::dmi::ScriptVarArray& args, ::acdk::lang::dmi::DmiClient& dc, IN(::acdk::lang::RStringArray) namedArgs, int flags, const ::acdk::lang::dmi::ClazzMethodInfo* methinf)
{
  if (methinf == 0)
    methinf = ::acdk::lang::dmi::StdDispatch::lookupMethod(clazzInfo(), fname, args, namedArgs, dc, flags);
  if (&LispObject_method_getClass__L_acdk_lang_RClass_ == methinf) {
    ret = (::acdk::lang::RObject)getClass();
    return methinf;
  }
  if (&LispObject_method_toString__LRString_ == methinf) {
    ret = (::acdk::lang::RObject)toString();
    return methinf;
  }
#ifdef ACDK_NEED_FQ_SUPER_QUALIFIER
  if ((methinf = acdk::lang::Object::standardDispatch(fname, ret, args, dc, namedArgs, flags, methinf)) != 0)
#else //ACDK_NEED_FQ_SUPER_QUALIFIER
  if ((methinf = Object::standardDispatch(fname, ret, args, dc, namedArgs, flags, methinf)) != 0)
#endif //ACDK_NEED_FQ_SUPER_QUALIFIER
    return methinf;
  return StandardDispatch(fname, ret, args, dc, namedArgs, flags, methinf);
  return 0;
}
//static
const ::acdk::lang::dmi::ClazzMethodInfo* 
LispObject::StandardDispatch(const char* fname, ::acdk::lang::dmi::ScriptVar& ret, ::acdk::lang::dmi::ScriptVarArray& args, ::acdk::lang::dmi::DmiClient& dc, IN(::acdk::lang::RStringArray) namedArgs, int flags, const ::acdk::lang::dmi::ClazzMethodInfo* methinf)
{
  if (methinf == 0)
    methinf = ::acdk::lang::dmi::StdDispatch::lookupMethod(clazzInfo(), fname, args, namedArgs, dc, flags);
  if (&LispObject_method_GetClass__L_acdk_lang_RClass_ == methinf) {
    ret = (::acdk::lang::RObject)GetClass();
    return methinf;
  }
#ifdef ACDK_NEED_FQ_SUPER_QUALIFIER
  if ((methinf = acdk::lang::Object::StandardDispatch(fname, ret, args, dc, namedArgs, flags, methinf)) != 0)
#else //ACDK_NEED_FQ_SUPER_QUALIFIER
  if ((methinf = Object::StandardDispatch(fname, ret, args, dc, namedArgs, flags, methinf)) != 0)
#endif //ACDK_NEED_FQ_SUPER_QUALIFIER
    return methinf;
  return 0;
}
*/

} // namespace lisp
} // namespace acdk





<html><body>
<h1>Unit Test 2004-03-07T18:34:33</h1>
<a href="index.html">Back to Index</a><br>
<table border=0 width="100%"><tr><td bgcolor="red">TEST FAILED</td></tr></table>
Tests: 65; Failures: 0; Errors: 33<br>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#AalObject_Test.staticMember">AalObject_Test.staticMember</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#AalObject_Test.dynMember">AalObject_Test.dynMember</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AritmExpr_Test.incDec">AritmExpr_Test.incDec</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AritmExpr_Test.multiply">AritmExpr_Test.multiply</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Arrays_Test.basicArrays">Arrays_Test.basicArrays</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Arrays_Test.objectArrays">Arrays_Test.objectArrays</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.standard">Basics_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.syntax">Basics_Test.syntax</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.expressions">Basics_Test.expressions</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.statements">Basics_Test.statements</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.functionDecl">Basics_Test.functionDecl</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.CondAndLoops">Basics_Test.CondAndLoops</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectDecls">Basics_Test.objectDecls</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectCalls">Basics_Test.objectCalls</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectOperator">Basics_Test.objectOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.experimental">Basics_Test.experimental</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#BinaryExpr_Test.basicRels">BinaryExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Closure_Test.standard">Closure_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Compiler_Test.standard">Compiler_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Compiler_Test.grammar">Compiler_Test.grammar</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Compiler_Test.errors">Compiler_Test.errors</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#DefunStatements_Test.standard">DefunStatements_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#DeriveObject_Test.deriveAalObject">DeriveObject_Test.deriveAalObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#DeriveObject_Test.deriveAcdkObject">DeriveObject_Test.deriveAcdkObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Exceptions_Test.basicThrow">Exceptions_Test.basicThrow</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Exceptions_Test.catchAalException">Exceptions_Test.catchAalException</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Exceptions_Test.throwAckdCatchAalException">Exceptions_Test.throwAckdCatchAalException</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Exceptions_Test.aalExceptions">Exceptions_Test.aalExceptions</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ExtendClass_Test.extendClass">ExtendClass_Test.extendClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Functions_Test.standard">Functions_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.standard">Interpret_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.assignment">Interpret_Test.assignment</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.fqClassInvoke">Interpret_Test.fqClassInvoke</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.classOperator">Interpret_Test.classOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.derivedClass">Interpret_Test.derivedClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.interfaceClass">Interpret_Test.interfaceClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#LiteralWrapping_Test.wrappedStrings">LiteralWrapping_Test.wrappedStrings</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#LiteralWrapping_Test.wrappedNumbers">LiteralWrapping_Test.wrappedNumbers</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LogicalExpr_Test.basicRels">LogicalExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LogicalExpr_Test.operatorRels">LogicalExpr_Test.operatorRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Operator_Test.plusOperator">Operator_Test.plusOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Operator_Test.callOperator">Operator_Test.callOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Operator_Test.arrayOperator">Operator_Test.arrayOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.polymorph">ParameterPassing_Test.polymorph</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.namedParameter">ParameterPassing_Test.namedParameter</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.restParameter">ParameterPassing_Test.restParameter</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#RelExpr_Test.basicRels">RelExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#RelExpr_Test.operatorRels">RelExpr_Test.operatorRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#RelExpr_Test.equalsExpr">RelExpr_Test.equalsExpr</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.standard">Scanner_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.string">Scanner_Test.string</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.interactive">Scanner_Test.interactive</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.cComments">Scanner_Test.cComments</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.standard">Statements_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.varDecl">Statements_Test.varDecl</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.block">Statements_Test.block</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.whileStatement">Statements_Test.whileStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.doStatement">Statements_Test.doStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.forStatement">Statements_Test.forStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Statements_Test.gotoStatement">Statements_Test.gotoStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.ifStatement">Statements_Test.ifStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Statements_Test.switchStatement">Statements_Test.switchStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.expressionIf">Statements_Test.expressionIf</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#WeakInvoke_Test.callAalObject">WeakInvoke_Test.callAalObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#WeakInvoke_Test.callComObject">WeakInvoke_Test.callComObject</a> <br>
</td></tr></table>
<h2><a id="AalObject_Test.staticMember">AalObject_Test.staticMember</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 BaseClass.getIvar<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:STRT] Start Test: AalObject_Test.staticMember
[AUNIT:STRT] Start Test: AalObject_Test.staticMember
Parsed: [using acdk.lang;
class BaseClass { public static int ivar = 42; }
__assert(BaseClass.ivar == 42, "initialization of static members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
          'static'
        FqTypeName:
          TypeName:
            int
        VarName:
          ivar
        VarInitializer:
          Literal:
            : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      BaseClass
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        ivar
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : initialization of static members failed
Create Var this at idx: 0
BaseClass this
push "BaseClass" // classname
push "ivar" // fieldname
push 0 // dmi flags
poke_static // 
pop // 
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
push <undefined> // void return
ret  // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: ret  // 
3: push "BaseClass" // class name
4: push "ivar" // fieldname
5: push 0 // dmi flags
6: peek_static
7: push 42 // Terminal
8: eq
9: push "initialization of static members failed" // Terminal
10: assert
11: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
0: push 42 // Terminal
   Stack: 42 | 
1: push "BaseClass" // classname
   Stack: 42 | BaseClass | 
2: push "ivar" // fieldname
   Stack: 42 | BaseClass | ivar | 
3: push 0 // dmi flags
   Stack: 42 | BaseClass | ivar | 0 | 
4: poke_static // 
   Stack: 42 | 
5: pop // 
   Stack: 
6: push <undefined> // void return
   Stack: 
2: ret  // 
Parsed: [using acdk.lang;
class BaseClass { public static int ivar = 42; static int getIvar() { return BaseClass.ivar; return ivar; } }
__assert(BaseClass.getIvar() == 42, "initialization of static members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
          'static'
        FqTypeName:
          TypeName:
            int
        VarName:
          ivar
        VarInitializer:
          Literal:
            : 42
      ClassDeclMethod:
        ClassMemberAttr:
          'static'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          getIvar
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                SubscribeExpr:
                  VarName:
                    BaseClass
                  MemberSubscribeExpr:
                    '.'
                    VarName:
                      ivar
            Statement:
              ReturnStatement:
                VarName:
                  ivar
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      BaseClass
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          getIvar
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : initialization of static members failed
Create Var this at idx: 0
BaseClass this
[AUNIT:ERRR] Error in Test: AalObject_Test.staticMember: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: AalObject_Test.staticMember: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="AalObject_Test.dynMember">AalObject_Test.dynMember</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 BaseClass.getString<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: AalObject_Test.staticMember
[AUNIT:ENDT] End Test: AalObject_Test.staticMember
[AUNIT:STRT] Start Test: AalObject_Test.dynMember
[AUNIT:STRT] Start Test: AalObject_Test.dynMember
Parsed: [using acdk.lang;
class BaseClass { public BaseClass() {} String getString() { return "A"; } }
__assert((new BaseClass()).getString().length() == 1, "initialization of dynamic members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              String
        MethodName:
          getString
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : A
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    NewExpr:
                      FqTypeName:
                        TypeName:
                          BaseClass
                      Arguments:
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          getString
                        FuncSubscribeExpr:
                          Arguments:
                        MemberSubscribeExpr:
                          '.'
                          SubscribeExpr:
                            VarName:
                              length
                            FuncSubscribeExpr:
                              Arguments:
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : initialization of dynamic members failed
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
BaseClass this
[AUNIT:ERRR] Error in Test: AalObject_Test.dynMember: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: AalObject_Test.dynMember: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="AritmExpr_Test.incDec">AritmExpr_Test.incDec</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: AalObject_Test.dynMember
[AUNIT:ENDT] End Test: AalObject_Test.dynMember
[AUNIT:STRT] Start Test: AritmExpr_Test.incDec
[AUNIT:STRT] Start Test: AritmExpr_Test.incDec
Parsed: [int i = 0;
int j = ++i;
--i;
__assert(j == 1 && i == 0, "Prefix ++ not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        PrefixExpr:
          '++'
          VarName:
            i
  Statement:
    ExprStatement:
      PrefixExpr:
        '--'
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                LogicalANDExpr:
                  EqualityExpr:
                    VarName:
                      j
                    '=='
                    Literal:
                      : 1
                  '&&'
                  EqualityExpr:
                    VarName:
                      i
                    '=='
                    Literal:
                      : 0
              Argument:
                Literal:
                  : Prefix ++ not working
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 0 // i
inc // prefix inc/dec
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
dec // prefix inc/dec
pop // discarge expression result for ExprStatement
load 1 // j
eq
dup // safe lh expr result
brfalse logexprend1 // bool short-circuit
pop // remove lh expr result
load 0 // i
eq
logexprend1: nop // 
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: loadref 0 // i
11: inc // prefix inc/dec
12: loadref 1 // j
13: assign
14: pop // discarge expression result for ExprStatement
15: loadref 0 // i
16: dec // prefix inc/dec
17: pop // discarge expression result for ExprStatement
18: load 1 // j
19: push 1 // Terminal
20: eq
21: dup // safe lh expr result
22: brfalse logexprend1 // bool short-circuit
23: pop // remove lh expr result
24: load 0 // i
25: push 0 // Terminal
26: eq
27: logexprend1: nop // 
28: push "Prefix ++ not working" // Terminal
29: assert
30: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: inc // prefix inc/dec
   Stack: 1 | 
12: loadref 1 // j
   Stack: 1 | &0 | 
13: assign
   Stack: 1 | 
14: pop // discarge expression result for ExprStatement
   Stack: 
15: loadref 0 // i
   Stack: &1 | 
16: dec // prefix inc/dec
   Stack: 0 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: load 1 // j
   Stack: 1 | 
19: push 1 // Terminal
   Stack: 1 | 1 | 
20: eq
   Stack: true | 
21: dup // safe lh expr result
   Stack: true | true | 
22: brfalse logexprend1 // bool short-circuit
   Stack: true | 
23: pop // remove lh expr result
   Stack: 
24: load 0 // i
   Stack: 0 | 
25: push 0 // Terminal
   Stack: 0 | 0 | 
26: eq
   Stack: true | 
27: logexprend1: nop // 
   Stack: true | 
28: push "Prefix ++ not working" // Terminal
   Stack: true | Prefix ++ not working | 
29: assert
   Stack: true | 
30: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
int j = i++;
--i;
__assert(j == 0 && i == 0, "Postfix ++ not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        PostfixExpr:
          VarName:
            i
          '++'
  Statement:
    ExprStatement:
      PrefixExpr:
        '--'
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                LogicalANDExpr:
                  EqualityExpr:
                    VarName:
                      j
                    '=='
                    Literal:
                      : 0
                  '&&'
                  EqualityExpr:
                    VarName:
                      i
                    '=='
                    Literal:
                      : 0
              Argument:
                Literal:
                  : Postfix ++ not working
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 0 // i
Create Var __tvar1 at idx: 2
dupval // postfix expression temp
clvr 2 // postfix expression temp
store 2
inc // prefix inc/dec
pop // postfix expression temp erg
load 2
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
dec // prefix inc/dec
pop // discarge expression result for ExprStatement
load 1 // j
eq
dup // safe lh expr result
brfalse logexprend2 // bool short-circuit
pop // remove lh expr result
load 0 // i
eq
logexprend2: nop // 
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: loadref 0 // i
11: dupval // postfix expression temp
12: clvr 2 // postfix expression temp
13: store 2
14: inc // prefix inc/dec
15: pop // postfix expression temp erg
16: load 2
17: loadref 1 // j
18: assign
19: pop // discarge expression result for ExprStatement
20: loadref 0 // i
21: dec // prefix inc/dec
22: pop // discarge expression result for ExprStatement
23: load 1 // j
24: push 0 // Terminal
25: eq
26: dup // safe lh expr result
27: brfalse logexprend2 // bool short-circuit
28: pop // remove lh expr result
29: load 0 // i
30: push 0 // Terminal
31: eq
32: logexprend2: nop // 
33: push "Postfix ++ not working" // Terminal
34: assert
35: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: dupval // postfix expression temp
   Stack: &0 | 0 | 
12: clvr 2 // postfix expression temp
   Stack: &0 | 0 | 
13: store 2
   Stack: &0 | 
14: inc // prefix inc/dec
   Stack: 1 | 
15: pop // postfix expression temp erg
   Stack: 
16: load 2
   Stack: 0 | 
17: loadref 1 // j
   Stack: 0 | &0 | 
18: assign
   Stack: 0 | 
19: pop // discarge expression result for ExprStatement
   Stack: 
20: loadref 0 // i
   Stack: &1 | 
21: dec // prefix inc/dec
   Stack: 0 | 
22: pop // discarge expression result for ExprStatement
   Stack: 
23: load 1 // j
   Stack: 0 | 
24: push 0 // Terminal
   Stack: 0 | 0 | 
25: eq
   Stack: true | 
26: dup // safe lh expr result
   Stack: true | true | 
27: brfalse logexprend2 // bool short-circuit
   Stack: true | 
28: pop // remove lh expr result
   Stack: 
29: load 0 // i
   Stack: 0 | 
30: push 0 // Terminal
   Stack: 0 | 0 | 
31: eq
   Stack: true | 
32: logexprend2: nop // 
   Stack: true | 
33: push "Postfix ++ not working" // Terminal
   Stack: true | Postfix ++ not working | 
34: assert
   Stack: true | 
35: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="AritmExpr_Test.multiply">AritmExpr_Test.multiply</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: AritmExpr_Test.incDec
[AUNIT:ENDT] End Test: AritmExpr_Test.incDec
[AUNIT:STRT] Start Test: AritmExpr_Test.multiply
[AUNIT:STRT] Start Test: AritmExpr_Test.multiply
Parsed: [__assert((2 * 3) == 6 , "multiply not working");
__assert((6 / 2) == 3 , "divide not working");
__assert((7 % 2) == 1, "modulo not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 2
                    '*'
                    Literal:
                      : 3
                  '=='
                  Literal:
                    : 6
              Argument:
                Literal:
                  : multiply not working
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 6
                    '/'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : divide not working
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 7
                    '%'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : modulo not working
mul
eq
assert
pop // discarge expression result for ExprStatement
div
eq
assert
pop // discarge expression result for ExprStatement
mod
eq
assert
pop // discarge expression result for ExprStatement
0: push 2 // Terminal
1: push 3 // Terminal
2: mul
3: push 6 // Terminal
4: eq
5: push "multiply not working" // Terminal
6: assert
7: pop // discarge expression result for ExprStatement
8: push 6 // Terminal
9: push 2 // Terminal
10: div
11: push 3 // Terminal
12: eq
13: push "divide not working" // Terminal
14: assert
15: pop // discarge expression result for ExprStatement
16: push 7 // Terminal
17: push 2 // Terminal
18: mod
19: push 1 // Terminal
20: eq
21: push "modulo not working" // Terminal
22: assert
23: pop // discarge expression result for ExprStatement
   Stack: 
0: push 2 // Terminal
   Stack: 2 | 
1: push 3 // Terminal
   Stack: 2 | 3 | 
2: mul
   Stack: 6 | 
3: push 6 // Terminal
   Stack: 6 | 6 | 
4: eq
   Stack: true | 
5: push "multiply not working" // Terminal
   Stack: true | multiply not working | 
6: assert
   Stack: true | 
7: pop // discarge expression result for ExprStatement
   Stack: 
8: push 6 // Terminal
   Stack: 6 | 
9: push 2 // Terminal
   Stack: 6 | 2 | 
10: div
   Stack: 3.000000 | 
11: push 3 // Terminal
   Stack: 3.000000 | 3 | 
12: eq
   Stack: true | 
13: push "divide not working" // Terminal
   Stack: true | divide not working | 
14: assert
   Stack: true | 
15: pop // discarge expression result for ExprStatement
   Stack: 
16: push 7 // Terminal
   Stack: 7 | 
17: push 2 // Terminal
   Stack: 7 | 2 | 
18: mod
   Stack: 1 | 
19: push 1 // Terminal
   Stack: 1 | 1 | 
20: eq
   Stack: true | 
21: push "modulo not working" // Terminal
   Stack: true | modulo not working | 
22: assert
   Stack: true | 
23: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Arrays_Test.basicArrays">Arrays_Test.basicArrays</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 int[].length<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: AritmExpr_Test.multiply
[AUNIT:ENDT] End Test: AritmExpr_Test.multiply
[AUNIT:STRT] Start Test: Arrays_Test.basicArrays
[AUNIT:STRT] Start Test: Arrays_Test.basicArrays
Parsed: [int[] ia = new int[](2);
ia[0] = 42;
ia[1] = 43;
__assert(ia[0] == 42, "basic Arrays failed");
__assert(ia[1] == 43, "basic Arrays failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
        ArrayDims:
          ArrayDim:
      VarName:
        ia
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              int
            ArrayDims:
              ArrayDim:
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            ia
          ArraySubscribeExpr:
            Literal:
              : 0
        '='
        Literal:
          : 42
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            ia
          ArraySubscribeExpr:
            Literal:
              : 1
        '='
        Literal:
          : 43
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 0
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : basic Arrays failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 1
                  '=='
                  Literal:
                    : 43
              Argument:
                Literal:
                  : basic Arrays failed
Create Var ia at idx: 0
clvr 0 // ia
push Nil // initialize local value
store 0 // initialize local value
push "int" // array element class name
push 1103806595072 // dmi flags = 0, argcount = 1
newarr
loadref 0 // ia
assign
pop // discarge expression result for ExprStatement
loadref 0 // ia
ldarelref // array element access
assign
pop // discarge expression result for ExprStatement
loadref 0 // ia
ldarelref // array element access
assign
pop // discarge expression result for ExprStatement
load 0 // ia
ldarel // array element access
eq
assert
pop // discarge expression result for ExprStatement
load 0 // ia
ldarel // array element access
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // ia
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: push "int" // array element class name
5: push 1103806595072 // dmi flags = 0, argcount = 1
6: newarr
7: loadref 0 // ia
8: assign
9: pop // discarge expression result for ExprStatement
10: push 42 // Terminal
11: loadref 0 // ia
12: push 0 // Terminal
13: ldarelref // array element access
14: assign
15: pop // discarge expression result for ExprStatement
16: push 43 // Terminal
17: loadref 0 // ia
18: push 1 // Terminal
19: ldarelref // array element access
20: assign
21: pop // discarge expression result for ExprStatement
22: load 0 // ia
23: push 0 // Terminal
24: ldarel // array element access
25: push 42 // Terminal
26: eq
27: push "basic Arrays failed" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: load 0 // ia
31: push 1 // Terminal
32: ldarel // array element access
33: push 43 // Terminal
34: eq
35: push "basic Arrays failed" // Terminal
36: assert
37: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // ia
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: push "int" // array element class name
   Stack: 2 | int | 
5: push 1103806595072 // dmi flags = 0, argcount = 1
   Stack: 2 | int | 1103806595072 | 
6: newarr
   Stack: [0, 0] | 
7: loadref 0 // ia
   Stack: [0, 0] | &Nil | 
8: assign
   Stack: [0, 0] | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: push 42 // Terminal
   Stack: 42 | 
11: loadref 0 // ia
   Stack: 42 | &[0, 0] | 
12: push 0 // Terminal
   Stack: 42 | &[0, 0] | 0 | 
13: ldarelref // array element access
   Stack: 42 | &0 | 
14: assign
   Stack: 42 | 
15: pop // discarge expression result for ExprStatement
   Stack: 
16: push 43 // Terminal
   Stack: 43 | 
17: loadref 0 // ia
   Stack: 43 | &[42, 0] | 
18: push 1 // Terminal
   Stack: 43 | &[42, 0] | 1 | 
19: ldarelref // array element access
   Stack: 43 | &0 | 
20: assign
   Stack: 43 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: load 0 // ia
   Stack: [42, 43] | 
23: push 0 // Terminal
   Stack: [42, 43] | 0 | 
24: ldarel // array element access
   Stack: 42 | 
25: push 42 // Terminal
   Stack: 42 | 42 | 
26: eq
   Stack: true | 
27: push "basic Arrays failed" // Terminal
   Stack: true | basic Arrays failed | 
28: assert
   Stack: true | 
29: pop // discarge expression result for ExprStatement
   Stack: 
30: load 0 // ia
   Stack: [42, 43] | 
31: push 1 // Terminal
   Stack: [42, 43] | 1 | 
32: ldarel // array element access
   Stack: 43 | 
33: push 43 // Terminal
   Stack: 43 | 43 | 
34: eq
   Stack: true | 
35: push "basic Arrays failed" // Terminal
   Stack: true | basic Arrays failed | 
36: assert
   Stack: true | 
37: pop // discarge expression result for ExprStatement
Parsed: [int[] ia = new int[](2);
__assert(ia.length() == 2, "basic Arrays length failed");
__assert(ia[0] == 0, "basic Arrays default field initialization failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
        ArrayDims:
          ArrayDim:
      VarName:
        ia
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              int
            ArrayDims:
              ArrayDim:
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          length
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : basic Arrays length failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 0
                  '=='
                  Literal:
                    : 0
              Argument:
                Literal:
                  : basic Arrays default field initialization failed
Create Var ia at idx: 0
[AUNIT:ERRR] Error in Test: Arrays_Test.basicArrays: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Arrays_Test.basicArrays: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Arrays_Test.objectArrays">Arrays_Test.objectArrays</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Arrays_Test.basicArrays
[AUNIT:ENDT] End Test: Arrays_Test.basicArrays
[AUNIT:STRT] Start Test: Arrays_Test.objectArrays
[AUNIT:STRT] Start Test: Arrays_Test.objectArrays
Parsed: [] to
CodeText:
 SymbolTable: [
 ]
</pre>
<h2><a id="Basics_Test.standard">Basics_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Arrays_Test.objectArrays
[AUNIT:ENDT] End Test: Arrays_Test.objectArrays
[AUNIT:STRT] Start Test: Basics_Test.standard
[AUNIT:STRT] Start Test: Basics_Test.standard
</pre>
<h2><a id="Basics_Test.syntax">Basics_Test.syntax</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.standard
[AUNIT:ENDT] End Test: Basics_Test.standard
[AUNIT:STRT] Start Test: Basics_Test.syntax
[AUNIT:STRT] Start Test: Basics_Test.syntax
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'CKeyWord'
test:
  'AKeyWord'
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'CKeyWord'
FLOATING_POINT_LITERAL
: ([0-9])+\.([0-9])+
;

ThrowStatement
: 'throw'& [ Expression ] ';'& $
;

LogicalOROp
: '||'
;

EqualsExpr
: RelationalExpr [ EqualsOp EqualsExpr ] %
;

ReturnStatement
: 'return'& [ Expression ]';'& $
;

SubscribeExpr
: PrimaryExpr ( ArraySubscribeExpr | MemberSubscribeExpr | FuncSubscribeExpr  )* %
;

ClassDeclMember
: ClassMemberAttr FqTypeName VarName ( ';'& | VarInitializer ';'& ) $
;

AdditiveOp
: '+' | '-'
;

PostfixExpr
: SubscribeExpr [ PostfixOp ] % [ PostfixExpr ] 
;

AssignmentOp
: '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='
;

AdditiveExpr
: MultiplicativeExpr [ AdditiveOp AdditiveExpr ]  %
;

ElseStatement
: 'else'& ! Statement $
;

Argument
: [ Label ':'& ] Expression $
;

CXX_COMMENT
: 
;

ForStatement
: 'for'& ! '('& ( EmptyStatement| VarDecl | ExprStatement ) ( Expression | EmptyExpression) ';'& ( Expression | EmptyExpression ) ')'& Statement $ 
;

Variable
: Identifier $
;

MethodName
: IDENTIFIER $
;

CatchBlock
: 'catch'& '('& FqTypeName VarName ')'& Statement $
;

DerivedSuperDef
: 'extends'& ! FqTypeName $
;

PrimaryExpr
: '('& Expression ')'& | 'operator'&  Operator | VarName | Literal
;

PostfixOp
: '++' | '--' $
;

ConditionalExpr
: LogicalORExpr [ '?'& AssignmentExpr ':'& AssignmentExpr ] %
;

ShiftOp
: '>>' | '>>>' | '<<'
;

Statements
: ( Statement )*
;

HEX_LITERAL
: 0[xX][0-9a-fA-F]+[LISB]?
;

Expression
: AssignmentExpr
;

ArrayDims
: ( ArrayDim )* %
;

SIGNED_DEC_LITERAL
: ([\+\-])?([0-9])+[LISB]?
;

EqualsOp
: '===' | '!=='
;

TryCatchStatement
: 'try'& Statement ( CatchBlock )* [ FinallyBlock ] $
;

ClassDeclConstructorInitializerList
:  [ ':'& ClassDeclConstructorInitializer ( ','& ClassDeclConstructorInitializer )* ] $
;

FqTypeName
: TypeName ( '.'& FqTypeName )* ArrayDims  $
;

C_COMMENT
: 
;

LogicalANDExpr
: BitwiseORExpr [ LogicalANDOp  LogicalANDExpr ] %
;

LVarDecl
: FqTypeName VarName ( ';'& | VarInitializer ';'& ) $
;

Literal
: ( BOOLEAN_LITERAL | STRING_LITERAL | HEX_LITERAL | FLOATING_POINT_LITERAL  | OCTAL_LITERAL | SIGNED_DEC_LITERAL ) %
;

InterfaceDeclDef
: 'interface'& ! TypeName (InterfaceDef | ';'&) $
;

NewArrayArguments
: ( NewArrayArgument )+ $
;

BOOLEAN_LITERAL
: 'true' $ | 'false' $ | 'nil' $
;

ExtendStatement
: 'extend' ClassMemberAttr ReturnType FqTypeName FunctionParamsDecl FunctionBlock $
;

DEC_LITERAL
: ([0-9])+[LISB]?
;

OPERATOR
: 
;

ClassDeclElement
: ClassDeclMember | ClassDeclMethod | ClassDeclConstructor | ClassDeclOperator
;

ClosureExpr
: 'new'& ClosureArguments ClassDef $
;

FuncSubscribeExpr
: Arguments $
;

PrefixExpr
: NewExpr | ClosureExpr | [ PrefixOp ] % PostfixExpr
;

EmptyStatement
: ';'& $ 
;

MultiplicativeExpr
: CastExpr [ MultiplicativeOp MultiplicativeExpr ] %
;

GotoStatement
: 'goto'& Label ';'& $ 
;

DerivedDef
: [ DerivedSuperDef ] [ DerivedInterfaceDef ] $
;

InterfaceDef
: InterfaceDerivedDef ClassDeclBody
;

ClassMemberAttr
: ( 'public' | 'protected' | 'private' | 'foreign' | 'static' )* %
;

ArraySubscribeExpr
: '['& Expression ']'& $
;

Operator
: ( '+' | '-' | '*' | '/' | '.' | '<<=' | '>>=' | '<<' | '>>' | ',' | '!' | '~' | '==' | '=' | '+=' | '-=' | '<' | '>' | '<=' | '>=' | '==' | '!=' | '[' ']' | '(' ')' | OPERATOR) $
;

AssignmentExpr
: ConditionalExpr [ AssignmentOp AssignmentExpr ] %
;

Identifier
: IDENTIFIER $
;

DoStatement
: 'do'& ! Statement 'while'& '('& Expression ')'& ';'& $ 
;

test
: 'AKeyWord' ( 'BKeyWord' | 'CKeyWord' ) 'DKeyWord'
;

SwitchStatement
: 'switch'& '('& Expression ')'& '{'& ( CaseClause )* '}'& $ 
;

ClosureArgumentList
: VarName ( ','& VarName )* %
;

BreakStatement
: 'break' ';'& $
;

FunctionParamsDecl
: '('& ')'& $ |  '('& Parameter ( ','& Parameter )* ')'& $
;

EqualityOp
: '==' | '!='
;

InterfaceDerivedDef
: [ DerivedInterfaceDef ] $
;

ClassDeclConstructor
: ClassMemberAttr MethodName FunctionParamsDecl ClassDeclConstructorInitializerList  ( ';' | FunctionBlock ) $
;

FunctionDeclDef
: ClassDeclMethod $
;

UsingDecl
: 'using'& FqTypeName ';'& $
;

ClassDeclMethod
: ClassMemberAttr ReturnType MethodName  FunctionParamsDecl !  ( ';' | FunctionBlock ) $ 
;

VarInitializer
: '='& ( AssignmentExpr | ConditionalExpr ) $
;

OCTAL_LITERAL
: 0[0-7]+
;

EmptyExpression
:  $
;

BaseExpr
: AssignmentExpr 
;

LeftHandVariable
: Identifier $
;

STRING_LITERAL
: 
;

BitwiseXORExpr
: BitwiseANDExpr [ BitwiseXOROp BitwiseXORExpr ] %
;

NewExpr
: 'new'& FqTypeName ( Arguments ) $
;

BitwiseOROp
: '|'
;

FunctionBlock
: Block $
;

ClassDeclBody
: '{'& ( ClassDeclElement )* '}'& 
;

ReturnType
: FqTypeName $
;

LogicalANDOp
: '&&'
;

EqualityExpr
: EqualsExpr [ EqualityOp EqualityExpr ] %
;

ArgumentList
: Argument ( ','& Argument )* %
;

ClassDef
: DerivedDef ClassDeclBody
;

LogicalORExpr
: LogicalANDExpr [ LogicalOROp  LogicalORExpr ] %
;

ExprStatement
: Expression ';'& $
;

IfStatement
: 'if'& ! '('& Expression ')'& Statement [ ElseStatement ]  $
;

VarDecl
: LVarDecl
;

Arguments
: '('& ')'& $ | '('& ArgumentList ')'& $
;

MemberSubscribeExpr
: MemberSubscribeOp SubscribeExpr $
;

ClassDeclDef
: 'class'& ! TypeName (ClassDef | ';'&) $
;

CaseClause
: ( 'case' Expression | 'default' ) ':'& ( Statement )* $
;

DefunDecl
: 'defun'& TypeName ClassMemberAttr ReturnType FunctionParamsDecl ';'& $
;

ClassDeclOperator
: ClassMemberAttr ReturnType 'operator'&  Operator FunctionParamsDecl !  ( ';' | FunctionBlock ) $ 
;

RelationalOp
: '<' | '>' | '<=' | '>='
;

WhileStatement
: 'while'& '('& Expression ')'& Statement $ 
;

Block
: '{'& Statements '}'& $
;

BitwiseANDOp
: '&'
;

TypeName
: IDENTIFIER $
;

CastExpr
: '('& FqTypeName ')'&  CastExpr $ | PrefixExpr
;

MultiplicativeOp
: '*' | '%' | '/' 
;

ArrayDim
: '['& ']'& $
;

NewArrayArgument
: '['& [ Expression ] ']'& $
;

Label
: IDENTIFIER $
;

DerivedInterfaceDef
: 'implements'& ! FqTypeName ( ','& FqTypeName )* $
;

LabeledStatement
: Label ':'& [ Statement ] $ 
;

NamespaceDecl
: 'namespace'& TypeName '{'& Statements '}'& $
;

CodeText
: Statements
;

ShiftExpr
: AdditiveExpr [ ShiftOp ShiftExpr ] %
;

VarName
: IDENTIFIER $
;

RelationalExpr
: ShiftExpr [ RelationalOp RelationalExpr ] %
;

FinallyBlock
: 'finally'& Statement $
;

BitwiseANDExpr
: EqualityExpr [ BitwiseANDOp BitwiseANDExpr ] %
;

ContinueStatement
: 'continue' ';'& $
;

IDENTIFIER
: [a-zA-Z_][a-zA-Z_0-9]*
;

ClosureArguments
: '('& ')'& $ | '('& ClosureArgumentList ')'&  $
;

TypeDecl
: ClassDeclDef | InterfaceDeclDef | FunctionDeclDef
;

Statement
: Block 
 |ReturnStatement 
 |IfStatement 
 |ContinueStatement 
 |BreakStatement 
 |DoStatement 
 |WhileStatement 
 |ForStatement 
 |GotoStatement 
 |ThrowStatement 
 |TryCatchStatement 
 |LabeledStatement
 |SwitchStatement 
 |DefunDecl 
 | ExtendStatement
 |VarDecl 
 | TypeDecl 
 | NamespaceDecl 
 | UsingDecl 
 | ExprStatement 
 |EmptyStatement
;

Parameter
: FqTypeName VarName $
;

MemberSubscribeOp
: '.' | '->'
;

ClassDeclConstructorInitializer
: FqTypeName Arguments $
;

PrefixOp
: '++' | '--' | '-' | '+' | '~' | '!'
;

BitwiseXOROp
: '^'
;

BitwiseORExpr
: BitwiseXORExpr [ BitwiseOROp BitwiseORExpr ] %
;

test:
  'AKeyWord'
  'CKeyWord'
  'DKeyWord'
test:
  'param'
  ','
  'param'
test:
  'param'
  ','
  'param'
  ','
  'param'
test:
  'A'
test:
  'A'
  'B'
test:
  'A'
  'B'
  'B'
test:
  mlt:
    'a'
  '+'
  mlt:
    'b'
    '*'
    'c'
  '+'
  mlt:
    zahl:
      'd'
</pre>
<h2><a id="Basics_Test.expressions">Basics_Test.expressions</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.syntax
[AUNIT:ENDT] End Test: Basics_Test.syntax
[AUNIT:STRT] Start Test: Basics_Test.expressions
[AUNIT:STRT] Start Test: Basics_Test.expressions
Parsed: [ a + b]
Expression:
  AdditiveExpr:
    VarName:
      a
    '+'
    VarName:
      b
Parsed: [a == b]
Expression:
  EqualityExpr:
    VarName:
      a
    '=='
    VarName:
      b
Parsed: [a != b]
Expression:
  EqualityExpr:
    VarName:
      a
    '!='
    VarName:
      b
Parsed: [a == b ? a : b]
Expression:
  ConditionalExpr:
    EqualityExpr:
      VarName:
        a
      '=='
      VarName:
        b
    VarName:
      a
    VarName:
      b
Parsed: [a==b?a:b]
Expression:
  ConditionalExpr:
    EqualityExpr:
      VarName:
        a
      '=='
      VarName:
        b
    VarName:
      a
    VarName:
      b
Parsed: [acdk.lang.Object]
FqTypeName:
  TypeName:
    acdk
  FqTypeName:
    TypeName:
      lang
    FqTypeName:
      TypeName:
        Object
</pre>
<h2><a id="Basics_Test.statements">Basics_Test.statements</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.expressions
[AUNIT:ENDT] End Test: Basics_Test.expressions
[AUNIT:STRT] Start Test: Basics_Test.statements
[AUNIT:STRT] Start Test: Basics_Test.statements
Parsed: [a;]
Statement:
  ExprStatement:
    VarName:
      a
Parsed: [b = a;]
Statement:
  ExprStatement:
    AssignmentExpr:
      VarName:
        b
      '='
      VarName:
        a
Parsed: [b + a;]
Statement:
  ExprStatement:
    AdditiveExpr:
      VarName:
        b
      '+'
      VarName:
        a
Parsed: [j = k + 1;]
Statement:
  ExprStatement:
    AssignmentExpr:
      VarName:
        j
      '='
      AdditiveExpr:
        VarName:
          k
        '+'
        Literal:
          : 1
Parsed: [int i = 0; i = i + 1;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        AdditiveExpr:
          VarName:
            i
          '+'
          Literal:
            : 1
</pre>
<h2><a id="Basics_Test.functionDecl">Basics_Test.functionDecl</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.statements
[AUNIT:ENDT] End Test: Basics_Test.statements
[AUNIT:STRT] Start Test: Basics_Test.functionDecl
[AUNIT:STRT] Start Test: Basics_Test.functionDecl
Parsed: [int foo(int i, int j)
{
  return i + j;
}
void bar() { }
]
CodeText:
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              j
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  VarName:
                    j
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          bar
        FunctionParamsDecl:
        FunctionBlock:
          Block:
</pre>
<h2><a id="Basics_Test.CondAndLoops">Basics_Test.CondAndLoops</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.functionDecl
[AUNIT:ENDT] End Test: Basics_Test.functionDecl
[AUNIT:STRT] Start Test: Basics_Test.CondAndLoops
[AUNIT:STRT] Start Test: Basics_Test.CondAndLoops
Parsed: [if (true) i = 3;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            i
          '='
          Literal:
            : 3
Parsed: [if (true) { }]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
Parsed: [if (true) { a = i; b = x; }]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                a
              '='
              VarName:
                i
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                b
              '='
              VarName:
                x
Parsed: [if (true) { } else x = 4;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
    ElseStatement:
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              x
            '='
            Literal:
              : 4
Parsed: [if (true) { } else if (false) x = 4;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
    ElseStatement:
      Statement:
        IfStatement:
          Literal:
            BOOLEAN_LITERAL:
              'false'
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  x
                '='
                Literal:
                  : 4
Parsed: [while (true) x = 1;]
Statement:
  WhileStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            x
          '='
          Literal:
            : 1
Parsed: [while (true) {}]
Statement:
  WhileStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
Parsed: [do x = 1; while (true);]
Statement:
  DoStatement:
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            x
          '='
          Literal:
            : 1
    Literal:
      BOOLEAN_LITERAL:
        'true'
Parsed: [do { } while (true);]
Statement:
  DoStatement:
    Statement:
      Block:
    Literal:
      BOOLEAN_LITERAL:
        'true'
Parsed: [switch(x) { case a : case b: x = 1; break; default: break; }]
Statement:
  SwitchStatement:
    VarName:
      x
    CaseClause:
      'case'
      VarName:
        a
    CaseClause:
      'case'
      VarName:
        b
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              x
            '='
            Literal:
              : 1
      Statement:
        BreakStatement:
          'break'
    CaseClause:
      'default'
      Statement:
        BreakStatement:
          'break'
</pre>
<h2><a id="Basics_Test.objectDecls">Basics_Test.objectDecls</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.CondAndLoops
[AUNIT:ENDT] End Test: Basics_Test.CondAndLoops
[AUNIT:STRT] Start Test: Basics_Test.objectDecls
[AUNIT:STRT] Start Test: Basics_Test.objectDecls
Parsed: [class AClass { }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
Parsed: [class AClass { int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMember:
        FqTypeName:
          TypeName:
            int
        VarName:
          ival
Parsed: [class AClass { void foo() { } }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
Parsed: [class AClass { public void foo() { } static int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
      ClassDeclMember:
        ClassMemberAttr:
          'static'
        FqTypeName:
          TypeName:
            int
        VarName:
          ival
Parsed: [class AClass { void foo(int i) { } int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
      ClassDeclMember:
        FqTypeName:
          TypeName:
            int
        VarName:
          ival
Parsed: [class AClass { void foo(int i) { ival = i; } int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
      ClassDeclMember:
        FqTypeName:
          TypeName:
            int
        VarName:
          ival
Parsed: [class AClass { int ival; void foo(int i) { ival = i; }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMember:
        FqTypeName:
          TypeName:
            int
        VarName:
          ival
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
Parsed: [class AClass { AClass(int i) { ival = i; }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
Parsed: [class AClass { AClass(int i) : ival(i) { }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                ival
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
Parsed: [class AClass extends acdk.lang.Object { }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  Object
</pre>
<h2><a id="Basics_Test.objectCalls">Basics_Test.objectCalls</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.objectDecls
[AUNIT:ENDT] End Test: Basics_Test.objectDecls
[AUNIT:STRT] Start Test: Basics_Test.objectCalls
[AUNIT:STRT] Start Test: Basics_Test.objectCalls
Parsed: [o = new Object();]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          o
        '='
        NewExpr:
          FqTypeName:
            TypeName:
              Object
          Arguments:
Parsed: [acdk.lang.Object s;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              Object
      VarName:
        s
Parsed: [acdk.lang.Object s = a;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              Object
      VarName:
        s
      VarInitializer:
        VarName:
          a
Parsed: [acdk.lang.Object s = new Object();]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              Object
      VarName:
        s
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              Object
          Arguments:
Parsed: [acdk.lang.Object s = new acdk.lang.String(1);]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              Object
      VarName:
        s
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  String
          Arguments:
            Argument:
              Literal:
                : 1
Parsed: [o.member = x;]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              member
        '='
        VarName:
          x
Parsed: [o1 = a2.m2;
o.foo(x);
o.foo(x)[i];
o.foo = x;
o.foo[i] = x;
o[i] = x;
o[i].bar = x;
o[i].foo() = x;
]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          o1
        '='
        SubscribeExpr:
          VarName:
            a2
          MemberSubscribeExpr:
            '.'
            VarName:
              m2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    x
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    x
            ArraySubscribeExpr:
              VarName:
                i
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              foo
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                foo
              ArraySubscribeExpr:
                VarName:
                  i
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
          MemberSubscribeExpr:
            '.'
            VarName:
              bar
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                foo
              FuncSubscribeExpr:
                Arguments:
        '='
        VarName:
          x
Parsed: [(o).toString();
(i + 1).toString();
]
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              toString
            FuncSubscribeExpr:
              Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        AdditiveExpr:
          VarName:
            i
          '+'
          Literal:
            : 1
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              toString
            FuncSubscribeExpr:
              Arguments:
Parsed: [(((foo(i)[j].bar + 1)(v) + 2).bar + 4)[x];
]
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        AdditiveExpr:
          SubscribeExpr:
            AdditiveExpr:
              SubscribeExpr:
                AdditiveExpr:
                  SubscribeExpr:
                    VarName:
                      foo
                    FuncSubscribeExpr:
                      Arguments:
                        Argument:
                          VarName:
                            i
                    ArraySubscribeExpr:
                      VarName:
                        j
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        bar
                  '+'
                  Literal:
                    : 1
                FuncSubscribeExpr:
                  Arguments:
                    Argument:
                      VarName:
                        v
              '+'
              Literal:
                : 2
            MemberSubscribeExpr:
              '.'
              VarName:
                bar
          '+'
          Literal:
            : 4
        ArraySubscribeExpr:
          VarName:
            x
Parsed: [s = (new acdk.lang.Object()).toString();]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          NewExpr:
            FqTypeName:
              TypeName:
                acdk
              FqTypeName:
                TypeName:
                  lang
                FqTypeName:
                  TypeName:
                    Object
            Arguments:
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
</pre>
<h2><a id="Basics_Test.objectOperator">Basics_Test.objectOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.objectCalls
[AUNIT:ENDT] End Test: Basics_Test.objectCalls
[AUNIT:STRT] Start Test: Basics_Test.objectOperator
[AUNIT:STRT] Start Test: Basics_Test.objectOperator
Parsed: [class AClass { String operator+(String s) { return "AClass"; } }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclOperator:
        ReturnType:
          FqTypeName:
            TypeName:
              String
        Operator:
          +
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                String
            VarName:
              s
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : AClass
Parsed: [a + 42;]
CodeText:
  Statement:
    ExprStatement:
      AdditiveExpr:
        VarName:
          a
        '+'
        Literal:
          : 42
</pre>
<h2><a id="Basics_Test.experimental">Basics_Test.experimental</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.objectOperator
[AUNIT:ENDT] End Test: Basics_Test.objectOperator
[AUNIT:STRT] Start Test: Basics_Test.experimental
[AUNIT:STRT] Start Test: Basics_Test.experimental
</pre>
<h2><a id="BinaryExpr_Test.basicRels">BinaryExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Basics_Test.experimental
[AUNIT:ENDT] End Test: Basics_Test.experimental
[AUNIT:STRT] Start Test: BinaryExpr_Test.basicRels
[AUNIT:STRT] Start Test: BinaryExpr_Test.basicRels
Parsed: [__assert(1 & 3, "binary and does not work");
__assert((1 | 2) == 3, "binary or does not work");
__assert((3 ^ 2) == 1, "binary xor does not work");
__assert((1 << 2) == 4, "binary left shift does not work");
__assert((4 >> 2) == 1, "binary right shift does not work");
__assert((-4 >> 2) == -1, "binary right shift on neg values does not work");
int i = -4;
__assert((i >>> 2) == 1073741823, "binary right unsigned shift does not work");
i = 42;
__assert(~i == -43, "binary not does not work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                BitwiseANDExpr:
                  Literal:
                    : 1
                  '&'
                  Literal:
                    : 3
              Argument:
                Literal:
                  : binary and does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  BitwiseORExpr:
                    Literal:
                      : 1
                    '|'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : binary or does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  BitwiseXORExpr:
                    Literal:
                      : 3
                    '^'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : binary xor does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : 1
                    '<<'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : binary left shift does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : 4
                    '>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : binary right shift does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : -4
                    '>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : -1
              Argument:
                Literal:
                  : binary right shift on neg values does not work
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : -4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    VarName:
                      i
                    '>>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1073741823
              Argument:
                Literal:
                  : binary right unsigned shift does not work
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        Literal:
          : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  PrefixExpr:
                    '~'
                    VarName:
                      i
                  '=='
                  Literal:
                    : -43
              Argument:
                Literal:
                  : binary not does not work
Create Var i at idx: 0
band // binary op: &
assert
pop // discarge expression result for ExprStatement
bor // binary op: |
eq
assert
pop // discarge expression result for ExprStatement
bxor // binary op: ^
eq
assert
pop // discarge expression result for ExprStatement
bshl // binary op: <<
eq
assert
pop // discarge expression result for ExprStatement
bshr // binary op: >>
eq
assert
pop // discarge expression result for ExprStatement
bshr // binary op: >>
eq
assert
pop // discarge expression result for ExprStatement
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
bshrus // binary op: >>>
eq
assert
pop // discarge expression result for ExprStatement
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
bnot // negation
eq
assert
pop // discarge expression result for ExprStatement
0: push 1 // Terminal
1: push 3 // Terminal
2: band // binary op: &
3: push "binary and does not work" // Terminal
4: assert
5: pop // discarge expression result for ExprStatement
6: push 1 // Terminal
7: push 2 // Terminal
8: bor // binary op: |
9: push 3 // Terminal
10: eq
11: push "binary or does not work" // Terminal
12: assert
13: pop // discarge expression result for ExprStatement
14: push 3 // Terminal
15: push 2 // Terminal
16: bxor // binary op: ^
17: push 1 // Terminal
18: eq
19: push "binary xor does not work" // Terminal
20: assert
21: pop // discarge expression result for ExprStatement
22: push 1 // Terminal
23: push 2 // Terminal
24: bshl // binary op: <<
25: push 4 // Terminal
26: eq
27: push "binary left shift does not work" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: push 4 // Terminal
31: push 2 // Terminal
32: bshr // binary op: >>
33: push 1 // Terminal
34: eq
35: push "binary right shift does not work" // Terminal
36: assert
37: pop // discarge expression result for ExprStatement
38: push -4 // Terminal
39: push 2 // Terminal
40: bshr // binary op: >>
41: push -1 // Terminal
42: eq
43: push "binary right shift on neg values does not work" // Terminal
44: assert
45: pop // discarge expression result for ExprStatement
46: clvr 0 // i
47: push 0 // initialize local value
48: store 0 // initialize local value
49: push -4 // Terminal
50: loadref 0 // i
51: assign
52: pop // discarge expression result for ExprStatement
53: load 0 // i
54: push 2 // Terminal
55: bshrus // binary op: >>>
56: push 1073741823 // Terminal
57: eq
58: push "binary right unsigned shift does not work" // Terminal
59: assert
60: pop // discarge expression result for ExprStatement
61: push 42 // Terminal
62: loadref 0 // i
63: assign
64: pop // discarge expression result for ExprStatement
65: loadref 0 // i
66: bnot // negation
67: push -43 // Terminal
68: eq
69: push "binary not does not work" // Terminal
70: assert
71: pop // discarge expression result for ExprStatement
   Stack: 
0: push 1 // Terminal
   Stack: 1 | 
1: push 3 // Terminal
   Stack: 1 | 3 | 
2: band // binary op: &
   Stack: 1 | 
3: push "binary and does not work" // Terminal
   Stack: 1 | binary and does not work | 
4: assert
   Stack: true | 
5: pop // discarge expression result for ExprStatement
   Stack: 
6: push 1 // Terminal
   Stack: 1 | 
7: push 2 // Terminal
   Stack: 1 | 2 | 
8: bor // binary op: |
   Stack: 3 | 
9: push 3 // Terminal
   Stack: 3 | 3 | 
10: eq
   Stack: true | 
11: push "binary or does not work" // Terminal
   Stack: true | binary or does not work | 
12: assert
   Stack: true | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 3 // Terminal
   Stack: 3 | 
15: push 2 // Terminal
   Stack: 3 | 2 | 
16: bxor // binary op: ^
   Stack: 1 | 
17: push 1 // Terminal
   Stack: 1 | 1 | 
18: eq
   Stack: true | 
19: push "binary xor does not work" // Terminal
   Stack: true | binary xor does not work | 
20: assert
   Stack: true | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: push 1 // Terminal
   Stack: 1 | 
23: push 2 // Terminal
   Stack: 1 | 2 | 
24: bshl // binary op: <<
   Stack: 4 | 
25: push 4 // Terminal
   Stack: 4 | 4 | 
26: eq
   Stack: true | 
27: push "binary left shift does not work" // Terminal
   Stack: true | binary left shift does not work | 
28: assert
   Stack: true | 
29: pop // discarge expression result for ExprStatement
   Stack: 
30: push 4 // Terminal
   Stack: 4 | 
31: push 2 // Terminal
   Stack: 4 | 2 | 
32: bshr // binary op: >>
   Stack: 1 | 
33: push 1 // Terminal
   Stack: 1 | 1 | 
34: eq
   Stack: true | 
35: push "binary right shift does not work" // Terminal
   Stack: true | binary right shift does not work | 
36: assert
   Stack: true | 
37: pop // discarge expression result for ExprStatement
   Stack: 
38: push -4 // Terminal
   Stack: -4 | 
39: push 2 // Terminal
   Stack: -4 | 2 | 
40: bshr // binary op: >>
   Stack: -1 | 
41: push -1 // Terminal
   Stack: -1 | -1 | 
42: eq
   Stack: true | 
43: push "binary right shift on neg values does not work" // Terminal
   Stack: true | binary right shift on neg values does not work | 
44: assert
   Stack: true | 
45: pop // discarge expression result for ExprStatement
   Stack: 
46: clvr 0 // i
   Stack: 
47: push 0 // initialize local value
   Stack: 0 | 
48: store 0 // initialize local value
   Stack: 
49: push -4 // Terminal
   Stack: -4 | 
50: loadref 0 // i
   Stack: -4 | &0 | 
51: assign
   Stack: -4 | 
52: pop // discarge expression result for ExprStatement
   Stack: 
53: load 0 // i
   Stack: -4 | 
54: push 2 // Terminal
   Stack: -4 | 2 | 
55: bshrus // binary op: >>>
   Stack: 1073741823 | 
56: push 1073741823 // Terminal
   Stack: 1073741823 | 1073741823 | 
57: eq
   Stack: true | 
58: push "binary right unsigned shift does not work" // Terminal
   Stack: true | binary right unsigned shift does not work | 
59: assert
   Stack: true | 
60: pop // discarge expression result for ExprStatement
   Stack: 
61: push 42 // Terminal
   Stack: 42 | 
62: loadref 0 // i
   Stack: 42 | &-4 | 
63: assign
   Stack: 42 | 
64: pop // discarge expression result for ExprStatement
   Stack: 
65: loadref 0 // i
   Stack: &42 | 
66: bnot // negation
   Stack: -43 | 
67: push -43 // Terminal
   Stack: -43 | -43 | 
68: eq
   Stack: true | 
69: push "binary not does not work" // Terminal
   Stack: true | binary not does not work | 
70: assert
   Stack: true | 
71: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Closure_Test.standard">Closure_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.IFace<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: BinaryExpr_Test.basicRels
[AUNIT:ENDT] End Test: BinaryExpr_Test.basicRels
[AUNIT:STRT] Start Test: Closure_Test.standard
[AUNIT:STRT] Start Test: Closure_Test.standard
Parsed: [interface IFace { public int foo(); }
int i = 42;
class AClass implements IFace { int i; public AClass(int i_) : i(i_) {} public int foo() { return i; } }
IFace acls = new AClass(i);
IFace iface = new (i) implements IFace { public int foo() { return i; } };
iface.foo();
] to
CodeText:
  Statement:
    InterfaceDeclDef:
      TypeName:
        IFace
      InterfaceDerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          foo
        FunctionParamsDecl:
        ';'
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 42
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
          FqTypeName:
            TypeName:
              IFace
      ClassDeclMember:
        FqTypeName:
          TypeName:
            int
        VarName:
          i
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i_
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                i
            Arguments:
              Argument:
                VarName:
                  i_
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                VarName:
                  i
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          IFace
      VarName:
        acls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
            Argument:
              VarName:
                i
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          IFace
      VarName:
        iface
      VarInitializer:
        ClosureExpr:
          ClosureArguments:
            VarName:
              i
          DerivedDef:
            DerivedInterfaceDef:
              FqTypeName:
                TypeName:
                  IFace
          ClassDeclMethod:
            ClassMemberAttr:
              'public'
            ReturnType:
              FqTypeName:
                TypeName:
                  int
            MethodName:
              foo
            FunctionParamsDecl:
            FunctionBlock:
              Block:
                Statement:
                  ReturnStatement:
                    VarName:
                      i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          iface
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
Create Var this at idx: 0
IFace this
Create Var this at idx: 0
IFace this
Create Var i at idx: 0
Create Var i_ at idx: 0
int i_
Create Var this at idx: 0
AClass this
int i_
Create Var this at idx: 0
AClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      i
  Arguments:
    Argument:
      VarName:
        i_
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      IFace
  Arguments:
[AUNIT:ERRR] Error in Test: Closure_Test.standard: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Closure_Test.standard: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Compiler_Test.standard">Compiler_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Closure_Test.standard
[AUNIT:ENDT] End Test: Closure_Test.standard
[AUNIT:STRT] Start Test: Compiler_Test.standard
[AUNIT:STRT] Start Test: Compiler_Test.standard
Test:
  ARule:
    'A'
</pre>
<h2><a id="Compiler_Test.grammar">Compiler_Test.grammar</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> cannot find matching terminal: XC<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Compiler_Test.standard
[AUNIT:ENDT] End Test: Compiler_Test.standard
[AUNIT:STRT] Start Test: Compiler_Test.grammar
[AUNIT:STRT] Start Test: Compiler_Test.grammar
[AUNIT:ERRR] Error in Test: Compiler_Test.grammar: acdk/lang/Exception
[AUNIT:ERRR] Error in Test: Compiler_Test.grammar: acdk/lang/Exception
Called in:
</pre>
<h2><a id="Compiler_Test.errors">Compiler_Test.errors</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Compiler_Test.grammar
[AUNIT:ENDT] End Test: Compiler_Test.grammar
[AUNIT:STRT] Start Test: Compiler_Test.errors
[AUNIT:STRT] Start Test: Compiler_Test.errors
Expected Ex: cannot find matching terminal: AX
</pre>
<h2><a id="DefunStatements_Test.standard">DefunStatements_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.adder<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Compiler_Test.errors
[AUNIT:ENDT] End Test: Compiler_Test.errors
[AUNIT:STRT] Start Test: DefunStatements_Test.standard
[AUNIT:STRT] Start Test: DefunStatements_Test.standard
Parsed: [defun Incrementator static int (int value);
class AClass { public int adder(int value) { return value + 1; } }
AClass acls = new AClass();
Incrementator inc = acls.adder;
inc(41);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    DefunDecl:
      TypeName:
        Incrementator
      ClassMemberAttr:
        'static'
      ReturnType:
        FqTypeName:
          TypeName:
            int
      FunctionParamsDecl:
        Parameter:
          FqTypeName:
            TypeName:
              int
          VarName:
            value
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          adder
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              value
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    value
                  '+'
                  Literal:
                    : 1
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AClass
      VarName:
        acls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          Incrementator
      VarName:
        inc
      VarInitializer:
        SubscribeExpr:
          VarName:
            acls
          MemberSubscribeExpr:
            '.'
            VarName:
              adder
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          inc
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 41
Create Var value at idx: 0
int value
Create Var value at idx: 0
int value
Create Var this at idx: 0
AClass this
int value
Create Var this at idx: 0
AClass this
Create Var acls at idx: 0
Create Var inc at idx: 1
[AUNIT:ERRR] Error in Test: DefunStatements_Test.standard: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: DefunStatements_Test.standard: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="DeriveObject_Test.deriveAalObject">DeriveObject_Test.deriveAalObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 ExtClass.BaseClass<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: DefunStatements_Test.standard
[AUNIT:ENDT] End Test: DefunStatements_Test.standard
[AUNIT:STRT] Start Test: DeriveObject_Test.deriveAalObject
[AUNIT:STRT] Start Test: DeriveObject_Test.deriveAalObject
Parsed: [using acdk.lang;
class BaseClass { public int _ivar; public BaseClass(int i) : _ivar(i) {} }
class ExtClass extends BaseClass { public ExtClass(int i) : BaseClass(i) {} } 
ExtClass extcls = new ExtClass(42);
__assert(extcls._ivar == 42, "Base Aal class Contructor initialization failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
        FqTypeName:
          TypeName:
            int
        VarName:
          _ivar
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                _ivar
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    ClassDeclDef:
      TypeName:
        ExtClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            TypeName:
              BaseClass
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          ExtClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                BaseClass
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          ExtClass
      VarName:
        extcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              ExtClass
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      extcls
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        _ivar
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : Base Aal class Contructor initialization failed
Create Var i at idx: 0
int i
Create Var this at idx: 0
BaseClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      _ivar
  Arguments:
    Argument:
      VarName:
        i
Create Var i at idx: 0
int i
Create Var this at idx: 0
ExtClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      BaseClass
  Arguments:
    Argument:
      VarName:
        i
[AUNIT:ERRR] Error in Test: DeriveObject_Test.deriveAalObject: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: DeriveObject_Test.deriveAalObject: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="DeriveObject_Test.deriveAcdkObject">DeriveObject_Test.deriveAcdkObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 ExtInteger.Integer<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: DeriveObject_Test.deriveAalObject
[AUNIT:ENDT] End Test: DeriveObject_Test.deriveAalObject
[AUNIT:STRT] Start Test: DeriveObject_Test.deriveAcdkObject
[AUNIT:STRT] Start Test: DeriveObject_Test.deriveAcdkObject
Parsed: [using acdk.lang;
class ExtInteger extends acdk.lang.Integer { public ExtInteger(int i) : acdk.lang.Integer(i) {} } 
ExtInteger eint = new ExtInteger(42);
String s = eint.toString();
__assert(s.equals("42") == true, "calling super AcdkObject method failed");
s = ExtInteger.toString(42);
__assert(s.equals("42") == true, "calling super AcdkObject static method failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        ExtInteger
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  Integer
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          ExtInteger
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                acdk
              FqTypeName:
                TypeName:
                  lang
                FqTypeName:
                  TypeName:
                    Integer
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          ExtInteger
      VarName:
        eint
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              ExtInteger
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          VarName:
            eint
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : calling super AcdkObject method failed
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            ExtInteger
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : calling super AcdkObject static method failed
Create Var i at idx: 0
int i
Create Var this at idx: 0
ExtInteger this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      acdk
    FqTypeName:
      TypeName:
        lang
      FqTypeName:
        TypeName:
          Integer
  Arguments:
    Argument:
      VarName:
        i
[AUNIT:ERRR] Error in Test: DeriveObject_Test.deriveAcdkObject: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: DeriveObject_Test.deriveAcdkObject: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Exceptions_Test.basicThrow">Exceptions_Test.basicThrow</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: DeriveObject_Test.deriveAcdkObject
[AUNIT:ENDT] End Test: DeriveObject_Test.deriveAcdkObject
[AUNIT:STRT] Start Test: Exceptions_Test.basicThrow
[AUNIT:STRT] Start Test: Exceptions_Test.basicThrow
Parsed: [using acdk.lang;
throw new Exception("asdf");

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ThrowStatement:
      NewExpr:
        FqTypeName:
          TypeName:
            Exception
        Arguments:
          Argument:
            Literal:
              : asdf
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
0: push "asdf" // Terminal
1: push "acdk.lang.Exception" // class name
2: push 4294967296 // dmi flags = 0, argcount = 1
3: new
4: throw // throws an exception
   Stack: 
0: push "asdf" // Terminal
   Stack: asdf | 
1: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
2: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
3: new
   Stack: acdk/lang/Exception | 
4: throw // throws an exception
</pre>
<h2><a id="Exceptions_Test.catchAalException">Exceptions_Test.catchAalException</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.io.PrintWriter.println<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Exceptions_Test.basicThrow
[AUNIT:ENDT] End Test: Exceptions_Test.basicThrow
[AUNIT:STRT] Start Test: Exceptions_Test.catchAalException
[AUNIT:STRT] Start Test: Exceptions_Test.catchAalException
Parsed: [using acdk.lang;
try {
  throw new Exception("asdf");
} catch (Exception ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ThrowStatement:
              NewExpr:
                FqTypeName:
                  TypeName:
                    Exception
                Arguments:
                  Argument:
                    Literal:
                      : asdf
      CatchBlock:
        FqTypeName:
          TypeName:
            Exception
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var ex at idx: 0
[AUNIT:ERRR] Error in Test: Exceptions_Test.catchAalException: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Exceptions_Test.catchAalException: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Exceptions_Test.throwAckdCatchAalException">Exceptions_Test.throwAckdCatchAalException</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.Object.toString<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Exceptions_Test.catchAalException
[AUNIT:ENDT] End Test: Exceptions_Test.catchAalException
[AUNIT:STRT] Start Test: Exceptions_Test.throwAckdCatchAalException
[AUNIT:STRT] Start Test: Exceptions_Test.throwAckdCatchAalException
Parsed: [using acdk.lang;
try {
  Object o;
  o.toString();
} catch (NullPointerException ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            LVarDecl:
              FqTypeName:
                TypeName:
                  Object
              VarName:
                o
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  o
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      toString
                    FuncSubscribeExpr:
                      Arguments:
      CatchBlock:
        FqTypeName:
          TypeName:
            NullPointerException
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var o at idx: 0
[AUNIT:ERRR] Error in Test: Exceptions_Test.throwAckdCatchAalException: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Exceptions_Test.throwAckdCatchAalException: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Exceptions_Test.aalExceptions">Exceptions_Test.aalExceptions</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 MyException.Exception<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Exceptions_Test.throwAckdCatchAalException
[AUNIT:ENDT] End Test: Exceptions_Test.throwAckdCatchAalException
[AUNIT:STRT] Start Test: Exceptions_Test.aalExceptions
[AUNIT:STRT] Start Test: Exceptions_Test.aalExceptions
Parsed: [using acdk.lang;
class MyException extends acdk.lang.Exception { public MyException(String msg) : Exception(msg) {} }
try {
  throw new MyException("Test");
} catch (MyException ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        MyException
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  Exception
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          MyException
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                String
            VarName:
              msg
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                Exception
            Arguments:
              Argument:
                VarName:
                  msg
        FunctionBlock:
          Block:
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ThrowStatement:
              NewExpr:
                FqTypeName:
                  TypeName:
                    MyException
                Arguments:
                  Argument:
                    Literal:
                      : Test
      CatchBlock:
        FqTypeName:
          TypeName:
            MyException
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var msg at idx: 0
acdk.lang.String msg
Create Var this at idx: 0
MyException this
acdk.lang.String msg
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      Exception
  Arguments:
    Argument:
      VarName:
        msg
[AUNIT:ERRR] Error in Test: Exceptions_Test.aalExceptions: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Exceptions_Test.aalExceptions: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="ExtendClass_Test.extendClass">ExtendClass_Test.extendClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 48,2: Cannot find semantic element: _ivar<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Exceptions_Test.aalExceptions
[AUNIT:ENDT] End Test: Exceptions_Test.aalExceptions
[AUNIT:STRT] Start Test: ExtendClass_Test.extendClass
[AUNIT:STRT] Start Test: ExtendClass_Test.extendClass
Parsed: [using acdk.lang;
class BaseClass { public int _ivar; public BaseClass(int i) : _ivar(i) {} }
extend int BaseClass.foo(int i) { return _ivar + i; }
BaseClass cls = new BaseClass(42);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
        FqTypeName:
          TypeName:
            int
        VarName:
          _ivar
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              TypeName:
                _ivar
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    ExtendStatement:
      'extend'
      ReturnType:
        FqTypeName:
          TypeName:
            int
      FqTypeName:
        TypeName:
          BaseClass
        FqTypeName:
          TypeName:
            foo
      FunctionParamsDecl:
        Parameter:
          FqTypeName:
            TypeName:
              int
          VarName:
            i
      FunctionBlock:
        Block:
          Statement:
            ReturnStatement:
              AdditiveExpr:
                VarName:
                  _ivar
                '+'
                VarName:
                  i
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          BaseClass
      VarName:
        cls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              BaseClass
          Arguments:
            Argument:
              Literal:
                : 42
Create Var i at idx: 0
int i
Create Var this at idx: 0
BaseClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      _ivar
  Arguments:
    Argument:
      VarName:
        i
Create Var i at idx: 0
int i
[AUNIT:ERRR] Error in Test: ExtendClass_Test.extendClass: acdk/lang/Exception
[AUNIT:ERRR] Error in Test: ExtendClass_Test.extendClass: acdk/lang/Exception
Called in:
</pre>
<h2><a id="Functions_Test.standard">Functions_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> NullPointerException<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: ExtendClass_Test.extendClass
[AUNIT:ENDT] End Test: ExtendClass_Test.extendClass
[AUNIT:STRT] Start Test: Functions_Test.standard
[AUNIT:STRT] Start Test: Functions_Test.standard
Parsed: [class Foo { public static int operator()(int i) { return i + 1; } }
int foo(int i) { return i + 1; }
foo(41);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        Foo
      DerivedDef:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        Operator:
          ()
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          foo
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 41
Create Var i at idx: 0
int i
Create Var this at idx: 0
Foo this
[AUNIT:ERRR] Error in Test: Functions_Test.standard: acdk/lang/NullPointerException
[AUNIT:ERRR] Error in Test: Functions_Test.standard: acdk/lang/NullPointerException
Called in:
</pre>
<h2><a id="Interpret_Test.standard">Interpret_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.StringBuffer.append<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Functions_Test.standard
[AUNIT:ENDT] End Test: Functions_Test.standard
[AUNIT:STRT] Start Test: Interpret_Test.standard
[AUNIT:STRT] Start Test: Interpret_Test.standard
Create Var erg at idx: 0
   Stack: 
-1: clvr 0 // global var
   Stack:  | 
-1: store 0 // global var
Parsed: [erg = new acdk.lang.String("asdf");] to
CodeText:
 SymbolTable: [
  acdk.lang.String erg
 ]
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          erg
        '='
        NewExpr:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  String
          Arguments:
            Argument:
              Literal:
                : asdf
push "acdk.lang.String" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // erg
assign
pop // discarge expression result for ExprStatement
0: push "asdf" // Terminal
1: push "acdk.lang.String" // class name
2: push 4294967296 // dmi flags = 0, argcount = 1
3: new
4: loadref 0 // erg
5: assign
6: pop // discarge expression result for ExprStatement
   Stack: 
0: push "asdf" // Terminal
   Stack: asdf | 
1: push "acdk.lang.String" // class name
   Stack: asdf | acdk.lang.String | 
2: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.String | 4294967296 | 
3: new
   Stack: asdf | 
4: loadref 0 // erg
   Stack: asdf | & | 
5: assign
   Stack: asdf | 
6: pop // discarge expression result for ExprStatement
   Stack: 
6: load 0 // read global var
[AUNIT:SUCC]: Interpret_Test.standard:
.\acdk_aal_Interpret_Test.cpp(112): terg->equals("asdf") == true
Parsed: [acdk.lang.StringBuffer sb = new acdk.lang.StringBuffer("Hello ");
sb.append("ACDK");
acdk.lang.System.out.println(sb.toString());
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              StringBuffer
      VarName:
        sb
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  StringBuffer
          Arguments:
            Argument:
              Literal:
                : Hello 
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          sb
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              append
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : ACDK
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          acdk
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              lang
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  System
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      out
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          println
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              SubscribeExpr:
                                VarName:
                                  sb
                                MemberSubscribeExpr:
                                  '.'
                                  SubscribeExpr:
                                    VarName:
                                      toString
                                    FuncSubscribeExpr:
                                      Arguments:
Create Var sb at idx: 0
[AUNIT:ERRR] Error in Test: Interpret_Test.standard: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Interpret_Test.standard: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Interpret_Test.assignment">Interpret_Test.assignment</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.standard
[AUNIT:ENDT] End Test: Interpret_Test.standard
[AUNIT:STRT] Start Test: Interpret_Test.assignment
[AUNIT:STRT] Start Test: Interpret_Test.assignment
Parsed: [int i = 0;
int j = 0; i = j = 42;
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        AssignmentExpr:
          VarName:
            j
          '='
          Literal:
            : 42
Create Var i at idx: 0
Create Var j at idx: 1
CodeText:
 SymbolTable: [
  int i
  int j
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      ExprStatement:
        AssignmentExpr:Sem=[j=int] ExprSem=[j=int]
          VarName:Sem=[j=int] ExprSem=[j=int]
            j
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    ExprStatement:
      AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '='
        AssignmentExpr:Sem=[j=int] ExprSem=[j=int]
          VarName:Sem=[j=int] ExprSem=[j=int]
            j
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 42
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 1 // j
assign
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: push 0 // Terminal
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: push 42 // Terminal
15: loadref 1 // j
16: assign
17: loadref 0 // i
18: assign
19: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: push 0 // Terminal
   Stack: 0 | 
11: loadref 1 // j
   Stack: 0 | &0 | 
12: assign
   Stack: 0 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 42 // Terminal
   Stack: 42 | 
15: loadref 1 // j
   Stack: 42 | &0 | 
16: assign
   Stack: 42 | 
17: loadref 0 // i
   Stack: 42 | &0 | 
18: assign
   Stack: 42 | 
19: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.fqClassInvoke">Interpret_Test.fqClassInvoke</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> NullPointerException<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.assignment
[AUNIT:ENDT] End Test: Interpret_Test.assignment
[AUNIT:STRT] Start Test: Interpret_Test.fqClassInvoke
[AUNIT:STRT] Start Test: Interpret_Test.fqClassInvoke
Parsed: [acdk.lang.System.out.println("hello from Aal");
] to
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          acdk
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              lang
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  System
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      out
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          println
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : hello from Aal
[AUNIT:ERRR] Error in Test: Interpret_Test.fqClassInvoke: acdk/lang/NullPointerException
[AUNIT:ERRR] Error in Test: Interpret_Test.fqClassInvoke: acdk/lang/NullPointerException
Called in:
</pre>
<h2><a id="Interpret_Test.classOperator">Interpret_Test.classOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.operator_pl<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.fqClassInvoke
[AUNIT:ENDT] End Test: Interpret_Test.fqClassInvoke
[AUNIT:STRT] Start Test: Interpret_Test.classOperator
[AUNIT:STRT] Start Test: Interpret_Test.classOperator
Parsed: [class AClass { AClass() { } acdk.lang.String operator+(acdk.lang.String s) { return "AClass String"; } }
AClass a = new AClass();
acdk.lang.String s1 = a.operator_pl("asdf");
s1 = a + "asdf";
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ReturnType:
          FqTypeName:
            TypeName:
              acdk
            FqTypeName:
              TypeName:
                lang
              FqTypeName:
                TypeName:
                  String
        Operator:
          +
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                acdk
              FqTypeName:
                TypeName:
                  lang
                FqTypeName:
                  TypeName:
                    String
            VarName:
              s
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : AClass String
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AClass
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              String
      VarName:
        s1
      VarInitializer:
        SubscribeExpr:
          VarName:
            a
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                operator_pl
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : asdf
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s1
        '='
        AdditiveExpr:
          VarName:
            a
          '+'
          Literal:
            : asdf
Create Var this at idx: 0
AClass this
Create Var s at idx: 0
acdk.lang.String s
Create Var this at idx: 0
AClass this
acdk.lang.String s
Create Var a at idx: 0
Create Var s1 at idx: 1
[AUNIT:ERRR] Error in Test: Interpret_Test.classOperator: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Interpret_Test.classOperator: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Interpret_Test.derivedClass">Interpret_Test.derivedClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.print<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.classOperator
[AUNIT:ENDT] End Test: Interpret_Test.classOperator
[AUNIT:STRT] Start Test: Interpret_Test.derivedClass
[AUNIT:STRT] Start Test: Interpret_Test.derivedClass
Parsed: [class AClass { protected AClass() { this.print(); print(); } public void print() { acdk.lang.System.out.println("Call AClass.print "); } }
class BClass extends AClass { public BClass() { } }
BClass bcls = new BClass();
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'protected'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    this
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        print
                      FuncSubscribeExpr:
                        Arguments:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    print
                  FuncSubscribeExpr:
                    Arguments:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          print
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    acdk
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        lang
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            System
                          MemberSubscribeExpr:
                            '.'
                            SubscribeExpr:
                              VarName:
                                out
                              MemberSubscribeExpr:
                                '.'
                                SubscribeExpr:
                                  VarName:
                                    println
                                  FuncSubscribeExpr:
                                    Arguments:
                                      Argument:
                                        Literal:
                                          : Call AClass.print 
  Statement:
    ClassDeclDef:
      TypeName:
        BClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            TypeName:
              AClass
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          BClass
      VarName:
        bcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              BClass
          Arguments:
Create Var this at idx: 0
AClass this
Create Var this at idx: 0
AClass this
[AUNIT:ERRR] Error in Test: Interpret_Test.derivedClass: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Interpret_Test.derivedClass: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Interpret_Test.interfaceClass">Interpret_Test.interfaceClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.AInterface<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.derivedClass
[AUNIT:ENDT] End Test: Interpret_Test.derivedClass
[AUNIT:STRT] Start Test: Interpret_Test.interfaceClass
[AUNIT:STRT] Start Test: Interpret_Test.interfaceClass
Parsed: [interface AInterface { AInterface() {} void foo(); }
class AClass implements AInterface { AClass() {} void foo() { acdk.lang.System.out.println("Hello from InterfaceImplemenation"); } }
AInterface iface = new AClass();
iface->foo();
] to
CodeText:
  Statement:
    InterfaceDeclDef:
      TypeName:
        AInterface
      InterfaceDerivedDef:
      ClassDeclConstructor:
        MethodName:
          AInterface
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
        ';'
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
          FqTypeName:
            TypeName:
              AInterface
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    acdk
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        lang
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            System
                          MemberSubscribeExpr:
                            '.'
                            SubscribeExpr:
                              VarName:
                                out
                              MemberSubscribeExpr:
                                '.'
                                SubscribeExpr:
                                  VarName:
                                    println
                                  FuncSubscribeExpr:
                                    Arguments:
                                      Argument:
                                        Literal:
                                          : Hello from InterfaceImplemenation
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AInterface
      VarName:
        iface
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          iface
        MemberSubscribeExpr:
          '->'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
Create Var this at idx: 0
AInterface this
Create Var this at idx: 0
AInterface this
Create Var this at idx: 0
AClass this
Create Var this at idx: 0
AClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    TypeName:
      AInterface
  Arguments:
[AUNIT:ERRR] Error in Test: Interpret_Test.interfaceClass: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Interpret_Test.interfaceClass: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="LiteralWrapping_Test.wrappedStrings">LiteralWrapping_Test.wrappedStrings</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.String.length<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Interpret_Test.interfaceClass
[AUNIT:ENDT] End Test: Interpret_Test.interfaceClass
[AUNIT:STRT] Start Test: LiteralWrapping_Test.wrappedStrings
[AUNIT:STRT] Start Test: LiteralWrapping_Test.wrappedStrings
Parsed: [int i = "Text".length();
__assert(i == 4, "string literal object wrapper");
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        SubscribeExpr:
          Literal:
            : Text
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                length
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : string literal object wrapper
Create Var i at idx: 0
[AUNIT:ERRR] Error in Test: LiteralWrapping_Test.wrappedStrings: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: LiteralWrapping_Test.wrappedStrings: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="LiteralWrapping_Test.wrappedNumbers">LiteralWrapping_Test.wrappedNumbers</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 byte.toString<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: LiteralWrapping_Test.wrappedStrings
[AUNIT:ENDT] End Test: LiteralWrapping_Test.wrappedStrings
[AUNIT:STRT] Start Test: LiteralWrapping_Test.wrappedNumbers
[AUNIT:STRT] Start Test: LiteralWrapping_Test.wrappedNumbers
Parsed: [acdk.lang.String s = 42.toString();
__assert(s.equals("42") == true, "string literal object wrapper");
int i = 41;
s = i.toString();
__assert(s.equals("41") == true, "string literal object wrapper");
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              String
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          Literal:
            : 42
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : string literal object wrapper
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 41
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            i
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 41
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : string literal object wrapper
Create Var s at idx: 0
[AUNIT:ERRR] Error in Test: LiteralWrapping_Test.wrappedNumbers: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: LiteralWrapping_Test.wrappedNumbers: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="LogicalExpr_Test.basicRels">LogicalExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: LiteralWrapping_Test.wrappedNumbers
[AUNIT:ENDT] End Test: LiteralWrapping_Test.wrappedNumbers
[AUNIT:STRT] Start Test: LogicalExpr_Test.basicRels
[AUNIT:STRT] Start Test: LogicalExpr_Test.basicRels
Parsed: [false && __assert(false, "should never reached");
true || __assert(false, "should never reached");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      LogicalANDExpr:
        Literal:
          BOOLEAN_LITERAL:
            'false'
        '&&'
        SubscribeExpr:
          VarName:
            __assert
          FuncSubscribeExpr:
            Arguments:
              ArgumentList:
                Argument:
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
                Argument:
                  Literal:
                    : should never reached
  Statement:
    ExprStatement:
      LogicalORExpr:
        Literal:
          BOOLEAN_LITERAL:
            'true'
        '||'
        SubscribeExpr:
          VarName:
            __assert
          FuncSubscribeExpr:
            Arguments:
              ArgumentList:
                Argument:
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
                Argument:
                  Literal:
                    : should never reached
push false // false
dup // safe lh expr result
brfalse logexprend1 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend1: nop // 
pop // discarge expression result for ExprStatement
push true // true
dup // safe lh expr result
brtrue logexprend2 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend2: nop // 
pop // discarge expression result for ExprStatement
0: push false // false
1: dup // safe lh expr result
2: brfalse logexprend1 // bool short-circuit
3: pop // remove lh expr result
4: push false // false
5: push "should never reached" // Terminal
6: assert
7: logexprend1: nop // 
8: pop // discarge expression result for ExprStatement
9: push true // true
10: dup // safe lh expr result
11: brtrue logexprend2 // bool short-circuit
12: pop // remove lh expr result
13: push false // false
14: push "should never reached" // Terminal
15: assert
16: logexprend2: nop // 
17: pop // discarge expression result for ExprStatement
   Stack: 
0: push false // false
   Stack: false | 
1: dup // safe lh expr result
   Stack: false | false | 
2: brfalse logexprend1 // bool short-circuit
   Stack: false | 
8: pop // discarge expression result for ExprStatement
   Stack: 
9: push true // true
   Stack: true | 
10: dup // safe lh expr result
   Stack: true | true | 
11: brtrue logexprend2 // bool short-circuit
   Stack: true | 
17: pop // discarge expression result for ExprStatement
Parsed: [42 == 42 && 41 > 42 && __assert(false, "should never reached");
42 == 41 && 41 > 42 && __assert(false, "should never reached");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      LogicalANDExpr:
        EqualityExpr:
          Literal:
            : 42
          '=='
          Literal:
            : 42
        '&&'
        LogicalANDExpr:
          RelationalExpr:
            Literal:
              : 41
            '>'
            Literal:
              : 42
          '&&'
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      BOOLEAN_LITERAL:
                        'false'
                  Argument:
                    Literal:
                      : should never reached
  Statement:
    ExprStatement:
      LogicalANDExpr:
        EqualityExpr:
          Literal:
            : 42
          '=='
          Literal:
            : 41
        '&&'
        LogicalANDExpr:
          RelationalExpr:
            Literal:
              : 41
            '>'
            Literal:
              : 42
          '&&'
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      BOOLEAN_LITERAL:
                        'false'
                  Argument:
                    Literal:
                      : should never reached
eq
dup // safe lh expr result
brfalse logexprend3 // bool short-circuit
pop // remove lh expr result
gt
dup // safe lh expr result
brfalse logexprend4 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend4: nop // 
logexprend3: nop // 
pop // discarge expression result for ExprStatement
eq
dup // safe lh expr result
brfalse logexprend5 // bool short-circuit
pop // remove lh expr result
gt
dup // safe lh expr result
brfalse logexprend6 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend6: nop // 
logexprend5: nop // 
pop // discarge expression result for ExprStatement
0: push 42 // Terminal
1: push 42 // Terminal
2: eq
3: dup // safe lh expr result
4: brfalse logexprend3 // bool short-circuit
5: pop // remove lh expr result
6: push 41 // Terminal
7: push 42 // Terminal
8: gt
9: dup // safe lh expr result
10: brfalse logexprend4 // bool short-circuit
11: pop // remove lh expr result
12: push false // false
13: push "should never reached" // Terminal
14: assert
15: logexprend4: nop // 
16: logexprend3: nop // 
17: pop // discarge expression result for ExprStatement
18: push 42 // Terminal
19: push 41 // Terminal
20: eq
21: dup // safe lh expr result
22: brfalse logexprend5 // bool short-circuit
23: pop // remove lh expr result
24: push 41 // Terminal
25: push 42 // Terminal
26: gt
27: dup // safe lh expr result
28: brfalse logexprend6 // bool short-circuit
29: pop // remove lh expr result
30: push false // false
31: push "should never reached" // Terminal
32: assert
33: logexprend6: nop // 
34: logexprend5: nop // 
35: pop // discarge expression result for ExprStatement
   Stack: 
0: push 42 // Terminal
   Stack: 42 | 
1: push 42 // Terminal
   Stack: 42 | 42 | 
2: eq
   Stack: true | 
3: dup // safe lh expr result
   Stack: true | true | 
4: brfalse logexprend3 // bool short-circuit
   Stack: true | 
5: pop // remove lh expr result
   Stack: 
6: push 41 // Terminal
   Stack: 41 | 
7: push 42 // Terminal
   Stack: 41 | 42 | 
8: gt
   Stack: false | 
9: dup // safe lh expr result
   Stack: false | false | 
10: brfalse logexprend4 // bool short-circuit
   Stack: false | 
16: logexprend3: nop // 
   Stack: false | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: push 42 // Terminal
   Stack: 42 | 
19: push 41 // Terminal
   Stack: 42 | 41 | 
20: eq
   Stack: false | 
21: dup // safe lh expr result
   Stack: false | false | 
22: brfalse logexprend5 // bool short-circuit
   Stack: false | 
35: pop // discarge expression result for ExprStatement
Parsed: [__assert(! false, "not does not work");
__assert(! (41 == 42), "not does not work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                PrefixExpr:
                  '!'
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
              Argument:
                Literal:
                  : not does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                PrefixExpr:
                  '!'
                  EqualityExpr:
                    Literal:
                      : 41
                    '=='
                    Literal:
                      : 42
              Argument:
                Literal:
                  : not does not work
push false // false
not // negation
assert
pop // discarge expression result for ExprStatement
eq
not // negation
assert
pop // discarge expression result for ExprStatement
0: push false // false
1: not // negation
2: push "not does not work" // Terminal
3: assert
4: pop // discarge expression result for ExprStatement
5: push 41 // Terminal
6: push 42 // Terminal
7: eq
8: not // negation
9: push "not does not work" // Terminal
10: assert
11: pop // discarge expression result for ExprStatement
   Stack: 
0: push false // false
   Stack: false | 
1: not // negation
   Stack: true | 
2: push "not does not work" // Terminal
   Stack: true | not does not work | 
3: assert
   Stack: true | 
4: pop // discarge expression result for ExprStatement
   Stack: 
5: push 41 // Terminal
   Stack: 41 | 
6: push 42 // Terminal
   Stack: 41 | 42 | 
7: eq
   Stack: false | 
8: not // negation
   Stack: true | 
9: push "not does not work" // Terminal
   Stack: true | not does not work | 
10: assert
   Stack: true | 
11: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="LogicalExpr_Test.operatorRels">LogicalExpr_Test.operatorRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: LogicalExpr_Test.basicRels
[AUNIT:ENDT] End Test: LogicalExpr_Test.basicRels
[AUNIT:STRT] Start Test: LogicalExpr_Test.operatorRels
[AUNIT:STRT] Start Test: LogicalExpr_Test.operatorRels
</pre>
<h2><a id="Operator_Test.plusOperator">Operator_Test.plusOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.String.operator_pl<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: LogicalExpr_Test.operatorRels
[AUNIT:ENDT] End Test: LogicalExpr_Test.operatorRels
[AUNIT:STRT] Start Test: Operator_Test.plusOperator
[AUNIT:STRT] Start Test: Operator_Test.plusOperator
Parsed: [using acdk.lang;
String s = "A";
String e = s + "B";
__assert(e.equals("AB"), "Plus operator on strings failed");
__assert("A" + "B" === "AB", "Plus operator on strings failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
      VarName:
        s
      VarInitializer:
        Literal:
          : A
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
      VarName:
        e
      VarInitializer:
        AdditiveExpr:
          VarName:
            s
          '+'
          Literal:
            : B
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                SubscribeExpr:
                  VarName:
                    e
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        equals
                      FuncSubscribeExpr:
                        Arguments:
                          Argument:
                            Literal:
                              : AB
              Argument:
                Literal:
                  : Plus operator on strings failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  AdditiveExpr:
                    Literal:
                      : A
                    '+'
                    Literal:
                      : B
                  '==='
                  Literal:
                    : AB
              Argument:
                Literal:
                  : Plus operator on strings failed
Create Var s at idx: 0
Create Var e at idx: 1
Code already postParsed: VarName: s
[AUNIT:ERRR] Error in Test: Operator_Test.plusOperator: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Operator_Test.plusOperator: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Operator_Test.callOperator">Operator_Test.callOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.operator_po_pc<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Operator_Test.plusOperator
[AUNIT:ENDT] End Test: Operator_Test.plusOperator
[AUNIT:STRT] Start Test: Operator_Test.callOperator
[AUNIT:STRT] Start Test: Operator_Test.callOperator
Parsed: [class AClass { public AClass() {} public static int operator()(int i) { return i + 2; } }
AClass.operator()(42);
AClass(42);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        Operator:
          ()
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          AClass
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            Operator:
              ()
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          AClass
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 42
Create Var this at idx: 0
AClass this
Create Var i at idx: 0
int i
[AUNIT:ERRR] Error in Test: Operator_Test.callOperator: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Operator_Test.callOperator: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Operator_Test.arrayOperator">Operator_Test.arrayOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.io.PrintWriter.println<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Operator_Test.callOperator
[AUNIT:ENDT] End Test: Operator_Test.callOperator
[AUNIT:STRT] Start Test: Operator_Test.arrayOperator
[AUNIT:STRT] Start Test: Operator_Test.arrayOperator
Parsed: [using acdk.lang;
String[] sa = new String[](2);
sa[1] = "Hello";
System.out.println(sa[1]);
sa[1].length() == 5;
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
        ArrayDims:
          ArrayDim:
      VarName:
        sa
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              String
            ArrayDims:
              ArrayDim:
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            sa
          ArraySubscribeExpr:
            Literal:
              : 1
        '='
        Literal:
          : Hello
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          System
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              out
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  println
                FuncSubscribeExpr:
                  Arguments:
                    Argument:
                      SubscribeExpr:
                        VarName:
                          sa
                        ArraySubscribeExpr:
                          Literal:
                            : 1
  Statement:
    ExprStatement:
      EqualityExpr:
        SubscribeExpr:
          VarName:
            sa
          ArraySubscribeExpr:
            Literal:
              : 1
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                length
              FuncSubscribeExpr:
                Arguments:
        '=='
        Literal:
          : 5
Create Var sa at idx: 0
[AUNIT:ERRR] Error in Test: Operator_Test.arrayOperator: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Operator_Test.arrayOperator: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="ParameterPassing_Test.polymorph">ParameterPassing_Test.polymorph</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.tools.aunit.DmiTestClass.polymorphFunc<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Operator_Test.arrayOperator
[AUNIT:ENDT] End Test: Operator_Test.arrayOperator
[AUNIT:STRT] Start Test: ParameterPassing_Test.polymorph
[AUNIT:STRT] Start Test: ParameterPassing_Test.polymorph
Parsed: [using acdk.tools.aunit;
using acdk.lang;
DmiTestClass obj = new DmiTestClass();
String s;
s = obj.polymorphFunc(new Integer(42));
Number number = new Integer(41);
s = obj.polymorphFunc(number);
number = new Short(2);
s = obj.polymorphFunc(number);
s = obj.polymorphFunc("asdf");
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            tools
          FqTypeName:
            TypeName:
              aunit
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          DmiTestClass
      VarName:
        obj
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              DmiTestClass
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
      VarName:
        s
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    NewExpr:
                      FqTypeName:
                        TypeName:
                          Integer
                      Arguments:
                        Argument:
                          Literal:
                            : 42
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          Number
      VarName:
        number
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              Integer
          Arguments:
            Argument:
              Literal:
                : 41
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    VarName:
                      number
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          number
        '='
        NewExpr:
          FqTypeName:
            TypeName:
              Short
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    VarName:
                      number
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : asdf
Create Var obj at idx: 0
Create Var s at idx: 1
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.polymorph: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.polymorph: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="ParameterPassing_Test.namedParameter">ParameterPassing_Test.namedParameter</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.Integer.toString<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: ParameterPassing_Test.polymorph
[AUNIT:ENDT] End Test: ParameterPassing_Test.polymorph
[AUNIT:STRT] Start Test: ParameterPassing_Test.namedParameter
[AUNIT:STRT] Start Test: ParameterPassing_Test.namedParameter
Parsed: [using acdk.lang;
String s = Integer.toString(radix: 10, value: 42);
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          String
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          VarName:
            Integer
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
                  ArgumentList:
                    Argument:
                      Label:
                        radix
                      Literal:
                        : 10
                    Argument:
                      Label:
                        value
                      Literal:
                        : 42
Create Var s at idx: 0
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.namedParameter: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.namedParameter: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="ParameterPassing_Test.restParameter">ParameterPassing_Test.restParameter</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.foo<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: ParameterPassing_Test.namedParameter
[AUNIT:ENDT] End Test: ParameterPassing_Test.namedParameter
[AUNIT:STRT] Start Test: ParameterPassing_Test.restParameter
[AUNIT:STRT] Start Test: ParameterPassing_Test.restParameter
Parsed: [class AClass { public AClass() {} public void foo(int i, acdk.lang.dmi.DmiObjectArray rest) { } }
AClass a = new AClass();
a.foo(2, 40, 41, 42);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              i
          Parameter:
            FqTypeName:
              TypeName:
                acdk
              FqTypeName:
                TypeName:
                  lang
                FqTypeName:
                  TypeName:
                    dmi
                  FqTypeName:
                    TypeName:
                      DmiObjectArray
            VarName:
              rest
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AClass
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          a
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      : 2
                  Argument:
                    Literal:
                      : 40
                  Argument:
                    Literal:
                      : 41
                  Argument:
                    Literal:
                      : 42
Create Var this at idx: 0
AClass this
Create Var i at idx: 0
Create Var rest at idx: 1
int i
[acdk.lang.dmi.DmiObject rest
Create Var this at idx: 0
AClass this
int i
[acdk.lang.dmi.DmiObject rest
Create Var a at idx: 0
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.restParameter: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: ParameterPassing_Test.restParameter: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="RelExpr_Test.basicRels">RelExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.Integer.equals<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: ParameterPassing_Test.restParameter
[AUNIT:ENDT] End Test: ParameterPassing_Test.restParameter
[AUNIT:STRT] Start Test: RelExpr_Test.basicRels
[AUNIT:STRT] Start Test: RelExpr_Test.basicRels
Parsed: [using acdk.lang;
Integer integer1 = new Integer(42);
Integer integer2 = integer1;
__assert(integer1 == integer2, "compare object instances failed");
integer2 = new Integer(42);
__assert(integer1 != integer2, "compare object instances failed");
__assert(integer1.equals(integer2) == true, "compare object via equals failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          Integer
      VarName:
        integer1
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              Integer
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          Integer
      VarName:
        integer2
      VarInitializer:
        VarName:
          integer1
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    integer1
                  '=='
                  VarName:
                    integer2
              Argument:
                Literal:
                  : compare object instances failed
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          integer2
        '='
        NewExpr:
          FqTypeName:
            TypeName:
              Integer
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    integer1
                  '!='
                  VarName:
                    integer2
              Argument:
                Literal:
                  : compare object instances failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      integer1
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              VarName:
                                integer2
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : compare object via equals failed
Create Var integer1 at idx: 0
Create Var integer2 at idx: 1
[AUNIT:ERRR] Error in Test: RelExpr_Test.basicRels: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: RelExpr_Test.basicRels: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="RelExpr_Test.operatorRels">RelExpr_Test.operatorRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.operator_lt<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: RelExpr_Test.basicRels
[AUNIT:ENDT] End Test: RelExpr_Test.basicRels
[AUNIT:STRT] Start Test: RelExpr_Test.operatorRels
[AUNIT:STRT] Start Test: RelExpr_Test.operatorRels
Parsed: [class AClass { public AClass() {}
  public bool operator<(int other) { return 42 < other; }
  public bool operator<=(int other) { return 42 <= other; }
  public bool operator>(int other) { return 42 > other; }
  public bool operator>=(int other) { return 42 >= other; }
  public bool operator==(int other) { return 42 == other; }
  public bool operator!=(int other) { return 42 != other; }
}
AClass a = new AClass();
__assert(a < 43, "compare int failed");
__assert(a > 41, "compare int failed");
__assert(a >= 41, "compare int failed");
__assert(a >= 42, "compare int failed");
__assert(a <= 43, "compare int failed");
__assert(a <= 42, "compare int failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          <
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '<'
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          <=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '<='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          >
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '>'
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          >=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '>='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          ==
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                EqualityExpr:
                  Literal:
                    : 42
                  '=='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              bool
        Operator:
          !=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                int
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                EqualityExpr:
                  Literal:
                    : 42
                  '!='
                  VarName:
                    other
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AClass
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<'
                  Literal:
                    : 43
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>'
                  Literal:
                    : 41
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>='
                  Literal:
                    : 41
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<='
                  Literal:
                    : 43
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : compare int failed
Create Var this at idx: 0
AClass this
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var a at idx: 0
Code already postParsed: VarName: a
[AUNIT:ERRR] Error in Test: RelExpr_Test.operatorRels: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: RelExpr_Test.operatorRels: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="RelExpr_Test.equalsExpr">RelExpr_Test.equalsExpr</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.String.equals<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: RelExpr_Test.operatorRels
[AUNIT:ENDT] End Test: RelExpr_Test.operatorRels
[AUNIT:STRT] Start Test: RelExpr_Test.equalsExpr
[AUNIT:STRT] Start Test: RelExpr_Test.equalsExpr
Parsed: [__assert(1 !== 2, "equals operator fails");
acdk.lang.String s = "a";
s.equals("a");
__assert(s === "a", "equals operator fails");
__assert(s !== "b", "equals operator fails");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  Literal:
                    : 1
                  '!=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : equals operator fails
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
          FqTypeName:
            TypeName:
              String
      VarName:
        s
      VarInitializer:
        Literal:
          : a
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          s
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              equals
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : a
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  VarName:
                    s
                  '==='
                  Literal:
                    : a
              Argument:
                Literal:
                  : equals operator fails
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  VarName:
                    s
                  '!=='
                  Literal:
                    : b
              Argument:
                Literal:
                  : equals operator fails
Code already postParsed: Literal: 
Code already postParsed: Literal: 
Create Var s at idx: 0
[AUNIT:ERRR] Error in Test: RelExpr_Test.equalsExpr: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: RelExpr_Test.equalsExpr: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Scanner_Test.standard">Scanner_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: RelExpr_Test.equalsExpr
[AUNIT:ENDT] End Test: RelExpr_Test.equalsExpr
[AUNIT:STRT] Start Test: Scanner_Test.standard
[AUNIT:STRT] Start Test: Scanner_Test.standard
</pre>
<h2><a id="Scanner_Test.string">Scanner_Test.string</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Scanner_Test.standard
[AUNIT:ENDT] End Test: Scanner_Test.standard
[AUNIT:STRT] Start Test: Scanner_Test.string
[AUNIT:STRT] Start Test: Scanner_Test.string
</pre>
<h2><a id="Scanner_Test.interactive">Scanner_Test.interactive</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Scanner_Test.string
[AUNIT:ENDT] End Test: Scanner_Test.string
[AUNIT:STRT] Start Test: Scanner_Test.interactive
[AUNIT:STRT] Start Test: Scanner_Test.interactive
</pre>
<h2><a id="Scanner_Test.cComments">Scanner_Test.cComments</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Scanner_Test.interactive
[AUNIT:ENDT] End Test: Scanner_Test.interactive
[AUNIT:STRT] Start Test: Scanner_Test.cComments
[AUNIT:STRT] Start Test: Scanner_Test.cComments
</pre>
<h2><a id="Statements_Test.standard">Statements_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Scanner_Test.cComments
[AUNIT:ENDT] End Test: Scanner_Test.cComments
[AUNIT:STRT] Start Test: Statements_Test.standard
[AUNIT:STRT] Start Test: Statements_Test.standard
Parsed: [] to
CodeText:
CodeText:
</pre>
<h2><a id="Statements_Test.varDecl">Statements_Test.varDecl</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.standard
[AUNIT:ENDT] End Test: Statements_Test.standard
[AUNIT:STRT] Start Test: Statements_Test.varDecl
[AUNIT:STRT] Start Test: Statements_Test.varDecl
Parsed: [int i;
__assert(i == 0, "varDecl without initalizer don't work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 0
              Argument:
                Literal:
                  : varDecl without initalizer don't work
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: load 0 // i
4: push 0 // Terminal
5: eq
6: push "varDecl without initalizer don't work" // Terminal
7: assert
8: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: load 0 // i
   Stack: 0 | 
4: push 0 // Terminal
   Stack: 0 | 0 | 
5: eq
   Stack: true | 
6: push "varDecl without initalizer don't work" // Terminal
   Stack: true | varDecl without initalizer don't work | 
7: assert
   Stack: true | 
8: pop // discarge expression result for ExprStatement
Parsed: [int i = 2;
__assert(i == 2, "varDecl with initalizer don't work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : varDecl with initalizer don't work
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 2 // Terminal
9: eq
10: push "varDecl with initalizer don't work" // Terminal
11: assert
12: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 2 | 
8: push 2 // Terminal
   Stack: 2 | 2 | 
9: eq
   Stack: true | 
10: push "varDecl with initalizer don't work" // Terminal
   Stack: true | varDecl with initalizer don't work | 
11: assert
   Stack: true | 
12: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.block">Statements_Test.block</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.varDecl
[AUNIT:ENDT] End Test: Statements_Test.varDecl
[AUNIT:STRT] Start Test: Statements_Test.block
[AUNIT:STRT] Start Test: Statements_Test.block
Parsed: [int i = 2;
int j = 10;
{
  int j = i;
  __assert(j == 2, "Scoped Block local vars");
}
i = j;
__assert(i == 10, "Scoped Block local vars");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        Literal:
          : 10
  Statement:
    Block:
      Statement:
        LVarDecl:
          FqTypeName:
            TypeName:
              int
          VarName:
            j
          VarInitializer:
            VarName:
              i
      Statement:
        ExprStatement:
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    EqualityExpr:
                      VarName:
                        j
                      '=='
                      Literal:
                        : 2
                  Argument:
                    Literal:
                      : Scoped Block local vars
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        VarName:
          j
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 10
              Argument:
                Literal:
                  : Scoped Block local vars
Create Var i at idx: 0
Create Var j at idx: 1
Create Var j at idx: 2
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
clvr 2 // j
push 0 // initialize local value
store 2 // initialize local value
load 0 // i
loadref 2 // j
assign
pop // discarge expression result for ExprStatement
load 2 // j
eq
assert
pop // discarge expression result for ExprStatement
load 1 // j
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: push 10 // Terminal
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: clvr 2 // j
15: push 0 // initialize local value
16: store 2 // initialize local value
17: load 0 // i
18: loadref 2 // j
19: assign
20: pop // discarge expression result for ExprStatement
21: load 2 // j
22: push 2 // Terminal
23: eq
24: push "Scoped Block local vars" // Terminal
25: assert
26: pop // discarge expression result for ExprStatement
27: load 1 // j
28: loadref 0 // i
29: assign
30: pop // discarge expression result for ExprStatement
31: load 0 // i
32: push 10 // Terminal
33: eq
34: push "Scoped Block local vars" // Terminal
35: assert
36: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: push 10 // Terminal
   Stack: 10 | 
11: loadref 1 // j
   Stack: 10 | &0 | 
12: assign
   Stack: 10 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: clvr 2 // j
   Stack: 
15: push 0 // initialize local value
   Stack: 0 | 
16: store 2 // initialize local value
   Stack: 
17: load 0 // i
   Stack: 2 | 
18: loadref 2 // j
   Stack: 2 | &0 | 
19: assign
   Stack: 2 | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: load 2 // j
   Stack: 2 | 
22: push 2 // Terminal
   Stack: 2 | 2 | 
23: eq
   Stack: true | 
24: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
25: assert
   Stack: true | 
26: pop // discarge expression result for ExprStatement
   Stack: 
27: load 1 // j
   Stack: 10 | 
28: loadref 0 // i
   Stack: 10 | &2 | 
29: assign
   Stack: 10 | 
30: pop // discarge expression result for ExprStatement
   Stack: 
31: load 0 // i
   Stack: 10 | 
32: push 10 // Terminal
   Stack: 10 | 10 | 
33: eq
   Stack: true | 
34: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
35: assert
   Stack: true | 
36: pop // discarge expression result for ExprStatement
Parsed: [int i = 2;
{
  int j = i;
  __assert(j == 2, "Scoped Block local vars");
}
int j = 4;
__assert(i == 2, "Scoped Block local vars");
__assert(j == 4, "Scoped Block local vars");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    Block:
      Statement:
        LVarDecl:
          FqTypeName:
            TypeName:
              int
          VarName:
            j
          VarInitializer:
            VarName:
              i
      Statement:
        ExprStatement:
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    EqualityExpr:
                      VarName:
                        j
                      '=='
                      Literal:
                        : 2
                  Argument:
                    Literal:
                      : Scoped Block local vars
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        Literal:
          : 4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : Scoped Block local vars
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    j
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : Scoped Block local vars
Create Var i at idx: 0
Create Var j at idx: 1
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: load 0 // i
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: load 1 // j
15: push 2 // Terminal
16: eq
17: push "Scoped Block local vars" // Terminal
18: assert
19: pop // discarge expression result for ExprStatement
20: clvr 1 // j
21: push 0 // initialize local value
22: store 1 // initialize local value
23: push 4 // Terminal
24: loadref 1 // j
25: assign
26: pop // discarge expression result for ExprStatement
27: load 0 // i
28: push 2 // Terminal
29: eq
30: push "Scoped Block local vars" // Terminal
31: assert
32: pop // discarge expression result for ExprStatement
33: load 1 // j
34: push 4 // Terminal
35: eq
36: push "Scoped Block local vars" // Terminal
37: assert
38: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: loadref 1 // j
   Stack: 2 | &0 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 1 // j
   Stack: 2 | 
15: push 2 // Terminal
   Stack: 2 | 2 | 
16: eq
   Stack: true | 
17: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
18: assert
   Stack: true | 
19: pop // discarge expression result for ExprStatement
   Stack: 
20: clvr 1 // j
   Stack: 
21: push 0 // initialize local value
   Stack: 0 | 
22: store 1 // initialize local value
   Stack: 
23: push 4 // Terminal
   Stack: 4 | 
24: loadref 1 // j
   Stack: 4 | &0 | 
25: assign
   Stack: 4 | 
26: pop // discarge expression result for ExprStatement
   Stack: 
27: load 0 // i
   Stack: 2 | 
28: push 2 // Terminal
   Stack: 2 | 2 | 
29: eq
   Stack: true | 
30: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
31: assert
   Stack: true | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: load 1 // j
   Stack: 4 | 
34: push 4 // Terminal
   Stack: 4 | 4 | 
35: eq
   Stack: true | 
36: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
37: assert
   Stack: true | 
38: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.whileStatement">Statements_Test.whileStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.block
[AUNIT:ENDT] End Test: Statements_Test.block
[AUNIT:STRT] Start Test: Statements_Test.whileStatement
[AUNIT:STRT] Start Test: Statements_Test.whileStatement
Parsed: [int i = 0;
while (i < 10)
{
  i = i + 1;
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    WhileStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
whilebegin1: nop // whilebegin
load 0 // i
lt
brfalse whileend1 // break while loop
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br whilebegin1 // next while loop
whileend1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: whilebegin1: nop // whilebegin
8: load 0 // i
9: push 10 // Terminal
10: lt
11: brfalse whileend1 // break while loop
12: load 0 // i
13: push 1 // Terminal
14: add
15: loadref 0 // i
16: assign
17: pop // discarge expression result for ExprStatement
18: br whilebegin1 // next while loop
19: whileend1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: whilebegin1: nop // whilebegin
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 10 // Terminal
   Stack: 0 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 0 | 
13: push 1 // Terminal
   Stack: 0 | 1 | 
14: add
   Stack: 1 | 
15: loadref 0 // i
   Stack: 1 | &0 | 
16: assign
   Stack: 1 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 10 // Terminal
   Stack: 1 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 1 | 
13: push 1 // Terminal
   Stack: 1 | 1 | 
14: add
   Stack: 2 | 
15: loadref 0 // i
   Stack: 2 | &1 | 
16: assign
   Stack: 2 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 10 // Terminal
   Stack: 2 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 2 | 
13: push 1 // Terminal
   Stack: 2 | 1 | 
14: add
   Stack: 3 | 
15: loadref 0 // i
   Stack: 3 | &2 | 
16: assign
   Stack: 3 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 10 // Terminal
   Stack: 3 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 3 | 
13: push 1 // Terminal
   Stack: 3 | 1 | 
14: add
   Stack: 4 | 
15: loadref 0 // i
   Stack: 4 | &3 | 
16: assign
   Stack: 4 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 4 | 
9: push 10 // Terminal
   Stack: 4 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 4 | 
13: push 1 // Terminal
   Stack: 4 | 1 | 
14: add
   Stack: 5 | 
15: loadref 0 // i
   Stack: 5 | &4 | 
16: assign
   Stack: 5 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 5 | 
9: push 10 // Terminal
   Stack: 5 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 5 | 
13: push 1 // Terminal
   Stack: 5 | 1 | 
14: add
   Stack: 6 | 
15: loadref 0 // i
   Stack: 6 | &5 | 
16: assign
   Stack: 6 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 6 | 
9: push 10 // Terminal
   Stack: 6 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 6 | 
13: push 1 // Terminal
   Stack: 6 | 1 | 
14: add
   Stack: 7 | 
15: loadref 0 // i
   Stack: 7 | &6 | 
16: assign
   Stack: 7 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 7 | 
9: push 10 // Terminal
   Stack: 7 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 7 | 
13: push 1 // Terminal
   Stack: 7 | 1 | 
14: add
   Stack: 8 | 
15: loadref 0 // i
   Stack: 8 | &7 | 
16: assign
   Stack: 8 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 8 | 
9: push 10 // Terminal
   Stack: 8 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 8 | 
13: push 1 // Terminal
   Stack: 8 | 1 | 
14: add
   Stack: 9 | 
15: loadref 0 // i
   Stack: 9 | &8 | 
16: assign
   Stack: 9 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 9 | 
9: push 10 // Terminal
   Stack: 9 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 9 | 
13: push 1 // Terminal
   Stack: 9 | 1 | 
14: add
   Stack: 10 | 
15: loadref 0 // i
   Stack: 10 | &9 | 
16: assign
   Stack: 10 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 10 | 
9: push 10 // Terminal
   Stack: 10 | 10 | 
10: lt
   Stack: false | 
11: brfalse whileend1 // break while loop
Parsed: [int i = 0;
while (true)
{
  if (i >= 10)
    break;
  i = i + 1;
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    WhileStatement:
      Literal:
        BOOLEAN_LITERAL:
          'true'
      Statement:
        Block:
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>='
                Literal:
                  : 10
              Statement:
                BreakStatement:
                  'break'
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
whilebegin2: nop // whilebegin
push true // true
brfalse whileend2 // break while loop
load 0 // i
gteq
brfalse endif3 // goto endif
br whileend2 // break/continue
endif3: nop // 
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br whilebegin2 // next while loop
whileend2: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: whilebegin2: nop // whilebegin
8: push true // true
9: brfalse whileend2 // break while loop
10: load 0 // i
11: push 10 // Terminal
12: gteq
13: brfalse endif3 // goto endif
14: br whileend2 // break/continue
15: endif3: nop // 
16: load 0 // i
17: push 1 // Terminal
18: add
19: loadref 0 // i
20: assign
21: pop // discarge expression result for ExprStatement
22: br whilebegin2 // next while loop
23: whileend2: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: whilebegin2: nop // whilebegin
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 0 | 
11: push 10 // Terminal
   Stack: 0 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 0 | 
17: push 1 // Terminal
   Stack: 0 | 1 | 
18: add
   Stack: 1 | 
19: loadref 0 // i
   Stack: 1 | &0 | 
20: assign
   Stack: 1 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 1 | 
11: push 10 // Terminal
   Stack: 1 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 1 | 
17: push 1 // Terminal
   Stack: 1 | 1 | 
18: add
   Stack: 2 | 
19: loadref 0 // i
   Stack: 2 | &1 | 
20: assign
   Stack: 2 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: push 10 // Terminal
   Stack: 2 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 2 | 
17: push 1 // Terminal
   Stack: 2 | 1 | 
18: add
   Stack: 3 | 
19: loadref 0 // i
   Stack: 3 | &2 | 
20: assign
   Stack: 3 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 3 | 
11: push 10 // Terminal
   Stack: 3 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 3 | 
17: push 1 // Terminal
   Stack: 3 | 1 | 
18: add
   Stack: 4 | 
19: loadref 0 // i
   Stack: 4 | &3 | 
20: assign
   Stack: 4 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 4 | 
11: push 10 // Terminal
   Stack: 4 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 4 | 
17: push 1 // Terminal
   Stack: 4 | 1 | 
18: add
   Stack: 5 | 
19: loadref 0 // i
   Stack: 5 | &4 | 
20: assign
   Stack: 5 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 5 | 
11: push 10 // Terminal
   Stack: 5 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 5 | 
17: push 1 // Terminal
   Stack: 5 | 1 | 
18: add
   Stack: 6 | 
19: loadref 0 // i
   Stack: 6 | &5 | 
20: assign
   Stack: 6 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 6 | 
11: push 10 // Terminal
   Stack: 6 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 6 | 
17: push 1 // Terminal
   Stack: 6 | 1 | 
18: add
   Stack: 7 | 
19: loadref 0 // i
   Stack: 7 | &6 | 
20: assign
   Stack: 7 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 7 | 
11: push 10 // Terminal
   Stack: 7 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 7 | 
17: push 1 // Terminal
   Stack: 7 | 1 | 
18: add
   Stack: 8 | 
19: loadref 0 // i
   Stack: 8 | &7 | 
20: assign
   Stack: 8 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 8 | 
11: push 10 // Terminal
   Stack: 8 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 8 | 
17: push 1 // Terminal
   Stack: 8 | 1 | 
18: add
   Stack: 9 | 
19: loadref 0 // i
   Stack: 9 | &8 | 
20: assign
   Stack: 9 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 9 | 
11: push 10 // Terminal
   Stack: 9 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 9 | 
17: push 1 // Terminal
   Stack: 9 | 1 | 
18: add
   Stack: 10 | 
19: loadref 0 // i
   Stack: 10 | &9 | 
20: assign
   Stack: 10 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 10 | 
11: push 10 // Terminal
   Stack: 10 | 10 | 
12: gteq
   Stack: true | 
13: brfalse endif3 // goto endif
   Stack: 
14: br whileend2 // break/continue
</pre>
<h2><a id="Statements_Test.doStatement">Statements_Test.doStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.whileStatement
[AUNIT:ENDT] End Test: Statements_Test.whileStatement
[AUNIT:STRT] Start Test: Statements_Test.doStatement
[AUNIT:STRT] Start Test: Statements_Test.doStatement
Parsed: [int i = 0;
do
{
  i = i + 1;
} while  (i < 4);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 4
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin1: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse doend1 // break do loop
br dobegin1 // next do loop
doend1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin1: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 4 // Terminal
16: lt
17: brfalse doend1 // break do loop
18: br dobegin1 // next do loop
19: doend1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin1: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 4 // Terminal
   Stack: 1 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 4 // Terminal
   Stack: 2 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 4 // Terminal
   Stack: 3 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 4 // Terminal
   Stack: 4 | 4 | 
16: lt
   Stack: false | 
17: brfalse doend1 // break do loop
Parsed: [int i = 0;
do
{
  i = i + 1;
  if (i > 3) break;
} while  (i < 10);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>'
                Literal:
                  : 3
              Statement:
                BreakStatement:
                  'break'
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin2: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
gt
brfalse endif3 // goto endif
br doend2 // break/continue
endif3: nop // 
load 0 // i
lt
brfalse doend2 // break do loop
br dobegin2 // next do loop
doend2: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin2: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 3 // Terminal
16: gt
17: brfalse endif3 // goto endif
18: br doend2 // break/continue
19: endif3: nop // 
20: load 0 // i
21: push 10 // Terminal
22: lt
23: brfalse doend2 // break do loop
24: br dobegin2 // next do loop
25: doend2: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin2: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 3 // Terminal
   Stack: 1 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 1 | 
21: push 10 // Terminal
   Stack: 1 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 3 // Terminal
   Stack: 2 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 2 | 
21: push 10 // Terminal
   Stack: 2 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 3 // Terminal
   Stack: 3 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 3 | 
21: push 10 // Terminal
   Stack: 3 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 3 // Terminal
   Stack: 4 | 3 | 
16: gt
   Stack: true | 
17: brfalse endif3 // goto endif
   Stack: 
18: br doend2 // break/continue
</pre>
<h2><a id="Statements_Test.forStatement">Statements_Test.forStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.doStatement
[AUNIT:ENDT] End Test: Statements_Test.doStatement
[AUNIT:STRT] Start Test: Statements_Test.forStatement
[AUNIT:STRT] Start Test: Statements_Test.forStatement
Parsed: [for (int i = 0; i < 1; ++i)
{
}
int i = 0;
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ForStatement:
      LVarDecl:
        FqTypeName:
          TypeName:
            int
        VarName:
          i
        VarInitializer:
          Literal:
            : 0
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 1
      PrefixExpr:
        '++'
        VarName:
          i
      Statement:
        Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
Create Var i at idx: 0
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst1 // first for loop
fornext1: nop // 
loadref 0 // i
inc // prefix inc/dec
pop // remove step expression result
forfirst1: nop // 
load 0 // i
lt
brfalse forlast1 // break for loop
br fornext1 // next for loop
forlast1: nop // 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst1 // first for loop
8: fornext1: nop // 
9: loadref 0 // i
10: inc // prefix inc/dec
11: pop // remove step expression result
12: forfirst1: nop // 
13: load 0 // i
14: push 1 // Terminal
15: lt
16: brfalse forlast1 // break for loop
17: br fornext1 // next for loop
18: forlast1: nop // 
19: clvr 0 // i
20: push 0 // initialize local value
21: store 0 // initialize local value
22: push 0 // Terminal
23: loadref 0 // i
24: assign
25: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst1 // first for loop
   Stack: 
13: load 0 // i
   Stack: 0 | 
14: push 1 // Terminal
   Stack: 0 | 1 | 
15: lt
   Stack: true | 
16: brfalse forlast1 // break for loop
   Stack: 
17: br fornext1 // next for loop
   Stack: 
9: loadref 0 // i
   Stack: &0 | 
10: inc // prefix inc/dec
   Stack: 1 | 
11: pop // remove step expression result
   Stack: 
12: forfirst1: nop // 
   Stack: 
13: load 0 // i
   Stack: 1 | 
14: push 1 // Terminal
   Stack: 1 | 1 | 
15: lt
   Stack: false | 
16: brfalse forlast1 // break for loop
   Stack: 
19: clvr 0 // i
   Stack: 
20: push 0 // initialize local value
   Stack: 0 | 
21: store 0 // initialize local value
   Stack: 
22: push 0 // Terminal
   Stack: 0 | 
23: loadref 0 // i
   Stack: 0 | &0 | 
24: assign
   Stack: 0 | 
25: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
for (; i < 1; ++i)
{
}
int j = i;
__assert(j == 1, "for loop local var handling");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ForStatement:
      EmptyStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 1
      PrefixExpr:
        '++'
        VarName:
          i
      Statement:
        Block:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        j
      VarInitializer:
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    j
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : for loop local var handling
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst2 // first for loop
fornext2: nop // 
loadref 0 // i
inc // prefix inc/dec
pop // remove step expression result
forfirst2: nop // 
load 0 // i
lt
brfalse forlast2 // break for loop
br fornext2 // next for loop
forlast2: nop // 
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst2 // first for loop
8: fornext2: nop // 
9: loadref 0 // i
10: inc // prefix inc/dec
11: pop // remove step expression result
12: forfirst2: nop // 
13: load 0 // i
14: push 1 // Terminal
15: lt
16: brfalse forlast2 // break for loop
17: br fornext2 // next for loop
18: forlast2: nop // 
19: clvr 1 // j
20: push 0 // initialize local value
21: store 1 // initialize local value
22: load 0 // i
23: loadref 1 // j
24: assign
25: pop // discarge expression result for ExprStatement
26: load 1 // j
27: push 1 // Terminal
28: eq
29: push "for loop local var handling" // Terminal
30: assert
31: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst2 // first for loop
   Stack: 
13: load 0 // i
   Stack: 0 | 
14: push 1 // Terminal
   Stack: 0 | 1 | 
15: lt
   Stack: true | 
16: brfalse forlast2 // break for loop
   Stack: 
17: br fornext2 // next for loop
   Stack: 
9: loadref 0 // i
   Stack: &0 | 
10: inc // prefix inc/dec
   Stack: 1 | 
11: pop // remove step expression result
   Stack: 
12: forfirst2: nop // 
   Stack: 
13: load 0 // i
   Stack: 1 | 
14: push 1 // Terminal
   Stack: 1 | 1 | 
15: lt
   Stack: false | 
16: brfalse forlast2 // break for loop
   Stack: 
19: clvr 1 // j
   Stack: 
20: push 0 // initialize local value
   Stack: 0 | 
21: store 1 // initialize local value
   Stack: 
22: load 0 // i
   Stack: 1 | 
23: loadref 1 // j
   Stack: 1 | &0 | 
24: assign
   Stack: 1 | 
25: pop // discarge expression result for ExprStatement
   Stack: 
26: load 1 // j
   Stack: 1 | 
27: push 1 // Terminal
   Stack: 1 | 1 | 
28: eq
   Stack: true | 
29: push "for loop local var handling" // Terminal
   Stack: true | for loop local var handling | 
30: assert
   Stack: true | 
31: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
for (;;)
  if (++i > 2)
    break;
__assert(i == 3, "for loop local var handling");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ForStatement:
      EmptyStatement:
      EmptyExpression:
      EmptyExpression:
      Statement:
        IfStatement:
          RelationalExpr:
            PrefixExpr:
              '++'
              VarName:
                i
            '>'
            Literal:
              : 2
          Statement:
            BreakStatement:
              'break'
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : for loop local var handling
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst3 // first for loop
fornext3: nop // 
forfirst3: nop // 
loadref 0 // i
inc // prefix inc/dec
gt
brfalse endif4 // goto endif
br forlast3 // break/continue
endif4: nop // 
br fornext3 // next for loop
forlast3: nop // 
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst3 // first for loop
8: fornext3: nop // 
9: forfirst3: nop // 
10: loadref 0 // i
11: inc // prefix inc/dec
12: push 2 // Terminal
13: gt
14: brfalse endif4 // goto endif
15: br forlast3 // break/continue
16: endif4: nop // 
17: br fornext3 // next for loop
18: forlast3: nop // 
19: load 0 // i
20: push 3 // Terminal
21: eq
22: push "for loop local var handling" // Terminal
23: assert
24: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst3 // first for loop
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: inc // prefix inc/dec
   Stack: 1 | 
12: push 2 // Terminal
   Stack: 1 | 2 | 
13: gt
   Stack: false | 
14: brfalse endif4 // goto endif
   Stack: 
17: br fornext3 // next for loop
   Stack: 
9: forfirst3: nop // 
   Stack: 
10: loadref 0 // i
   Stack: &1 | 
11: inc // prefix inc/dec
   Stack: 2 | 
12: push 2 // Terminal
   Stack: 2 | 2 | 
13: gt
   Stack: false | 
14: brfalse endif4 // goto endif
   Stack: 
17: br fornext3 // next for loop
   Stack: 
9: forfirst3: nop // 
   Stack: 
10: loadref 0 // i
   Stack: &2 | 
11: inc // prefix inc/dec
   Stack: 3 | 
12: push 2 // Terminal
   Stack: 3 | 2 | 
13: gt
   Stack: true | 
14: brfalse endif4 // goto endif
   Stack: 
15: br forlast3 // break/continue
   Stack: 
19: load 0 // i
   Stack: 3 | 
20: push 3 // Terminal
   Stack: 3 | 3 | 
21: eq
   Stack: true | 
22: push "for loop local var handling" // Terminal
   Stack: true | for loop local var handling | 
23: assert
   Stack: true | 
24: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.gotoStatement">Statements_Test.gotoStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> NullPointerException<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.forStatement
[AUNIT:ENDT] End Test: Statements_Test.forStatement
[AUNIT:STRT] Start Test: Statements_Test.gotoStatement
[AUNIT:STRT] Start Test: Statements_Test.gotoStatement
Parsed: [int i = 0;
do
{
  i = i + 1;
  if (i > 3) goto ende;
} while  (i < 4);
__assert(false, "unreachable. goto doesn't work expected");
ende:

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>'
                Literal:
                  : 3
              Statement:
                GotoStatement:
                  Label:
                    ende
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                Literal:
                  BOOLEAN_LITERAL:
                    'false'
              Argument:
                Literal:
                  : unreachable. goto doesn't work expected
  Statement:
    LabeledStatement:
      Label:
        ende
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin1: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
gt
brfalse endif2 // goto endif
br ende // goto
endif2: nop // 
load 0 // i
lt
brfalse doend1 // break do loop
br dobegin1 // next do loop
doend1: nop // 
push false // false
assert
pop // discarge expression result for ExprStatement
ende: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin1: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 3 // Terminal
16: gt
17: brfalse endif2 // goto endif
18: br ende // goto
19: endif2: nop // 
20: load 0 // i
21: push 4 // Terminal
22: lt
23: brfalse doend1 // break do loop
24: br dobegin1 // next do loop
25: doend1: nop // 
26: push false // false
27: push "unreachable. goto doesn't work expected" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: ende: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin1: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 3 // Terminal
   Stack: 1 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 1 | 
21: push 4 // Terminal
   Stack: 1 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 3 // Terminal
   Stack: 2 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 2 | 
21: push 4 // Terminal
   Stack: 2 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 3 // Terminal
   Stack: 3 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 3 | 
21: push 4 // Terminal
   Stack: 3 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 3 // Terminal
   Stack: 4 | 3 | 
16: gt
   Stack: true | 
17: brfalse endif2 // goto endif
   Stack: 
18: br ende // goto
Parsed: [goto ende;
ende: goto realende;
__assert(false, "goto doesn't work");
realende:

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    GotoStatement:
      Label:
        ende
  Statement:
    LabeledStatement:
      Label:
        ende
      Statement:
        GotoStatement:
          Label:
            realende
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                Literal:
                  BOOLEAN_LITERAL:
                    'false'
              Argument:
                Literal:
                  : goto doesn't work
  Statement:
    LabeledStatement:
      Label:
        realende
br ende // goto
ende: nop // 
br realende // goto
push false // false
assert
pop // discarge expression result for ExprStatement
realende: nop // 
0: br ende // goto
1: ende: nop // 
2: br realende // goto
3: push false // false
4: push "goto doesn't work" // Terminal
5: assert
6: pop // discarge expression result for ExprStatement
7: realende: nop // 
   Stack: 
0: br ende // goto
   Stack: 
2: br realende // goto
Parsed: [void foo()
{
  goto endoffoo;
  __assert(false, "goto in methods does not work");
endoffoo: ;
}
foo();
;
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            TypeName:
              void
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              GotoStatement:
                Label:
                  endoffoo
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    __assert
                  FuncSubscribeExpr:
                    Arguments:
                      ArgumentList:
                        Argument:
                          Literal:
                            BOOLEAN_LITERAL:
                              'false'
                        Argument:
                          Literal:
                            : goto in methods does not work
            Statement:
              LabeledStatement:
                Label:
                  endoffoo
                Statement:
                  EmptyStatement:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          foo
        FuncSubscribeExpr:
          Arguments:
  Statement:
    EmptyStatement:
[AUNIT:ERRR] Error in Test: Statements_Test.gotoStatement: acdk/lang/NullPointerException
[AUNIT:ERRR] Error in Test: Statements_Test.gotoStatement: acdk/lang/NullPointerException
Called in:
</pre>
<h2><a id="Statements_Test.ifStatement">Statements_Test.ifStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.gotoStatement
[AUNIT:ENDT] End Test: Statements_Test.gotoStatement
[AUNIT:STRT] Start Test: Statements_Test.ifStatement
[AUNIT:STRT] Start Test: Statements_Test.ifStatement
Parsed: [int i = 0;
if (i < 10) i = 11; else i = 9;] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              i
            '='
            Literal:
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 9
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
            VarName:Sem=[i=int] ExprSem=[i=int]
              i
            '='
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
              VarName:Sem=[i=int] ExprSem=[i=int]
                i
              '='
              Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                : 9
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse elseblock1 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif1 // goto endif
elseblock1: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse elseblock1 // goto else block
11: push 11 // Terminal
12: loadref 0 // i
13: assign
14: pop // discarge expression result for ExprStatement
15: br endif1 // goto endif
16: elseblock1: nop // 
17: push 9 // Terminal
18: loadref 0 // i
19: assign
20: pop // discarge expression result for ExprStatement
21: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 0 | 
8: push 10 // Terminal
   Stack: 0 | 10 | 
9: lt
   Stack: true | 
10: brfalse elseblock1 // goto else block
   Stack: 
11: push 11 // Terminal
   Stack: 11 | 
12: loadref 0 // i
   Stack: 11 | &0 | 
13: assign
   Stack: 11 | 
14: pop // discarge expression result for ExprStatement
   Stack: 
15: br endif1 // goto endif
Parsed: [int i = 12;
if (i < 10) i = 11; else i = 9;] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 12
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              i
            '='
            Literal:
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 9
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 12
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
            VarName:Sem=[i=int] ExprSem=[i=int]
              i
            '='
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
              VarName:Sem=[i=int] ExprSem=[i=int]
                i
              '='
              Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                : 9
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse elseblock1 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif1 // goto endif
elseblock1: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 12 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse elseblock1 // goto else block
11: push 11 // Terminal
12: loadref 0 // i
13: assign
14: pop // discarge expression result for ExprStatement
15: br endif1 // goto endif
16: elseblock1: nop // 
17: push 9 // Terminal
18: loadref 0 // i
19: assign
20: pop // discarge expression result for ExprStatement
21: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 12 // Terminal
   Stack: 12 | 
4: loadref 0 // i
   Stack: 12 | &0 | 
5: assign
   Stack: 12 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 12 | 
8: push 10 // Terminal
   Stack: 12 | 10 | 
9: lt
   Stack: false | 
10: brfalse elseblock1 // goto else block
   Stack: 
17: push 9 // Terminal
   Stack: 9 | 
18: loadref 0 // i
   Stack: 9 | &12 | 
19: assign
   Stack: 9 | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: endif1: nop // 
Parsed: [int i = 5;
if (i < 10) { if (3 < i) i = 2; else i = 4; }
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 5
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        Block:
          Statement:
            IfStatement:
              RelationalExpr:
                Literal:
                  : 3
                '<'
                VarName:
                  i
              Statement:
                ExprStatement:
                  AssignmentExpr:
                    VarName:
                      i
                    '='
                    Literal:
                      : 2
              ElseStatement:
                Statement:
                  ExprStatement:
                    AssignmentExpr:
                      VarName:
                        i
                      '='
                      Literal:
                        : 4
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 5
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        Block:
         SymbolTable: [
          int i
         ]
          Statement:
            IfStatement:
              RelationalExpr:Sem=[bool=bool]
                Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                  : 3
                '<'
                VarName:Sem=[i=int] ExprSem=[i=int]
                  i
              Statement:
                ExprStatement:
                  AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
                    VarName:Sem=[i=int] ExprSem=[i=int]
                      i
                    '='
                    Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                      : 2
              ElseStatement:
                Statement:
                  ExprStatement:
                    AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
                      VarName:Sem=[i=int] ExprSem=[i=int]
                        i
                      '='
                      Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                        : 4
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse endif1 // goto endif
load 0 // i
lt
brfalse elseblock2 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif2 // goto endif
elseblock2: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif2: nop // 
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 5 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse endif1 // goto endif
11: push 3 // Terminal
12: load 0 // i
13: lt
14: brfalse elseblock2 // goto else block
15: push 2 // Terminal
16: loadref 0 // i
17: assign
18: pop // discarge expression result for ExprStatement
19: br endif2 // goto endif
20: elseblock2: nop // 
21: push 4 // Terminal
22: loadref 0 // i
23: assign
24: pop // discarge expression result for ExprStatement
25: endif2: nop // 
26: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 5 // Terminal
   Stack: 5 | 
4: loadref 0 // i
   Stack: 5 | &0 | 
5: assign
   Stack: 5 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 5 | 
8: push 10 // Terminal
   Stack: 5 | 10 | 
9: lt
   Stack: true | 
10: brfalse endif1 // goto endif
   Stack: 
11: push 3 // Terminal
   Stack: 3 | 
12: load 0 // i
   Stack: 3 | 5 | 
13: lt
   Stack: true | 
14: brfalse elseblock2 // goto else block
   Stack: 
15: push 2 // Terminal
   Stack: 2 | 
16: loadref 0 // i
   Stack: 2 | &5 | 
17: assign
   Stack: 2 | 
18: pop // discarge expression result for ExprStatement
   Stack: 
19: br endif2 // goto endif
   Stack: 
26: endif1: nop // 
</pre>
<h2><a id="Statements_Test.switchStatement">Statements_Test.switchStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdk.lang.String.equals<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.ifStatement
[AUNIT:ENDT] End Test: Statements_Test.ifStatement
[AUNIT:STRT] Start Test: Statements_Test.switchStatement
[AUNIT:STRT] Start Test: Statements_Test.switchStatement
Parsed: [int i = 2;
switch (i) {
case 1: i = 3; break;
case 2: i = 4; break;
}
__assert(i == 4, "switch failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    SwitchStatement:
      VarName:
        i
      CaseClause:
        'case'
        Literal:
          : 1
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 3
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'case'
        Literal:
          : 2
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 4
        Statement:
          BreakStatement:
            'break'
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : switch failed
Create Var i at idx: 0
Create Var __switchtestexpr1 at idx: 1
Code already postParsed: VarName: __switchtestexpr1
Code already postParsed: Literal: 
Code already postParsed: VarName: __switchtestexpr1
Code already postParsed: Literal: 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // __switchtestexpr1
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // __switchtestexpr1
assign
pop // discarge expression result for ExprStatement
load 1 // __switchtestexpr1
eq
brfalse case2 // goto next switch
case_stmt3: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endswitch1 // break/continue
br case_stmt4 // goto next switch stm block
case2: nop // 
load 1 // __switchtestexpr1
eq
brfalse endswitch1 // goto next switch
case_stmt4: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endswitch1 // break/continue
endswitch1: nop // 
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // __switchtestexpr1
8: push 0 // initialize local value
9: store 1 // initialize local value
10: load 0 // i
11: loadref 1 // __switchtestexpr1
12: assign
13: pop // discarge expression result for ExprStatement
14: load 1 // __switchtestexpr1
15: push 1 // Terminal
16: eq
17: brfalse case2 // goto next switch
18: case_stmt3: nop // 
19: push 3 // Terminal
20: loadref 0 // i
21: assign
22: pop // discarge expression result for ExprStatement
23: br endswitch1 // break/continue
24: br case_stmt4 // goto next switch stm block
25: case2: nop // 
26: load 1 // __switchtestexpr1
27: push 2 // Terminal
28: eq
29: brfalse endswitch1 // goto next switch
30: case_stmt4: nop // 
31: push 4 // Terminal
32: loadref 0 // i
33: assign
34: pop // discarge expression result for ExprStatement
35: br endswitch1 // break/continue
36: endswitch1: nop // 
37: load 0 // i
38: push 4 // Terminal
39: eq
40: push "switch failed" // Terminal
41: assert
42: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // __switchtestexpr1
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: loadref 1 // __switchtestexpr1
   Stack: 2 | &0 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 1 // __switchtestexpr1
   Stack: 2 | 
15: push 1 // Terminal
   Stack: 2 | 1 | 
16: eq
   Stack: false | 
17: brfalse case2 // goto next switch
   Stack: 
26: load 1 // __switchtestexpr1
   Stack: 2 | 
27: push 2 // Terminal
   Stack: 2 | 2 | 
28: eq
   Stack: true | 
29: brfalse endswitch1 // goto next switch
   Stack: 
30: case_stmt4: nop // 
   Stack: 
31: push 4 // Terminal
   Stack: 4 | 
32: loadref 0 // i
   Stack: 4 | &2 | 
33: assign
   Stack: 4 | 
34: pop // discarge expression result for ExprStatement
   Stack: 
35: br endswitch1 // break/continue
   Stack: 
37: load 0 // i
   Stack: 4 | 
38: push 4 // Terminal
   Stack: 4 | 4 | 
39: eq
   Stack: true | 
40: push "switch failed" // Terminal
   Stack: true | switch failed | 
41: assert
   Stack: true | 
42: pop // discarge expression result for ExprStatement
Parsed: [int i = 2;
switch (i) {
case 1: i = 3; break;
case 4: break;
default: i = 10;
}
__assert(i == 10, "switch failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    SwitchStatement:
      VarName:
        i
      CaseClause:
        'case'
        Literal:
          : 1
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 3
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'case'
        Literal:
          : 4
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'default'
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 10
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 10
              Argument:
                Literal:
                  : switch failed
Create Var i at idx: 0
Create Var __switchtestexpr5 at idx: 1
Code already postParsed: VarName: __switchtestexpr5
Code already postParsed: Literal: 
Code already postParsed: VarName: __switchtestexpr5
Code already postParsed: Literal: 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // __switchtestexpr5
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // __switchtestexpr5
assign
pop // discarge expression result for ExprStatement
load 1 // __switchtestexpr5
eq
brfalse case6 // goto next switch
case_stmt7: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endswitch5 // break/continue
br case_stmt9 // goto next switch stm block
case6: nop // 
load 1 // __switchtestexpr5
eq
brfalse case8 // goto next switch
case_stmt9: nop // 
br endswitch5 // break/continue
br case_stmt10 // goto next switch stm block
case8: nop // 
case_stmt10: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endswitch5: nop // 
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // __switchtestexpr5
8: push 0 // initialize local value
9: store 1 // initialize local value
10: load 0 // i
11: loadref 1 // __switchtestexpr5
12: assign
13: pop // discarge expression result for ExprStatement
14: load 1 // __switchtestexpr5
15: push 1 // Terminal
16: eq
17: brfalse case6 // goto next switch
18: case_stmt7: nop // 
19: push 3 // Terminal
20: loadref 0 // i
21: assign
22: pop // discarge expression result for ExprStatement
23: br endswitch5 // break/continue
24: br case_stmt9 // goto next switch stm block
25: case6: nop // 
26: load 1 // __switchtestexpr5
27: push 4 // Terminal
28: eq
29: brfalse case8 // goto next switch
30: case_stmt9: nop // 
31: br endswitch5 // break/continue
32: br case_stmt10 // goto next switch stm block
33: case8: nop // 
34: case_stmt10: nop // 
35: push 10 // Terminal
36: loadref 0 // i
37: assign
38: pop // discarge expression result for ExprStatement
39: endswitch5: nop // 
40: load 0 // i
41: push 10 // Terminal
42: eq
43: push "switch failed" // Terminal
44: assert
45: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // __switchtestexpr5
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: loadref 1 // __switchtestexpr5
   Stack: 2 | &0 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 1 // __switchtestexpr5
   Stack: 2 | 
15: push 1 // Terminal
   Stack: 2 | 1 | 
16: eq
   Stack: false | 
17: brfalse case6 // goto next switch
   Stack: 
26: load 1 // __switchtestexpr5
   Stack: 2 | 
27: push 4 // Terminal
   Stack: 2 | 4 | 
28: eq
   Stack: false | 
29: brfalse case8 // goto next switch
   Stack: 
34: case_stmt10: nop // 
   Stack: 
35: push 10 // Terminal
   Stack: 10 | 
36: loadref 0 // i
   Stack: 10 | &2 | 
37: assign
   Stack: 10 | 
38: pop // discarge expression result for ExprStatement
   Stack: 
39: endswitch5: nop // 
   Stack: 
40: load 0 // i
   Stack: 10 | 
41: push 10 // Terminal
   Stack: 10 | 10 | 
42: eq
   Stack: true | 
43: push "switch failed" // Terminal
   Stack: true | switch failed | 
44: assert
   Stack: true | 
45: pop // discarge expression result for ExprStatement
Parsed: [int i = 1;
switch (i) {
case 1: i = 2; // nobreak
case 4: ++i; break;
default: i = 10;
}
__assert(i == 3, "switch failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 1
  Statement:
    SwitchStatement:
      VarName:
        i
      CaseClause:
        'case'
        Literal:
          : 1
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 2
      CaseClause:
        'case'
        Literal:
          : 4
        Statement:
          ExprStatement:
            PrefixExpr:
              '++'
              VarName:
                i
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'default'
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 10
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : switch failed
Create Var i at idx: 0
Create Var __switchtestexpr11 at idx: 1
Code already postParsed: VarName: __switchtestexpr11
Code already postParsed: Literal: 
Code already postParsed: VarName: __switchtestexpr11
Code already postParsed: Literal: 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // __switchtestexpr11
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // __switchtestexpr11
assign
pop // discarge expression result for ExprStatement
load 1 // __switchtestexpr11
eq
brfalse case12 // goto next switch
case_stmt13: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br case_stmt15 // goto next switch stm block
case12: nop // 
load 1 // __switchtestexpr11
eq
brfalse case14 // goto next switch
case_stmt15: nop // 
loadref 0 // i
inc // prefix inc/dec
pop // discarge expression result for ExprStatement
br endswitch11 // break/continue
br case_stmt16 // goto next switch stm block
case14: nop // 
case_stmt16: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endswitch11: nop // 
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 1 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // __switchtestexpr11
8: push 0 // initialize local value
9: store 1 // initialize local value
10: load 0 // i
11: loadref 1 // __switchtestexpr11
12: assign
13: pop // discarge expression result for ExprStatement
14: load 1 // __switchtestexpr11
15: push 1 // Terminal
16: eq
17: brfalse case12 // goto next switch
18: case_stmt13: nop // 
19: push 2 // Terminal
20: loadref 0 // i
21: assign
22: pop // discarge expression result for ExprStatement
23: br case_stmt15 // goto next switch stm block
24: case12: nop // 
25: load 1 // __switchtestexpr11
26: push 4 // Terminal
27: eq
28: brfalse case14 // goto next switch
29: case_stmt15: nop // 
30: loadref 0 // i
31: inc // prefix inc/dec
32: pop // discarge expression result for ExprStatement
33: br endswitch11 // break/continue
34: br case_stmt16 // goto next switch stm block
35: case14: nop // 
36: case_stmt16: nop // 
37: push 10 // Terminal
38: loadref 0 // i
39: assign
40: pop // discarge expression result for ExprStatement
41: endswitch11: nop // 
42: load 0 // i
43: push 3 // Terminal
44: eq
45: push "switch failed" // Terminal
46: assert
47: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 1 // Terminal
   Stack: 1 | 
4: loadref 0 // i
   Stack: 1 | &0 | 
5: assign
   Stack: 1 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // __switchtestexpr11
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // i
   Stack: 1 | 
11: loadref 1 // __switchtestexpr11
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 1 // __switchtestexpr11
   Stack: 1 | 
15: push 1 // Terminal
   Stack: 1 | 1 | 
16: eq
   Stack: true | 
17: brfalse case12 // goto next switch
   Stack: 
18: case_stmt13: nop // 
   Stack: 
19: push 2 // Terminal
   Stack: 2 | 
20: loadref 0 // i
   Stack: 2 | &1 | 
21: assign
   Stack: 2 | 
22: pop // discarge expression result for ExprStatement
   Stack: 
23: br case_stmt15 // goto next switch stm block
   Stack: 
30: loadref 0 // i
   Stack: &2 | 
31: inc // prefix inc/dec
   Stack: 3 | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: br endswitch11 // break/continue
   Stack: 
42: load 0 // i
   Stack: 3 | 
43: push 3 // Terminal
   Stack: 3 | 3 | 
44: eq
   Stack: true | 
45: push "switch failed" // Terminal
   Stack: true | switch failed | 
46: assert
   Stack: true | 
47: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
switch ("B") {
case "A": i = 1; break;
case "B": i = 3; break;
default: i = 10;
}
__assert(i == 3, "switch failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    SwitchStatement:
      Literal:
        : B
      CaseClause:
        'case'
        Literal:
          : A
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 1
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'case'
        Literal:
          : B
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 3
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'default'
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 10
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : switch failed
Create Var i at idx: 0
Create Var __switchtestexpr17 at idx: 1
Code already postParsed: STRING_LITERAL: 
Code already postParsed: VarName: __switchtestexpr17
Code already postParsed: KeywordParseNode: 
Code already postParsed: Literal: 
Code already postParsed: VarName: __switchtestexpr17
[AUNIT:ERRR] Error in Test: Statements_Test.switchStatement: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: Statements_Test.switchStatement: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="Statements_Test.expressionIf">Statements_Test.expressionIf</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.switchStatement
[AUNIT:ENDT] End Test: Statements_Test.switchStatement
[AUNIT:STRT] Start Test: Statements_Test.expressionIf
[AUNIT:STRT] Start Test: Statements_Test.expressionIf
Parsed: [__assert((1 < 2 ? 3 : 4) == 3, "expressional if failed");
__assert((1 > 2 ? 3 : 4) == 4, "expressional if failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ConditionalExpr:
                    RelationalExpr:
                      Literal:
                        : 1
                      '<'
                      Literal:
                        : 2
                    Literal:
                      : 3
                    Literal:
                      : 4
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : expressional if failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ConditionalExpr:
                    RelationalExpr:
                      Literal:
                        : 1
                      '>'
                      Literal:
                        : 2
                    Literal:
                      : 3
                    Literal:
                      : 4
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : expressional if failed
lt
brfalse __expriffalse1 // expr if false
br __expriftrue1 // expr if true
__expriffalse1: nop // 
__expriftrue1: nop // 
eq
assert
pop // discarge expression result for ExprStatement
gt
brfalse __expriffalse2 // expr if false
br __expriftrue2 // expr if true
__expriffalse2: nop // 
__expriftrue2: nop // 
eq
assert
pop // discarge expression result for ExprStatement
0: push 1 // Terminal
1: push 2 // Terminal
2: lt
3: brfalse __expriffalse1 // expr if false
4: push 3 // Terminal
5: br __expriftrue1 // expr if true
6: __expriffalse1: nop // 
7: push 4 // Terminal
8: __expriftrue1: nop // 
9: push 3 // Terminal
10: eq
11: push "expressional if failed" // Terminal
12: assert
13: pop // discarge expression result for ExprStatement
14: push 1 // Terminal
15: push 2 // Terminal
16: gt
17: brfalse __expriffalse2 // expr if false
18: push 3 // Terminal
19: br __expriftrue2 // expr if true
20: __expriffalse2: nop // 
21: push 4 // Terminal
22: __expriftrue2: nop // 
23: push 4 // Terminal
24: eq
25: push "expressional if failed" // Terminal
26: assert
27: pop // discarge expression result for ExprStatement
   Stack: 
0: push 1 // Terminal
   Stack: 1 | 
1: push 2 // Terminal
   Stack: 1 | 2 | 
2: lt
   Stack: true | 
3: brfalse __expriffalse1 // expr if false
   Stack: 
4: push 3 // Terminal
   Stack: 3 | 
5: br __expriftrue1 // expr if true
   Stack: 3 | 
9: push 3 // Terminal
   Stack: 3 | 3 | 
10: eq
   Stack: true | 
11: push "expressional if failed" // Terminal
   Stack: true | expressional if failed | 
12: assert
   Stack: true | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 1 // Terminal
   Stack: 1 | 
15: push 2 // Terminal
   Stack: 1 | 2 | 
16: gt
   Stack: false | 
17: brfalse __expriffalse2 // expr if false
   Stack: 
21: push 4 // Terminal
   Stack: 4 | 
22: __expriftrue2: nop // 
   Stack: 4 | 
23: push 4 // Terminal
   Stack: 4 | 4 | 
24: eq
   Stack: true | 
25: push "expressional if failed" // Terminal
   Stack: true | expressional if failed | 
26: assert
   Stack: true | 
27: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="WeakInvoke_Test.callAalObject">WeakInvoke_Test.callAalObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 AClass.foo<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: Statements_Test.expressionIf
[AUNIT:ENDT] End Test: Statements_Test.expressionIf
[AUNIT:STRT] Start Test: WeakInvoke_Test.callAalObject
[AUNIT:STRT] Start Test: WeakInvoke_Test.callAalObject
Parsed: [using acdk.lang;
class AClass {
  public int foo(String obj) { return 2; }
}AClass cls = new AClass();
try {
  cls->foo(42);
} catch (ParamsMismatchException ex) {
  System.out.println(ex.getMessage());
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            TypeName:
              int
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              TypeName:
                String
            VarName:
              obj
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : 2
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          AClass
      VarName:
        cls
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              AClass
          Arguments:
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  cls
                MemberSubscribeExpr:
                  '->'
                  SubscribeExpr:
                    VarName:
                      foo
                    FuncSubscribeExpr:
                      Arguments:
                        Argument:
                          Literal:
                            : 42
      CatchBlock:
        FqTypeName:
          TypeName:
            ParamsMismatchException
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var obj at idx: 0
acdk.lang.String obj
Create Var this at idx: 0
AClass this
acdk.lang.String obj
Create Var this at idx: 0
AClass this
Create Var cls at idx: 0
[AUNIT:ERRR] Error in Test: WeakInvoke_Test.callAalObject: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: WeakInvoke_Test.callAalObject: acdk/lang/NoSuchElementException
Called in:
</pre>
<h2><a id="WeakInvoke_Test.callComObject">WeakInvoke_Test.callComObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Field not found: 0x0 acdkx.com.ComObject.Visible<br>Called in:<br><pre>  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in acdk (ACDK_AAL.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_TOOLS_AUNIT.DLL)
  called in acdk (ACDK_CORE.DLL)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
  called in _GetExceptDLLinfo (acdk_aal_Test.exe)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT] End Test: WeakInvoke_Test.callAalObject
[AUNIT:ENDT] End Test: WeakInvoke_Test.callAalObject
[AUNIT:STRT] Start Test: WeakInvoke_Test.callComObject
[AUNIT:STRT] Start Test: WeakInvoke_Test.callComObject
Parsed: [using acdk.lang;
using acdkx.com;
ComObject o = new ComObject("Word.Application");
o.Visible = true;
int exitcode = 0;
o.Quit(exitcode);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdk
        FqTypeName:
          TypeName:
            lang
  Statement:
    UsingDecl:
      FqTypeName:
        TypeName:
          acdkx
        FqTypeName:
          TypeName:
            com
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          ComObject
      VarName:
        o
      VarInitializer:
        NewExpr:
          FqTypeName:
            TypeName:
              ComObject
          Arguments:
            Argument:
              Literal:
                : Word.Application
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              Visible
        '='
        Literal:
          BOOLEAN_LITERAL:
            'true'
  Statement:
    LVarDecl:
      FqTypeName:
        TypeName:
          int
      VarName:
        exitcode
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              Quit
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    exitcode
Create Var o at idx: 0
[AUNIT:ERRR] Error in Test: WeakInvoke_Test.callComObject: acdk/lang/NoSuchElementException
[AUNIT:ERRR] Error in Test: WeakInvoke_Test.callComObject: acdk/lang/NoSuchElementException
Called in:
</pre>
</body></html>

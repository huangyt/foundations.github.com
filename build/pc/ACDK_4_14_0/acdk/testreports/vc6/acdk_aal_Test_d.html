<html><body>
<h1>Unit Test 2004-05-25T02:01:59</h1>
<a href="index.html">Back to Index</a><br>
<table border=0 width="100%"><tr><td bgcolor="red">TEST FAILED</td></tr></table>
Tests: 65; Failures: 0; Errors: 11<br>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AalObject_Test.staticMember">AalObject_Test.staticMember</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AalObject_Test.dynMember">AalObject_Test.dynMember</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AritmExpr_Test.incDec">AritmExpr_Test.incDec</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#AritmExpr_Test.multiply">AritmExpr_Test.multiply</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Arrays_Test.basicArrays">Arrays_Test.basicArrays</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Arrays_Test.objectArrays">Arrays_Test.objectArrays</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.standard">Basics_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.syntax">Basics_Test.syntax</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.expressions">Basics_Test.expressions</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.statements">Basics_Test.statements</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.functionDecl">Basics_Test.functionDecl</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.CondAndLoops">Basics_Test.CondAndLoops</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectDecls">Basics_Test.objectDecls</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectCalls">Basics_Test.objectCalls</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.objectOperator">Basics_Test.objectOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Basics_Test.experimental">Basics_Test.experimental</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#BinaryExpr_Test.basicRels">BinaryExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Closure_Test.standard">Closure_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Compiler_Test.standard">Compiler_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Compiler_Test.grammar">Compiler_Test.grammar</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Compiler_Test.errors">Compiler_Test.errors</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#DefunStatements_Test.standard">DefunStatements_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#DeriveObject_Test.deriveAalObject">DeriveObject_Test.deriveAalObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#DeriveObject_Test.deriveAcdkObject">DeriveObject_Test.deriveAcdkObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Exceptions_Test.basicThrow">Exceptions_Test.basicThrow</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Exceptions_Test.catchAalException">Exceptions_Test.catchAalException</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Exceptions_Test.throwAckdCatchAalException">Exceptions_Test.throwAckdCatchAalException</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Exceptions_Test.aalExceptions">Exceptions_Test.aalExceptions</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ExtendClass_Test.extendClass">ExtendClass_Test.extendClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Functions_Test.standard">Functions_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.standard">Interpret_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.assignment">Interpret_Test.assignment</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.fqClassInvoke">Interpret_Test.fqClassInvoke</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.classOperator">Interpret_Test.classOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Interpret_Test.derivedClass">Interpret_Test.derivedClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Interpret_Test.interfaceClass">Interpret_Test.interfaceClass</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LiteralWrapping_Test.wrappedStrings">LiteralWrapping_Test.wrappedStrings</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LiteralWrapping_Test.wrappedNumbers">LiteralWrapping_Test.wrappedNumbers</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LogicalExpr_Test.basicRels">LogicalExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#LogicalExpr_Test.operatorRels">LogicalExpr_Test.operatorRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Operator_Test.plusOperator">Operator_Test.plusOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Operator_Test.callOperator">Operator_Test.callOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Operator_Test.arrayOperator">Operator_Test.arrayOperator</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.polymorph">ParameterPassing_Test.polymorph</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.namedParameter">ParameterPassing_Test.namedParameter</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#ParameterPassing_Test.restParameter">ParameterPassing_Test.restParameter</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#RelExpr_Test.basicRels">RelExpr_Test.basicRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#RelExpr_Test.operatorRels">RelExpr_Test.operatorRels</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#RelExpr_Test.equalsExpr">RelExpr_Test.equalsExpr</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.standard">Scanner_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.string">Scanner_Test.string</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.interactive">Scanner_Test.interactive</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Scanner_Test.cComments">Scanner_Test.cComments</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.standard">Statements_Test.standard</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.varDecl">Statements_Test.varDecl</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.block">Statements_Test.block</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.whileStatement">Statements_Test.whileStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.doStatement">Statements_Test.doStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.forStatement">Statements_Test.forStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.gotoStatement">Statements_Test.gotoStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.ifStatement">Statements_Test.ifStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#Statements_Test.switchStatement">Statements_Test.switchStatement</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#Statements_Test.expressionIf">Statements_Test.expressionIf</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="ltgreen"> <a href="#WeakInvoke_Test.callAalObject">WeakInvoke_Test.callAalObject</a> <br>
</td></tr></table>
<table border=0 width="100%"><tr><td bgcolor="FF8080"> <a href="#WeakInvoke_Test.callComObject">WeakInvoke_Test.callComObject</a> <br>
</td></tr></table>
<h2><a id="AalObject_Test.staticMember">AalObject_Test.staticMember</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:STRT][AalObject_Test.staticMember] Start Test
Parsed: [using acdk.lang;
class BaseClass { public static int ivar = 42; }
__assert(BaseClass.ivar == 42, "initialization of static members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
          'static'
        FqTypeName:
          
        VarName:
          ivar
        VarInitializer:
          Literal:
            : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      BaseClass
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        ivar
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : initialization of static members failed
Create Var this at idx: 0
BaseClass this
push "BaseClass" // classname
push "ivar" // fieldname
push 0 // dmi flags
poke_static // 
pop // 
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
push <undefined> // void return
ret  // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: ret  // 
3: push "BaseClass" // class name
4: push "ivar" // fieldname
5: push 0 // dmi flags
6: peek_static
7: push 42 // Terminal
8: eq
9: push "initialization of static members failed" // Terminal
10: assert
11: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
0: push 42 // Terminal
   Stack: 42 | 
1: push "BaseClass" // classname
   Stack: 42 | BaseClass | 
2: push "ivar" // fieldname
   Stack: 42 | BaseClass | ivar | 
3: push 0 // dmi flags
   Stack: 42 | BaseClass | ivar | 0 | 
4: poke_static // 
   Stack: 42 | 
5: pop // 
   Stack: 
6: push <undefined> // void return
   Stack: 
2: ret  // 
Parsed: [using acdk.lang;
class BaseClass { public static int ivar = 42; static int getIvar() { return BaseClass.ivar; return ivar; } }
__assert(BaseClass.getIvar() == 42, "initialization of static members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
          'static'
        FqTypeName:
          
        VarName:
          ivar
        VarInitializer:
          Literal:
            : 42
      ClassDeclMethod:
        ClassMemberAttr:
          'static'
        ReturnType:
          FqTypeName:
            
        MethodName:
          getIvar
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                SubscribeExpr:
                  VarName:
                    BaseClass
                  MemberSubscribeExpr:
                    '.'
                    VarName:
                      ivar
            Statement:
              ReturnStatement:
                VarName:
                  ivar
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      BaseClass
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          getIvar
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : initialization of static members failed
Create Var this at idx: 0
BaseClass this
push "BaseClass" // classname
push "ivar" // fieldname
push 0 // dmi flags
poke_static // 
pop // 
__method_start: nop // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
ret  // return statement
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
ret  // return statement
Function getIvar[
__method_start: nop // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
ret  // return statement
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
push <undefined> // void return
ret  // 
push "BaseClass" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1956407307 // function name: _0_getIvar
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: ret  // 
3: push "BaseClass" // class name
4: clvr 0 // ClassName or object instance
5: store 0
6: load 0 // ClassName or object instance
7: push 1956407307 // function name: _0_getIvar
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke_static
10: push 42 // Terminal
11: eq
12: push "initialization of static members failed" // Terminal
13: assert
14: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
0: push 42 // Terminal
   Stack: 42 | 
1: push "BaseClass" // classname
   Stack: 42 | BaseClass | 
2: push "ivar" // fieldname
   Stack: 42 | BaseClass | ivar | 
3: push 0 // dmi flags
   Stack: 42 | BaseClass | ivar | 0 | 
4: poke_static // 
   Stack: 42 | 
5: pop // 
   Stack: 
6: push <undefined> // void return
   Stack: 
2: ret  // 
Parsed: [using acdk.lang;
class BaseClass { public static int ivar = 0; static BaseClass() { ivar = 42; } }
__assert(BaseClass.ivar == 42, "initialization of static members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
          'static'
        FqTypeName:
          
        VarName:
          ivar
        VarInitializer:
          Literal:
            : 0
      ClassDeclConstructor:
        ClassMemberAttr:
          'static'
        MethodName:
          BaseClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ivar
                  '='
                  Literal:
                    : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      BaseClass
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        ivar
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : initialization of static members failed
Create Var this at idx: 0
BaseClass this
push "BaseClass" // classname
push "ivar" // fieldname
push 0 // dmi flags
poke_static // 
pop // 
__method_start: nop // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
poke_static
pop // discarge expression result for ExprStatement
push <undefined> // void return
ret  // 
Function BaseClass[
push 0 // Terminal
push "BaseClass" // classname
push "ivar" // fieldname
push 0 // dmi flags
poke_static // 
pop // 
__method_start: nop // 
push 42 // Terminal
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
poke_static
pop // discarge expression result for ExprStatement
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
push "BaseClass" // class name
push "ivar" // fieldname
push 0 // dmi flags
peek_static
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: push "BaseClass" // class name
3: push "ivar" // fieldname
4: push 0 // dmi flags
5: peek_static
6: push 42 // Terminal
7: eq
8: push "initialization of static members failed" // Terminal
9: assert
10: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
0: push 0 // Terminal
   Stack: 0 | 
1: push "BaseClass" // classname
   Stack: 0 | BaseClass | 
2: push "ivar" // fieldname
   Stack: 0 | BaseClass | ivar | 
3: push 0 // dmi flags
   Stack: 0 | BaseClass | ivar | 0 | 
4: poke_static // 
   Stack: 0 | 
5: pop // 
   Stack: 
6: __method_start: nop // 
   Stack: 
7: push 42 // Terminal
   Stack: 42 | 
8: push "BaseClass" // class name
   Stack: 42 | BaseClass | 
9: push "ivar" // fieldname
   Stack: 42 | BaseClass | ivar | 
10: push 0 // dmi flags
   Stack: 42 | BaseClass | ivar | 0 | 
11: poke_static
   Stack: 42 | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: push <undefined> // void return
   Stack: Nil | 
14: ret  // 
   Stack: 
2: push "BaseClass" // class name
   Stack: BaseClass | 
3: push "ivar" // fieldname
   Stack: BaseClass | ivar | 
4: push 0 // dmi flags
   Stack: BaseClass | ivar | 0 | 
5: peek_static
   Stack: 42 | 
6: push 42 // Terminal
   Stack: 42 | 42 | 
7: eq
   Stack: true | 
8: push "initialization of static members failed" // Terminal
   Stack: true | initialization of static members failed | 
9: assert
   Stack: true | 
10: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="AalObject_Test.dynMember">AalObject_Test.dynMember</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][AalObject_Test.staticMember] End Test
[AUNIT:STRT][AalObject_Test.dynMember] Start Test
Parsed: [using acdk.lang;
class BaseClass { public BaseClass() {} String getString() { return "A"; } }
__assert((new BaseClass()).getString().length() == 1, "initialization of dynamic members failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          getString
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : A
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    NewExpr:
                      FqTypeName:
                        
                      Arguments:
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          getString
                        FuncSubscribeExpr:
                          Arguments:
                        MemberSubscribeExpr:
                          '.'
                          SubscribeExpr:
                            VarName:
                              length
                            FuncSubscribeExpr:
                              Arguments:
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : initialization of dynamic members failed
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
BaseClass this
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
ret  // return statement
Function getString[
__method_start: nop // 
push "A" // Terminal
ret  // return statement
]
push "BaseClass" // class name to initialize
init_clazz // 
push "BaseClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push -844898855 // function name: _1_getString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
Create Var __tvar2 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 62464505 // function name: _z_length
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: push "BaseClass" // class name
3: push 0 // dmi flags = 0, argcount = 0
4: new
5: clvr 0 // ClassName or object instance
6: store 0
7: load 0 // ClassName or object instance
8: push -844898855 // function name: _1_getString
9: push 67108880 // dmi flags = PUBLIC, argcount = 0
10: hash_invoke
11: clvr 1 // ClassName or object instance
12: store 1
13: load 1 // ClassName or object instance
14: push 62464505 // function name: _z_length
15: push 67108880 // dmi flags = PUBLIC, argcount = 0
16: hash_invoke
17: push 1 // Terminal
18: eq
19: push "initialization of dynamic members failed" // Terminal
20: assert
21: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
2: push "BaseClass" // class name
   Stack: BaseClass | 
3: push 0 // dmi flags = 0, argcount = 0
   Stack: BaseClass | 0 | 
4: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: BaseClass | 
5: clvr 0 // ClassName or object instance
   Stack: BaseClass | 
6: store 0
   Stack: 
7: load 0 // ClassName or object instance
   Stack: BaseClass | 
8: push -844898855 // function name: _1_getString
   Stack: BaseClass | -844898855 | 
9: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: BaseClass | -844898855 | 67108880 | 
10: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "A" // Terminal
   Stack: A | 
2: ret  // return statement
   Stack: A | 
11: clvr 1 // ClassName or object instance
   Stack: A | 
12: store 1
   Stack: 
13: load 1 // ClassName or object instance
   Stack: A | 
14: push 62464505 // function name: _z_length
   Stack: A | 62464505 | 
15: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: A | 62464505 | 67108880 | 
16: hash_invoke
   Stack: 1 | 
17: push 1 // Terminal
   Stack: 1 | 1 | 
18: eq
   Stack: true | 
19: push "initialization of dynamic members failed" // Terminal
   Stack: true | initialization of dynamic members failed | 
20: assert
   Stack: true | 
21: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="AritmExpr_Test.incDec">AritmExpr_Test.incDec</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][AalObject_Test.dynMember] End Test
[AUNIT:STRT][AritmExpr_Test.incDec] Start Test
Parsed: [int i = 0;
int j = ++i;
--i;
__assert(j == 1 && i == 0, "Prefix ++ not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        PrefixExpr:
          '++'
          VarName:
            i
  Statement:
    ExprStatement:
      PrefixExpr:
        '--'
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                LogicalANDExpr:
                  EqualityExpr:
                    VarName:
                      j
                    '=='
                    Literal:
                      : 1
                  '&&'
                  EqualityExpr:
                    VarName:
                      i
                    '=='
                    Literal:
                      : 0
              Argument:
                Literal:
                  : Prefix ++ not working
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 0 // i
inc // prefix inc/dec
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
dec // prefix inc/dec
pop // discarge expression result for ExprStatement
load 1 // j
eq
dup // safe lh expr result
brfalse logexprend1 // bool short-circuit
pop // remove lh expr result
load 0 // i
eq
logexprend1: nop // 
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: loadref 0 // i
11: inc // prefix inc/dec
12: loadref 1 // j
13: assign
14: pop // discarge expression result for ExprStatement
15: loadref 0 // i
16: dec // prefix inc/dec
17: pop // discarge expression result for ExprStatement
18: load 1 // j
19: push 1 // Terminal
20: eq
21: dup // safe lh expr result
22: brfalse logexprend1 // bool short-circuit
23: pop // remove lh expr result
24: load 0 // i
25: push 0 // Terminal
26: eq
27: logexprend1: nop // 
28: push "Prefix ++ not working" // Terminal
29: assert
30: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: inc // prefix inc/dec
   Stack: 1 | 
12: loadref 1 // j
   Stack: 1 | &0 | 
13: assign
   Stack: 1 | 
14: pop // discarge expression result for ExprStatement
   Stack: 
15: loadref 0 // i
   Stack: &1 | 
16: dec // prefix inc/dec
   Stack: 0 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: load 1 // j
   Stack: 1 | 
19: push 1 // Terminal
   Stack: 1 | 1 | 
20: eq
   Stack: true | 
21: dup // safe lh expr result
   Stack: true | true | 
22: brfalse logexprend1 // bool short-circuit
   Stack: true | 
23: pop // remove lh expr result
   Stack: 
24: load 0 // i
   Stack: 0 | 
25: push 0 // Terminal
   Stack: 0 | 0 | 
26: eq
   Stack: true | 
27: logexprend1: nop // 
   Stack: true | 
28: push "Prefix ++ not working" // Terminal
   Stack: true | Prefix ++ not working | 
29: assert
   Stack: true | 
30: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
int j = i++;
--i;
__assert(j == 0 && i == 0, "Postfix ++ not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        PostfixExpr:
          VarName:
            i
          '++'
  Statement:
    ExprStatement:
      PrefixExpr:
        '--'
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                LogicalANDExpr:
                  EqualityExpr:
                    VarName:
                      j
                    '=='
                    Literal:
                      : 0
                  '&&'
                  EqualityExpr:
                    VarName:
                      i
                    '=='
                    Literal:
                      : 0
              Argument:
                Literal:
                  : Postfix ++ not working
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 0 // i
Create Var __tvar1 at idx: 2
dupval // postfix expression temp
clvr 2 // postfix expression temp
store 2
inc // prefix inc/dec
pop // postfix expression temp erg
load 2
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
dec // prefix inc/dec
pop // discarge expression result for ExprStatement
load 1 // j
eq
dup // safe lh expr result
brfalse logexprend2 // bool short-circuit
pop // remove lh expr result
load 0 // i
eq
logexprend2: nop // 
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: loadref 0 // i
11: dupval // postfix expression temp
12: clvr 2 // postfix expression temp
13: store 2
14: inc // prefix inc/dec
15: pop // postfix expression temp erg
16: load 2
17: loadref 1 // j
18: assign
19: pop // discarge expression result for ExprStatement
20: loadref 0 // i
21: dec // prefix inc/dec
22: pop // discarge expression result for ExprStatement
23: load 1 // j
24: push 0 // Terminal
25: eq
26: dup // safe lh expr result
27: brfalse logexprend2 // bool short-circuit
28: pop // remove lh expr result
29: load 0 // i
30: push 0 // Terminal
31: eq
32: logexprend2: nop // 
33: push "Postfix ++ not working" // Terminal
34: assert
35: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: dupval // postfix expression temp
   Stack: &0 | 0 | 
12: clvr 2 // postfix expression temp
   Stack: &0 | 0 | 
13: store 2
   Stack: &0 | 
14: inc // prefix inc/dec
   Stack: 1 | 
15: pop // postfix expression temp erg
   Stack: 
16: load 2
   Stack: 0 | 
17: loadref 1 // j
   Stack: 0 | &0 | 
18: assign
   Stack: 0 | 
19: pop // discarge expression result for ExprStatement
   Stack: 
20: loadref 0 // i
   Stack: &1 | 
21: dec // prefix inc/dec
   Stack: 0 | 
22: pop // discarge expression result for ExprStatement
   Stack: 
23: load 1 // j
   Stack: 0 | 
24: push 0 // Terminal
   Stack: 0 | 0 | 
25: eq
   Stack: true | 
26: dup // safe lh expr result
   Stack: true | true | 
27: brfalse logexprend2 // bool short-circuit
   Stack: true | 
28: pop // remove lh expr result
   Stack: 
29: load 0 // i
   Stack: 0 | 
30: push 0 // Terminal
   Stack: 0 | 0 | 
31: eq
   Stack: true | 
32: logexprend2: nop // 
   Stack: true | 
33: push "Postfix ++ not working" // Terminal
   Stack: true | Postfix ++ not working | 
34: assert
   Stack: true | 
35: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="AritmExpr_Test.multiply">AritmExpr_Test.multiply</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][AritmExpr_Test.incDec] End Test
[AUNIT:STRT][AritmExpr_Test.multiply] Start Test
Parsed: [__assert((2 * 3) == 6 , "multiply not working");
__assert((6 / 2) == 3 , "divide not working");
__assert((7 % 2) == 1, "modulo not working");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 2
                    '*'
                    Literal:
                      : 3
                  '=='
                  Literal:
                    : 6
              Argument:
                Literal:
                  : multiply not working
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 6
                    '/'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : divide not working
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  MultiplicativeExpr:
                    Literal:
                      : 7
                    '%'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : modulo not working
mul
eq
assert
pop // discarge expression result for ExprStatement
div
eq
assert
pop // discarge expression result for ExprStatement
mod
eq
assert
pop // discarge expression result for ExprStatement
0: push 2 // Terminal
1: push 3 // Terminal
2: mul
3: push 6 // Terminal
4: eq
5: push "multiply not working" // Terminal
6: assert
7: pop // discarge expression result for ExprStatement
8: push 6 // Terminal
9: push 2 // Terminal
10: div
11: push 3 // Terminal
12: eq
13: push "divide not working" // Terminal
14: assert
15: pop // discarge expression result for ExprStatement
16: push 7 // Terminal
17: push 2 // Terminal
18: mod
19: push 1 // Terminal
20: eq
21: push "modulo not working" // Terminal
22: assert
23: pop // discarge expression result for ExprStatement
   Stack: 
0: push 2 // Terminal
   Stack: 2 | 
1: push 3 // Terminal
   Stack: 2 | 3 | 
2: mul
   Stack: 6 | 
3: push 6 // Terminal
   Stack: 6 | 6 | 
4: eq
   Stack: true | 
5: push "multiply not working" // Terminal
   Stack: true | multiply not working | 
6: assert
   Stack: true | 
7: pop // discarge expression result for ExprStatement
   Stack: 
8: push 6 // Terminal
   Stack: 6 | 
9: push 2 // Terminal
   Stack: 6 | 2 | 
10: div
   Stack: 3.000000 | 
11: push 3 // Terminal
   Stack: 3.000000 | 3 | 
12: eq
   Stack: true | 
13: push "divide not working" // Terminal
   Stack: true | divide not working | 
14: assert
   Stack: true | 
15: pop // discarge expression result for ExprStatement
   Stack: 
16: push 7 // Terminal
   Stack: 7 | 
17: push 2 // Terminal
   Stack: 7 | 2 | 
18: mod
   Stack: 1 | 
19: push 1 // Terminal
   Stack: 1 | 1 | 
20: eq
   Stack: true | 
21: push "modulo not working" // Terminal
   Stack: true | modulo not working | 
22: assert
   Stack: true | 
23: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Arrays_Test.basicArrays">Arrays_Test.basicArrays</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][AritmExpr_Test.multiply] End Test
[AUNIT:STRT][Arrays_Test.basicArrays] Start Test
Parsed: [int[] ia = new int[](2);
ia[0] = 42;
ia[1] = 43;
__assert(ia[0] == 42, "basic Arrays failed");
__assert(ia[1] == 43, "basic Arrays failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        ia
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            ia
          ArraySubscribeExpr:
            Literal:
              : 0
        '='
        Literal:
          : 42
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            ia
          ArraySubscribeExpr:
            Literal:
              : 1
        '='
        Literal:
          : 43
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 0
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : basic Arrays failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 1
                  '=='
                  Literal:
                    : 43
              Argument:
                Literal:
                  : basic Arrays failed
Create Var ia at idx: 0
clvr 0 // ia
push Nil // initialize local value
store 0 // initialize local value
push "int" // array element class name
push 1103806595072 // dmi flags = 0, argcount = 1
newarr
loadref 0 // ia
assign
pop // discarge expression result for ExprStatement
loadref 0 // ia
ldarelref // array element access
assign
pop // discarge expression result for ExprStatement
loadref 0 // ia
ldarelref // array element access
assign
pop // discarge expression result for ExprStatement
load 0 // ia
ldarel // array element access
eq
assert
pop // discarge expression result for ExprStatement
load 0 // ia
ldarel // array element access
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // ia
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: push "int" // array element class name
5: push 1103806595072 // dmi flags = 0, argcount = 1
6: newarr
7: loadref 0 // ia
8: assign
9: pop // discarge expression result for ExprStatement
10: push 42 // Terminal
11: loadref 0 // ia
12: push 0 // Terminal
13: ldarelref // array element access
14: assign
15: pop // discarge expression result for ExprStatement
16: push 43 // Terminal
17: loadref 0 // ia
18: push 1 // Terminal
19: ldarelref // array element access
20: assign
21: pop // discarge expression result for ExprStatement
22: load 0 // ia
23: push 0 // Terminal
24: ldarel // array element access
25: push 42 // Terminal
26: eq
27: push "basic Arrays failed" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: load 0 // ia
31: push 1 // Terminal
32: ldarel // array element access
33: push 43 // Terminal
34: eq
35: push "basic Arrays failed" // Terminal
36: assert
37: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // ia
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: push "int" // array element class name
   Stack: 2 | int | 
5: push 1103806595072 // dmi flags = 0, argcount = 1
   Stack: 2 | int | 1103806595072 | 
6: newarr
   Stack: [0, 0] | 
7: loadref 0 // ia
   Stack: [0, 0] | &Nil | 
8: assign
   Stack: [0, 0] | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: push 42 // Terminal
   Stack: 42 | 
11: loadref 0 // ia
   Stack: 42 | &[0, 0] | 
12: push 0 // Terminal
   Stack: 42 | &[0, 0] | 0 | 
13: ldarelref // array element access
   Stack: 42 | &0 | 
14: assign
   Stack: 42 | 
15: pop // discarge expression result for ExprStatement
   Stack: 
16: push 43 // Terminal
   Stack: 43 | 
17: loadref 0 // ia
   Stack: 43 | &[42, 0] | 
18: push 1 // Terminal
   Stack: 43 | &[42, 0] | 1 | 
19: ldarelref // array element access
   Stack: 43 | &0 | 
20: assign
   Stack: 43 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: load 0 // ia
   Stack: [42, 43] | 
23: push 0 // Terminal
   Stack: [42, 43] | 0 | 
24: ldarel // array element access
   Stack: 42 | 
25: push 42 // Terminal
   Stack: 42 | 42 | 
26: eq
   Stack: true | 
27: push "basic Arrays failed" // Terminal
   Stack: true | basic Arrays failed | 
28: assert
   Stack: true | 
29: pop // discarge expression result for ExprStatement
   Stack: 
30: load 0 // ia
   Stack: [42, 43] | 
31: push 1 // Terminal
   Stack: [42, 43] | 1 | 
32: ldarel // array element access
   Stack: 43 | 
33: push 43 // Terminal
   Stack: 43 | 43 | 
34: eq
   Stack: true | 
35: push "basic Arrays failed" // Terminal
   Stack: true | basic Arrays failed | 
36: assert
   Stack: true | 
37: pop // discarge expression result for ExprStatement
Parsed: [int[] ia = new int[](2);
__assert(ia.length() == 2, "basic Arrays length failed");
__assert(ia[0] == 0, "basic Arrays default field initialization failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        ia
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          length
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : basic Arrays length failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      ia
                    ArraySubscribeExpr:
                      Literal:
                        : 0
                  '=='
                  Literal:
                    : 0
              Argument:
                Literal:
                  : basic Arrays default field initialization failed
Create Var ia at idx: 0
clvr 0 // ia
push Nil // initialize local value
store 0 // initialize local value
push "int" // array element class name
push 1103806595072 // dmi flags = 0, argcount = 1
newarr
loadref 0 // ia
assign
pop // discarge expression result for ExprStatement
load 0 // ia
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 62464505 // function name: length
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
eq
assert
pop // discarge expression result for ExprStatement
load 0 // ia
ldarel // array element access
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // ia
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: push "int" // array element class name
5: push 1103806595072 // dmi flags = 0, argcount = 1
6: newarr
7: loadref 0 // ia
8: assign
9: pop // discarge expression result for ExprStatement
10: load 0 // ia
11: clvr 1 // ClassName or object instance
12: store 1
13: load 1 // ClassName or object instance
14: push 62464505 // function name: length
15: push 67108880 // dmi flags = PUBLIC, argcount = 0
16: hash_invoke
17: push 2 // Terminal
18: eq
19: push "basic Arrays length failed" // Terminal
20: assert
21: pop // discarge expression result for ExprStatement
22: load 0 // ia
23: push 0 // Terminal
24: ldarel // array element access
25: push 0 // Terminal
26: eq
27: push "basic Arrays default field initialization failed" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // ia
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: push "int" // array element class name
   Stack: 2 | int | 
5: push 1103806595072 // dmi flags = 0, argcount = 1
   Stack: 2 | int | 1103806595072 | 
6: newarr
   Stack: [0, 0] | 
7: loadref 0 // ia
   Stack: [0, 0] | &Nil | 
8: assign
   Stack: [0, 0] | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: load 0 // ia
   Stack: [0, 0] | 
11: clvr 1 // ClassName or object instance
   Stack: [0, 0] | 
12: store 1
   Stack: 
13: load 1 // ClassName or object instance
   Stack: [0, 0] | 
14: push 62464505 // function name: length
   Stack: [0, 0] | 62464505 | 
15: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: [0, 0] | 62464505 | 67108880 | 
16: hash_invoke
   Stack: 2 | 
17: push 2 // Terminal
   Stack: 2 | 2 | 
18: eq
   Stack: true | 
19: push "basic Arrays length failed" // Terminal
   Stack: true | basic Arrays length failed | 
20: assert
   Stack: true | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: load 0 // ia
   Stack: [0, 0] | 
23: push 0 // Terminal
   Stack: [0, 0] | 0 | 
24: ldarel // array element access
   Stack: 0 | 
25: push 0 // Terminal
   Stack: 0 | 0 | 
26: eq
   Stack: true | 
27: push "basic Arrays default field initialization failed" // Terminal
   Stack: true | basic Arrays default field initialization failed | 
28: assert
   Stack: true | 
29: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Arrays_Test.objectArrays">Arrays_Test.objectArrays</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Arrays_Test.basicArrays] End Test
[AUNIT:STRT][Arrays_Test.objectArrays] Start Test
Parsed: [] to
CodeText:
 SymbolTable: [
 ]
</pre>
<h2><a id="Basics_Test.standard">Basics_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Arrays_Test.objectArrays] End Test
[AUNIT:STRT][Basics_Test.standard] Start Test
</pre>
<h2><a id="Basics_Test.syntax">Basics_Test.syntax</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.standard] End Test
[AUNIT:STRT][Basics_Test.syntax] Start Test
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'CKeyWord'
test:
  'AKeyWord'
test:
  'AKeyWord'
  'BKeyWord'
test:
  'AKeyWord'
  'CKeyWord'
FLOATING_POINT_LITERAL
: ([0-9])+\.([0-9])+
;

ThrowStatement
: 'throw'& [ Expression ] ';'& $
;

LogicalOROp
: '||'
;

EqualsExpr
: RelationalExpr [ EqualsOp EqualsExpr ] %
;

ReturnStatement
: 'return'& [ Expression ]';'& $
;

SubscribeExpr
: PrimaryExpr ( ArraySubscribeExpr | MemberSubscribeExpr | FuncSubscribeExpr  )* %
;

ClassDeclMember
: ClassMemberAttr FqTypeName VarName ( ';'& | VarInitializer ';'& ) $
;

AdditiveOp
: '+' | '-'
;

PostfixExpr
: SubscribeExpr [ PostfixOp ] % [ PostfixExpr ] 
;

AssignmentOp
: '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='
;

EvalBlock
: '['& CodeText ']'& $
;

AdditiveExpr
: MultiplicativeExpr [ AdditiveOp AdditiveExpr ]  %
;

ElseStatement
: 'else'& ! Statement $
;

Argument
: [ Label ':'& ] Expression $
;

CXX_COMMENT
: 
;

ForStatement
: 'for'& ! '('& ( EmptyStatement| VarDecl | ExprStatement ) ( Expression | EmptyExpression) ';'& ( Expression | EmptyExpression ) ')'& Statement $ 
;

Variable
: Identifier $
;

MethodName
: IDENTIFIER $
;

CatchBlock
: 'catch'& '('& FqTypeName VarName ')'& Statement $
;

DerivedSuperDef
: 'extends'& ! FqTypeName $
;

PrimaryExpr
: '('& Expression ')'& | 'operator'&  Operator | VarName | Literal
;

PostfixOp
: '++' | '--' $
;

ConditionalExpr
: LogicalORExpr [ '?'& AssignmentExpr ':'& AssignmentExpr ] %
;

ShiftOp
: '>>' | '>>>' | '<<'
;

Statements
: ( Statement )*
;

HEX_LITERAL
: 0[xX][0-9a-fA-F]+[LISB]?
;

Expression
: AssignmentExpr
;

ArrayDims
: ( ArrayDim )* %
;

SIGNED_DEC_LITERAL
: ([\+\-])?([0-9])+[LISB]?
;

EqualsOp
: '===' | '!=='
;

TryCatchStatement
: 'try'& Statement ( CatchBlock )* [ FinallyBlock ] $
;

ClassDeclConstructorInitializerList
:  [ ':'& ClassDeclConstructorInitializer ( ','& ClassDeclConstructorInitializer )* ] $
;

FqTypeName
: TypeName ( '.'& FqTypeName )* ArrayDims  $
;

C_COMMENT
: 
;

LogicalANDExpr
: BitwiseORExpr [ LogicalANDOp  LogicalANDExpr ] %
;

LVarDecl
: FqTypeName VarName ( ';'& | VarInitializer ';'& ) $
;

Literal
: ( BOOLEAN_LITERAL | STRING_LITERAL | HEX_LITERAL | FLOATING_POINT_LITERAL  | OCTAL_LITERAL | SIGNED_DEC_LITERAL ) %
;

InterfaceDeclDef
: 'interface'& ! TypeName (InterfaceDef | ';'&) $
;

NewArrayArguments
: ( NewArrayArgument )+ $
;

BOOLEAN_LITERAL
: 'true' $ | 'false' $ | 'nil' $
;

ExtendStatement
: 'extend' ClassMemberAttr ReturnType FqTypeName FunctionParamsDecl FunctionBlock $
;

DEC_LITERAL
: ([0-9])+[LISB]?
;

OPERATOR
: 
;

ClassDeclElement
: ClassDeclMember | ClassDeclMethod | ClassDeclConstructor | ClassDeclOperator
;

ClosureExpr
: 'new'& ClosureArguments ClassDef $
;

FuncSubscribeExpr
: Arguments $
;

PrefixExpr
: NewExpr | ClosureExpr | [ PrefixOp ] % PostfixExpr
;

EmptyStatement
: ';'& $ 
;

MultiplicativeExpr
: CastExpr [ MultiplicativeOp MultiplicativeExpr ] %
;

GotoStatement
: 'goto'& Label ';'& $ 
;

DerivedDef
: [ DerivedSuperDef ] [ DerivedInterfaceDef ] $
;

InterfaceDef
: InterfaceDerivedDef ClassDeclBody
;

ClassMemberAttr
: ( 'public' | 'protected' | 'private' | 'foreign' | 'static' )* %
;

ArraySubscribeExpr
: '['& Expression ']'& $
;

Operator
: ( '+' | '-' | '*' | '/' | '.' | '<<=' | '>>=' | '<<' | '>>' | ',' | '!' | '~' | '==' | '=' | '+=' | '-=' | '<' | '>' | '<=' | '>=' | '==' | '!=' | '[' ']' | '(' ')' | OPERATOR) $
;

AssignmentExpr
: ConditionalExpr [ AssignmentOp AssignmentExpr ] %
;

Identifier
: IDENTIFIER $
;

DoStatement
: 'do'& ! Statement 'while'& '('& Expression ')'& ';'& $ 
;

test
: 'AKeyWord' ( 'BKeyWord' | 'CKeyWord' ) 'DKeyWord'
;

SwitchStatement
: 'switch'& '('& Expression ')'& '{'& ( CaseClause )* '}'& $ 
;

ClosureArgumentList
: VarName ( ','& VarName )* %
;

BreakStatement
: 'break' ';'& $
;

FunctionParamsDecl
: '('& ')'& $ |  '('& Parameter ( ','& Parameter )* ')'& $
;

EqualityOp
: '==' | '!='
;

InterfaceDerivedDef
: [ DerivedInterfaceDef ] $
;

ClassDeclConstructor
: ClassMemberAttr MethodName FunctionParamsDecl ClassDeclConstructorInitializerList  ( ';' | FunctionBlock ) $
;

FunctionDeclDef
: ClassDeclMethod $
;

UsingDecl
: 'using'& FqTypeName ';'& $
;

ClassDeclMethod
: ClassMemberAttr ReturnType MethodName  FunctionParamsDecl !  ( ';' | FunctionBlock ) $ 
;

VarInitializer
: '='& ( AssignmentExpr | ConditionalExpr ) $
;

OCTAL_LITERAL
: 0[0-7]+
;

EmptyExpression
:  $
;

BaseExpr
: AssignmentExpr 
;

LeftHandVariable
: Identifier $
;

STRING_LITERAL
: 
;

BitwiseXORExpr
: BitwiseANDExpr [ BitwiseXOROp BitwiseXORExpr ] %
;

NewExpr
: 'new'& FqTypeName ( Arguments ) $
;

BitwiseOROp
: '|'
;

FunctionBlock
: Block $
;

ClassDeclBody
: '{'& ( ClassDeclElement )* '}'& 
;

ReturnType
: FqTypeName $
;

LogicalANDOp
: '&&'
;

ArgumentList
: Argument ( ','& Argument )* %
;

EqualityExpr
: EqualsExpr [ EqualityOp EqualityExpr ] %
;

ClassDef
: DerivedDef ClassDeclBody
;

LogicalORExpr
: LogicalANDExpr [ LogicalOROp  LogicalORExpr ] %
;

ExprStatement
: Expression ';'& $
;

IfStatement
: 'if'& ! '('& Expression ')'& Statement [ ElseStatement ]  $
;

VarDecl
: LVarDecl
;

Arguments
: '('& ')'& $ | '('& ArgumentList ')'& $
;

MemberSubscribeExpr
: MemberSubscribeOp SubscribeExpr $
;

ClassDeclDef
: 'class'& ! TypeName (ClassDef | ';'&) $
;

CaseClause
: ( 'case' Expression | 'default' ) ':'& ( Statement )* $
;

DefunDecl
: 'defun'& TypeName ClassMemberAttr ReturnType FunctionParamsDecl ';'& $
;

ClassDeclOperator
: ClassMemberAttr ReturnType 'operator'&  Operator FunctionParamsDecl !  ( ';' | FunctionBlock ) $ 
;

RelationalOp
: '<' | '>' | '<=' | '>='
;

WhileStatement
: 'while'& '('& Expression ')'& Statement $ 
;

Block
: '{'& Statements '}'& $
;

BitwiseANDOp
: '&'
;

TypeName
: IDENTIFIER $
;

CastExpr
: '('& FqTypeName ')'&  CastExpr $ | PrefixExpr
;

MultiplicativeOp
: '*' | '%' | '/' 
;

ArrayDim
: '['& ']'& $
;

NewArrayArgument
: '['& [ Expression ] ']'& $
;

Label
: IDENTIFIER $
;

DerivedInterfaceDef
: 'implements'& ! FqTypeName ( ','& FqTypeName )* $
;

LabeledStatement
: Label ':'& [ Statement ] $ 
;

NamespaceDecl
: 'namespace'& TypeName '{'& Statements '}'& $
;

CodeText
: Statements
;

ShiftExpr
: AdditiveExpr [ ShiftOp ShiftExpr ] %
;

VarName
: IDENTIFIER $
;

RelationalExpr
: ShiftExpr [ RelationalOp RelationalExpr ] %
;

FinallyBlock
: 'finally'& Statement $
;

BitwiseANDExpr
: EqualityExpr [ BitwiseANDOp BitwiseANDExpr ] %
;

ContinueStatement
: 'continue' ';'& $
;

IDENTIFIER
: [a-zA-Z_][a-zA-Z_0-9]*
;

ClosureArguments
: '('& ')'& $ | '('& ClosureArgumentList ')'&  $
;

TypeDecl
: ClassDeclDef | InterfaceDeclDef | FunctionDeclDef
;

Statement
: EvalBlock 
 |Block 
 |ReturnStatement 
 |IfStatement 
 |ContinueStatement 
 |BreakStatement 
 |DoStatement 
 |WhileStatement 
 |ForStatement 
 |GotoStatement 
 |ThrowStatement 
 |TryCatchStatement 
 |LabeledStatement
 |SwitchStatement 
 |DefunDecl 
 | ExtendStatement
 |VarDecl 
 | TypeDecl 
 | NamespaceDecl 
 | UsingDecl 
 | ExprStatement 
 |EmptyStatement
;

Parameter
: FqTypeName VarName $
;

MemberSubscribeOp
: '.' | '->'
;

ClassDeclConstructorInitializer
: FqTypeName Arguments $
;

PrefixOp
: '++' | '--' | '-' | '+' | '~' | '!'
;

BitwiseXOROp
: '^'
;

BitwiseORExpr
: BitwiseXORExpr [ BitwiseOROp BitwiseORExpr ] %
;

test:
  'AKeyWord'
  'CKeyWord'
  'DKeyWord'
test:
  'param'
  ','
  'param'
test:
  'param'
  ','
  'param'
  ','
  'param'
test:
  'A'
test:
  'A'
  'B'
test:
  'A'
  'B'
  'B'
test:
  mlt:
    'a'
  '+'
  mlt:
    'b'
    '*'
    'c'
  '+'
  mlt:
    zahl:
      'd'
</pre>
<h2><a id="Basics_Test.expressions">Basics_Test.expressions</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.syntax] End Test
[AUNIT:STRT][Basics_Test.expressions] Start Test
Parsed: [ a + b]
Expression:
  AdditiveExpr:
    VarName:
      a
    '+'
    VarName:
      b
Parsed: [a == b]
Expression:
  EqualityExpr:
    VarName:
      a
    '=='
    VarName:
      b
Parsed: [a != b]
Expression:
  EqualityExpr:
    VarName:
      a
    '!='
    VarName:
      b
Parsed: [a == b ? a : b]
Expression:
  ConditionalExpr:
    EqualityExpr:
      VarName:
        a
      '=='
      VarName:
        b
    VarName:
      a
    VarName:
      b
Parsed: [a==b?a:b]
Expression:
  ConditionalExpr:
    EqualityExpr:
      VarName:
        a
      '=='
      VarName:
        b
    VarName:
      a
    VarName:
      b
Parsed: [acdk.lang.Object]
FqTypeName:
  
</pre>
<h2><a id="Basics_Test.statements">Basics_Test.statements</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.expressions] End Test
[AUNIT:STRT][Basics_Test.statements] Start Test
Parsed: [a;]
Statement:
  ExprStatement:
    VarName:
      a
Parsed: [b = a;]
Statement:
  ExprStatement:
    AssignmentExpr:
      VarName:
        b
      '='
      VarName:
        a
Parsed: [b + a;]
Statement:
  ExprStatement:
    AdditiveExpr:
      VarName:
        b
      '+'
      VarName:
        a
Parsed: [j = k + 1;]
Statement:
  ExprStatement:
    AssignmentExpr:
      VarName:
        j
      '='
      AdditiveExpr:
        VarName:
          k
        '+'
        Literal:
          : 1
Parsed: [int i = 0; i = i + 1;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        AdditiveExpr:
          VarName:
            i
          '+'
          Literal:
            : 1
</pre>
<h2><a id="Basics_Test.functionDecl">Basics_Test.functionDecl</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.statements] End Test
[AUNIT:STRT][Basics_Test.functionDecl] Start Test
Parsed: [int foo(int i, int j)
{
  return i + j;
}
void bar() { }
]
CodeText:
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
          Parameter:
            FqTypeName:
              
            VarName:
              j
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  VarName:
                    j
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          bar
        FunctionParamsDecl:
        FunctionBlock:
          Block:
</pre>
<h2><a id="Basics_Test.CondAndLoops">Basics_Test.CondAndLoops</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.functionDecl] End Test
[AUNIT:STRT][Basics_Test.CondAndLoops] Start Test
Parsed: [if (true) i = 3;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            i
          '='
          Literal:
            : 3
Parsed: [if (true) { }]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
Parsed: [if (true) { a = i; b = x; }]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                a
              '='
              VarName:
                i
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                b
              '='
              VarName:
                x
Parsed: [if (true) { } else x = 4;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
    ElseStatement:
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              x
            '='
            Literal:
              : 4
Parsed: [if (true) { } else if (false) x = 4;]
Statement:
  IfStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
    ElseStatement:
      Statement:
        IfStatement:
          Literal:
            BOOLEAN_LITERAL:
              'false'
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  x
                '='
                Literal:
                  : 4
Parsed: [while (true) x = 1;]
Statement:
  WhileStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            x
          '='
          Literal:
            : 1
Parsed: [while (true) {}]
Statement:
  WhileStatement:
    Literal:
      BOOLEAN_LITERAL:
        'true'
    Statement:
      Block:
Parsed: [do x = 1; while (true);]
Statement:
  DoStatement:
    Statement:
      ExprStatement:
        AssignmentExpr:
          VarName:
            x
          '='
          Literal:
            : 1
    Literal:
      BOOLEAN_LITERAL:
        'true'
Parsed: [do { } while (true);]
Statement:
  DoStatement:
    Statement:
      Block:
    Literal:
      BOOLEAN_LITERAL:
        'true'
Parsed: [switch(x) { case a : case b: x = 1; break; default: break; }]
Statement:
  SwitchStatement:
    VarName:
      x
    CaseClause:
      'case'
      VarName:
        a
    CaseClause:
      'case'
      VarName:
        b
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              x
            '='
            Literal:
              : 1
      Statement:
        BreakStatement:
          'break'
    CaseClause:
      'default'
      Statement:
        BreakStatement:
          'break'
</pre>
<h2><a id="Basics_Test.objectDecls">Basics_Test.objectDecls</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.CondAndLoops] End Test
[AUNIT:STRT][Basics_Test.objectDecls] Start Test
Parsed: [class AClass { }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
Parsed: [class AClass { int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMember:
        FqTypeName:
          
        VarName:
          ival
Parsed: [class AClass { void foo() { } }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
Parsed: [class AClass { public void foo() { } static int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
      ClassDeclMember:
        ClassMemberAttr:
          'static'
        FqTypeName:
          
        VarName:
          ival
Parsed: [class AClass { void foo(int i) { } int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
      ClassDeclMember:
        FqTypeName:
          
        VarName:
          ival
Parsed: [class AClass { void foo(int i) { ival = i; } int ival; }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
      ClassDeclMember:
        FqTypeName:
          
        VarName:
          ival
Parsed: [class AClass { int ival; void foo(int i) { ival = i; }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMember:
        FqTypeName:
          
        VarName:
          ival
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
Parsed: [class AClass { AClass(int i) { ival = i; }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                AssignmentExpr:
                  VarName:
                    ival
                  '='
                  VarName:
                    i
Parsed: [class AClass { AClass(int i) : ival(i) { }  }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
Parsed: [class AClass extends acdk.lang.Object { }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
</pre>
<h2><a id="Basics_Test.objectCalls">Basics_Test.objectCalls</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.objectDecls] End Test
[AUNIT:STRT][Basics_Test.objectCalls] Start Test
Parsed: [o = new Object();]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          o
        '='
        NewExpr:
          FqTypeName:
            
          Arguments:
Parsed: [acdk.lang.Object s;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
Parsed: [acdk.lang.Object s = a;]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        VarName:
          a
Parsed: [acdk.lang.Object s = new Object();]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
Parsed: [acdk.lang.Object s = new acdk.lang.String(1);]
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 1
Parsed: [o.member = x;]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              member
        '='
        VarName:
          x
Parsed: [o1 = a2.m2;
o.foo(x);
o.foo(x)[i];
o.foo = x;
o.foo[i] = x;
o[i] = x;
o[i].bar = x;
o[i].foo() = x;
]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          o1
        '='
        SubscribeExpr:
          VarName:
            a2
          MemberSubscribeExpr:
            '.'
            VarName:
              m2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    x
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    x
            ArraySubscribeExpr:
              VarName:
                i
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              foo
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                foo
              ArraySubscribeExpr:
                VarName:
                  i
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
          MemberSubscribeExpr:
            '.'
            VarName:
              bar
        '='
        VarName:
          x
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          ArraySubscribeExpr:
            VarName:
              i
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                foo
              FuncSubscribeExpr:
                Arguments:
        '='
        VarName:
          x
Parsed: [(o).toString();
(i + 1).toString();
]
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              toString
            FuncSubscribeExpr:
              Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        AdditiveExpr:
          VarName:
            i
          '+'
          Literal:
            : 1
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              toString
            FuncSubscribeExpr:
              Arguments:
Parsed: [(((foo(i)[j].bar + 1)(v) + 2).bar + 4)[x];
]
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        AdditiveExpr:
          SubscribeExpr:
            AdditiveExpr:
              SubscribeExpr:
                AdditiveExpr:
                  SubscribeExpr:
                    VarName:
                      foo
                    FuncSubscribeExpr:
                      Arguments:
                        Argument:
                          VarName:
                            i
                    ArraySubscribeExpr:
                      VarName:
                        j
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        bar
                  '+'
                  Literal:
                    : 1
                FuncSubscribeExpr:
                  Arguments:
                    Argument:
                      VarName:
                        v
              '+'
              Literal:
                : 2
            MemberSubscribeExpr:
              '.'
              VarName:
                bar
          '+'
          Literal:
            : 4
        ArraySubscribeExpr:
          VarName:
            x
Parsed: [s = (new acdk.lang.Object()).toString();]
CodeText:
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          NewExpr:
            FqTypeName:
              
            Arguments:
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
</pre>
<h2><a id="Basics_Test.objectOperator">Basics_Test.objectOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.objectCalls] End Test
[AUNIT:STRT][Basics_Test.objectOperator] Start Test
Parsed: [class AClass { String operator+(String s) { return "AClass"; } }]
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclOperator:
        ReturnType:
          FqTypeName:
            
        Operator:
          +
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              s
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : AClass
Parsed: [a + 42;]
CodeText:
  Statement:
    ExprStatement:
      AdditiveExpr:
        VarName:
          a
        '+'
        Literal:
          : 42
</pre>
<h2><a id="Basics_Test.experimental">Basics_Test.experimental</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.objectOperator] End Test
[AUNIT:STRT][Basics_Test.experimental] Start Test
</pre>
<h2><a id="BinaryExpr_Test.basicRels">BinaryExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Basics_Test.experimental] End Test
[AUNIT:STRT][BinaryExpr_Test.basicRels] Start Test
Parsed: [__assert(1 & 3, "binary and does not work");
__assert((1 | 2) == 3, "binary or does not work");
__assert((3 ^ 2) == 1, "binary xor does not work");
__assert((1 << 2) == 4, "binary left shift does not work");
__assert((4 >> 2) == 1, "binary right shift does not work");
__assert((-4 >> 2) == -1, "binary right shift on neg values does not work");
int i = -4;
__assert((i >>> 2) == 1073741823, "binary right unsigned shift does not work");
i = 42;
__assert(~i == -43, "binary not does not work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                BitwiseANDExpr:
                  Literal:
                    : 1
                  '&'
                  Literal:
                    : 3
              Argument:
                Literal:
                  : binary and does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  BitwiseORExpr:
                    Literal:
                      : 1
                    '|'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : binary or does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  BitwiseXORExpr:
                    Literal:
                      : 3
                    '^'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : binary xor does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : 1
                    '<<'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : binary left shift does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : 4
                    '>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : binary right shift does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    Literal:
                      : -4
                    '>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : -1
              Argument:
                Literal:
                  : binary right shift on neg values does not work
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : -4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ShiftExpr:
                    VarName:
                      i
                    '>>>'
                    Literal:
                      : 2
                  '=='
                  Literal:
                    : 1073741823
              Argument:
                Literal:
                  : binary right unsigned shift does not work
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        Literal:
          : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  PrefixExpr:
                    '~'
                    VarName:
                      i
                  '=='
                  Literal:
                    : -43
              Argument:
                Literal:
                  : binary not does not work
Create Var i at idx: 0
band // binary op: &
assert
pop // discarge expression result for ExprStatement
bor // binary op: |
eq
assert
pop // discarge expression result for ExprStatement
bxor // binary op: ^
eq
assert
pop // discarge expression result for ExprStatement
bshl // binary op: <<
eq
assert
pop // discarge expression result for ExprStatement
bshr // binary op: >>
eq
assert
pop // discarge expression result for ExprStatement
bshr // binary op: >>
eq
assert
pop // discarge expression result for ExprStatement
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
bshrus // binary op: >>>
eq
assert
pop // discarge expression result for ExprStatement
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
loadref 0 // i
bnot // negation
eq
assert
pop // discarge expression result for ExprStatement
0: push 1 // Terminal
1: push 3 // Terminal
2: band // binary op: &
3: push "binary and does not work" // Terminal
4: assert
5: pop // discarge expression result for ExprStatement
6: push 1 // Terminal
7: push 2 // Terminal
8: bor // binary op: |
9: push 3 // Terminal
10: eq
11: push "binary or does not work" // Terminal
12: assert
13: pop // discarge expression result for ExprStatement
14: push 3 // Terminal
15: push 2 // Terminal
16: bxor // binary op: ^
17: push 1 // Terminal
18: eq
19: push "binary xor does not work" // Terminal
20: assert
21: pop // discarge expression result for ExprStatement
22: push 1 // Terminal
23: push 2 // Terminal
24: bshl // binary op: <<
25: push 4 // Terminal
26: eq
27: push "binary left shift does not work" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: push 4 // Terminal
31: push 2 // Terminal
32: bshr // binary op: >>
33: push 1 // Terminal
34: eq
35: push "binary right shift does not work" // Terminal
36: assert
37: pop // discarge expression result for ExprStatement
38: push -4 // Terminal
39: push 2 // Terminal
40: bshr // binary op: >>
41: push -1 // Terminal
42: eq
43: push "binary right shift on neg values does not work" // Terminal
44: assert
45: pop // discarge expression result for ExprStatement
46: clvr 0 // i
47: push 0 // initialize local value
48: store 0 // initialize local value
49: push -4 // Terminal
50: loadref 0 // i
51: assign
52: pop // discarge expression result for ExprStatement
53: load 0 // i
54: push 2 // Terminal
55: bshrus // binary op: >>>
56: push 1073741823 // Terminal
57: eq
58: push "binary right unsigned shift does not work" // Terminal
59: assert
60: pop // discarge expression result for ExprStatement
61: push 42 // Terminal
62: loadref 0 // i
63: assign
64: pop // discarge expression result for ExprStatement
65: loadref 0 // i
66: bnot // negation
67: push -43 // Terminal
68: eq
69: push "binary not does not work" // Terminal
70: assert
71: pop // discarge expression result for ExprStatement
   Stack: 
0: push 1 // Terminal
   Stack: 1 | 
1: push 3 // Terminal
   Stack: 1 | 3 | 
2: band // binary op: &
   Stack: 1 | 
3: push "binary and does not work" // Terminal
   Stack: 1 | binary and does not work | 
4: assert
   Stack: true | 
5: pop // discarge expression result for ExprStatement
   Stack: 
6: push 1 // Terminal
   Stack: 1 | 
7: push 2 // Terminal
   Stack: 1 | 2 | 
8: bor // binary op: |
   Stack: 3 | 
9: push 3 // Terminal
   Stack: 3 | 3 | 
10: eq
   Stack: true | 
11: push "binary or does not work" // Terminal
   Stack: true | binary or does not work | 
12: assert
   Stack: true | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 3 // Terminal
   Stack: 3 | 
15: push 2 // Terminal
   Stack: 3 | 2 | 
16: bxor // binary op: ^
   Stack: 1 | 
17: push 1 // Terminal
   Stack: 1 | 1 | 
18: eq
   Stack: true | 
19: push "binary xor does not work" // Terminal
   Stack: true | binary xor does not work | 
20: assert
   Stack: true | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: push 1 // Terminal
   Stack: 1 | 
23: push 2 // Terminal
   Stack: 1 | 2 | 
24: bshl // binary op: <<
   Stack: 4 | 
25: push 4 // Terminal
   Stack: 4 | 4 | 
26: eq
   Stack: true | 
27: push "binary left shift does not work" // Terminal
   Stack: true | binary left shift does not work | 
28: assert
   Stack: true | 
29: pop // discarge expression result for ExprStatement
   Stack: 
30: push 4 // Terminal
   Stack: 4 | 
31: push 2 // Terminal
   Stack: 4 | 2 | 
32: bshr // binary op: >>
   Stack: 1 | 
33: push 1 // Terminal
   Stack: 1 | 1 | 
34: eq
   Stack: true | 
35: push "binary right shift does not work" // Terminal
   Stack: true | binary right shift does not work | 
36: assert
   Stack: true | 
37: pop // discarge expression result for ExprStatement
   Stack: 
38: push -4 // Terminal
   Stack: -4 | 
39: push 2 // Terminal
   Stack: -4 | 2 | 
40: bshr // binary op: >>
   Stack: -1 | 
41: push -1 // Terminal
   Stack: -1 | -1 | 
42: eq
   Stack: true | 
43: push "binary right shift on neg values does not work" // Terminal
   Stack: true | binary right shift on neg values does not work | 
44: assert
   Stack: true | 
45: pop // discarge expression result for ExprStatement
   Stack: 
46: clvr 0 // i
   Stack: 
47: push 0 // initialize local value
   Stack: 0 | 
48: store 0 // initialize local value
   Stack: 
49: push -4 // Terminal
   Stack: -4 | 
50: loadref 0 // i
   Stack: -4 | &0 | 
51: assign
   Stack: -4 | 
52: pop // discarge expression result for ExprStatement
   Stack: 
53: load 0 // i
   Stack: -4 | 
54: push 2 // Terminal
   Stack: -4 | 2 | 
55: bshrus // binary op: >>>
   Stack: 1073741823 | 
56: push 1073741823 // Terminal
   Stack: 1073741823 | 1073741823 | 
57: eq
   Stack: true | 
58: push "binary right unsigned shift does not work" // Terminal
   Stack: true | binary right unsigned shift does not work | 
59: assert
   Stack: true | 
60: pop // discarge expression result for ExprStatement
   Stack: 
61: push 42 // Terminal
   Stack: 42 | 
62: loadref 0 // i
   Stack: 42 | &-4 | 
63: assign
   Stack: 42 | 
64: pop // discarge expression result for ExprStatement
   Stack: 
65: loadref 0 // i
   Stack: &42 | 
66: bnot // negation
   Stack: -43 | 
67: push -43 // Terminal
   Stack: -43 | -43 | 
68: eq
   Stack: true | 
69: push "binary not does not work" // Terminal
   Stack: true | binary not does not work | 
70: assert
   Stack: true | 
71: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Closure_Test.standard">Closure_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> EvalEnv::pop: Stack underflow<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::EvalEnv::pop (acdk_aal_d.dll)
  called in acdk::aal::AalObject::standardDispatch (acdk_aal_d.dll)
  called in acdk::aal::AalCompiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::Compiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::OpCodeStm::execute_inner (acdk_aal_d.dll)
  called in acdk::aci::Executable::execute (acdk_aal_d.dll)
  called in acdk::aci::EvalEnv::execute (acdk_aal_d.dll)
  called in acdk::aci::Compiler::execute (acdk_aal_d.dll)
  called in tests::acdk::aal::parseTreeInterpret (acdk_aal_Test_d.exe)
  called in tests::acdk::aal::Closure_Test::standard (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::Closure_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][BinaryExpr_Test.basicRels] End Test
[AUNIT:STRT][Closure_Test.standard] Start Test
Parsed: [interface IFace { public int foo(); }
int i = 42;
class AClass implements IFace { int i; public AClass(int i_) : i(i_) {} public int foo() { return i; } }
IFace acls = new AClass(i);
IFace iface = new (i) implements IFace { public int foo() { return i + 1; } };
iface.foo();
] to
CodeText:
  Statement:
    InterfaceDeclDef:
      TypeName:
        IFace
      InterfaceDerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        ';'
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 42
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
          FqTypeName:
            
      ClassDeclMember:
        FqTypeName:
          
        VarName:
          i
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i_
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i_
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                VarName:
                  i
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        acls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              VarName:
                i
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        iface
      VarInitializer:
        ClosureExpr:
          ClosureArguments:
            VarName:
              i
          DerivedDef:
            DerivedInterfaceDef:
              FqTypeName:
                
          ClassDeclMethod:
            ClassMemberAttr:
              'public'
            ReturnType:
              FqTypeName:
                
            MethodName:
              foo
            FunctionParamsDecl:
            FunctionBlock:
              Block:
                Statement:
                  ReturnStatement:
                    AdditiveExpr:
                      VarName:
                        i
                      '+'
                      Literal:
                        : 1
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          iface
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
Create Var this at idx: 0
IFace this
Create Var this at idx: 0
IFace this
Create Var i at idx: 0
Create Var i_ at idx: 0
int i_
Create Var this at idx: 0
AClass this
int i_
Create Var this at idx: 0
AClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i_
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
Create Var acls at idx: 1
Create Var iface at idx: 2
Create Var i_ at idx: 0
int i_
Create Var this at idx: 0
Closure1 this
int i_
Create Var this at idx: 0
Closure1 this
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i_
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
CodeText:
 SymbolTable: [
  int i
  IFace acls
  IFace iface
 ]
  Statement:
    InterfaceDeclDef:(IFace=IFace)
     SymbolTable: [
      IFace this
     ]
      TypeName:
        IFace
      InterfaceDerivedDef:
      ClassDeclMethod:Sem=[foo=int]
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          IFace this
         ]
        ';'
      ClassDeclConstructor:Sem=[IFace=void]
        ClassMemberAttr:
          'public'
        MethodName:
          IFace
        FunctionParamsDecl:
         SymbolTable: [
          IFace this
         ]
        ClassDeclConstructorInitializerList:(IFace=IFace)
         SymbolTable: [
          IFace this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            IFace this
           ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 42
  Statement:
    ClassDeclDef:(AClass=AClass)
     SymbolTable: [
      AClass this
     ]
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
         SymbolTable: [
         ]
          FqTypeName:
            
      ClassDeclMember:Sem=[i=int]
        FqTypeName:
          
        VarName:
          i
      ClassDeclConstructor:Sem=[AClass=void]
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
          int i_
         ]
          Parameter:Sem=[i_=int]
            FqTypeName:
              
            VarName:
              i_
        ClassDeclConstructorInitializerList:(AClass=AClass)
         SymbolTable: [
          AClass this
          int i_
         ]
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[IFace=void]
              
            Arguments:
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[i=int]
              
            Arguments:
              Argument:Sem=[i_=int]
                VarName:Sem=[i_=int] ExprSem=[i_=int]
                  i_
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
            int i_
           ]
      ClassDeclMethod:Sem=[foo=int]
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
            Statement:
              ReturnStatement:
                SubscribeExpr:Sem=[i=int] ExprSem=[i=int]
                  VarName:Sem=[this=AClass] ExprSem=[this=AClass]
                    this
                  MemberSubscribeExpr:Sem=[i=int] ExprSem=[i=int]
                    '.'
                    VarName:Sem=[i=int] ExprSem=[i=int]
                      i
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        acls
      ExprStatement:
        AssignmentExpr:Sem=[acls=IFace] ExprSem=[acls=IFace]
          VarName:Sem=[acls=IFace] ExprSem=[acls=IFace]
            acls
          '='
          NewExpr:Sem=[AClass=AClass]
            FqTypeName:
              
            Arguments:
              Argument:Sem=[i=int]
                VarName:Sem=[i=int] ExprSem=[i=int]
                  i
  Statements:
    ClassDeclDef:(Closure1=Closure1)
     SymbolTable: [
      Closure1 this
     ]
      TypeName:
        Closure1
      DerivedDef:
        DerivedInterfaceDef:
         SymbolTable: [
         ]
          FqTypeName:
            
      ClassDeclMember:Sem=[i=int]
        ClassMemberAttr:
        FqTypeName:
          
        VarName:
          i
      ClassDeclConstructor:Sem=[Closure1=void]
        ClassMemberAttr:
          'public'
        MethodName:
          Closure1
        FunctionParamsDecl:
         SymbolTable: [
          Closure1 this
          int i_
         ]
          Parameter:Sem=[i_=int]
            FqTypeName:
              
            VarName:
              i_
        ClassDeclConstructorInitializerList:(Closure1=Closure1)
         SymbolTable: [
          Closure1 this
          int i_
         ]
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[IFace=void]
              
            Arguments:
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[i=int]
              
            Arguments:
              Argument:Sem=[i_=int]
                VarName:Sem=[i_=int] ExprSem=[i_=int]
                  i_
        FunctionBlock:
          Block:
           SymbolTable: [
            Closure1 this
            int i_
           ]
            Statements:
      ClassDeclMethod:Sem=[foo=int]
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          Closure1 this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            Closure1 this
           ]
            Statement:
              ReturnStatement:
                AdditiveExpr:Sem=[byte=byte]
                  SubscribeExpr:Sem=[i=int] ExprSem=[i=int]
                    VarName:Sem=[this=Closure1] ExprSem=[this=Closure1]
                      this
                    MemberSubscribeExpr:Sem=[i=int] ExprSem=[i=int]
                      '.'
                      VarName:Sem=[i=int] ExprSem=[i=int]
                        i
                  '+'
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 1
    Statement:
      LVarDecl:
        FqTypeName:
          
        VarName:
          iface
        ExprStatement:
          AssignmentExpr:Sem=[iface=IFace] ExprSem=[iface=IFace]
            VarName:Sem=[iface=IFace] ExprSem=[iface=IFace]
              iface
            '='
            NewExpr:Sem=[Closure1=Closure1]
              FqTypeName:
                
              Arguments:
                Argument:Sem=[i=int]
                  VarName:Sem=[i=int] ExprSem=[i=int]
                    i
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[foo=int] ExprSem=[int=int]
        VarName:Sem=[iface=IFace] ExprSem=[iface=IFace]
          iface
        MemberSubscribeExpr:Sem=[foo=int] ExprSem=[int=int]
          '.'
          SubscribeExpr:Sem=[foo=int] ExprSem=[int=int]
            VarName:Sem=[foo=int] ExprSem=[foo=int]
              foo
            FuncSubscribeExpr:Sem=[foo=int] ExprSem=[int=int]
              Arguments:
Function foo[
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function IFace[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "IFace" // class name to initialize
init_clazz // 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // this
push "IFace" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 1 // i_
load 0 // this
push "i" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
load 0 // this
push "IFace" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 1 // i_
load 0 // this
push "i" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 0 // this
push "i" // fieldname
push 0 // dmi flags
peek
ret  // return statement
Function foo[
__method_start: nop // 
load 0 // this
push "i" // fieldname
push 0 // dmi flags
peek
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
clvr 1 // acls
push Nil // initialize local value
store 1 // initialize local value
load 0 // i
push "AClass" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 1 // acls
assign
pop // discarge expression result for ExprStatement
load 0 // this
push "IFace" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 1 // i_
load 0 // this
push "i" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function Closure1[
load 0 // this
push "IFace" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 1 // i_
load 0 // this
push "i" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 0 // this
push "i" // fieldname
push 0 // dmi flags
peek
add
ret  // return statement
Function foo[
__method_start: nop // 
load 0 // this
push "i" // fieldname
push 0 // dmi flags
peek
push 1 // Terminal
add
ret  // return statement
]
push "Closure1" // class name to initialize
init_clazz // 
clvr 2 // iface
push Nil // initialize local value
store 2 // initialize local value
load 0 // i
push "Closure1" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 2 // iface
assign
pop // discarge expression result for ExprStatement
load 2 // iface
Create Var __tvar1 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 3148825 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
pop // discarge expression result for ExprStatement
0: push "IFace" // class name to initialize
1: init_clazz // 
2: clvr 0 // i
3: push 0 // initialize local value
4: store 0 // initialize local value
5: push 42 // Terminal
6: loadref 0 // i
7: assign
8: pop // discarge expression result for ExprStatement
9: push "AClass" // class name to initialize
10: init_clazz // 
11: clvr 1 // acls
12: push Nil // initialize local value
13: store 1 // initialize local value
14: load 0 // i
15: push "AClass" // class name
16: push 4294967296 // dmi flags = 0, argcount = 1
17: new
18: loadref 1 // acls
19: assign
20: pop // discarge expression result for ExprStatement
21: push "Closure1" // class name to initialize
22: init_clazz // 
23: clvr 2 // iface
24: push Nil // initialize local value
25: store 2 // initialize local value
26: load 0 // i
27: push "Closure1" // class name
28: push 4294967296 // dmi flags = 0, argcount = 1
29: new
30: loadref 2 // iface
31: assign
32: pop // discarge expression result for ExprStatement
33: load 2 // iface
34: clvr 3 // ClassName or object instance
35: store 3
36: load 3 // ClassName or object instance
37: push 3148825 // function name: _0_foo
38: push 67108880 // dmi flags = PUBLIC, argcount = 0
39: hash_invoke
40: pop // discarge expression result for ExprStatement
   Stack: 
0: push "IFace" // class name to initialize
   Stack: IFace | 
1: init_clazz // 
   Stack: 
2: clvr 0 // i
   Stack: 
3: push 0 // initialize local value
   Stack: 0 | 
4: store 0 // initialize local value
   Stack: 
5: push 42 // Terminal
   Stack: 42 | 
6: loadref 0 // i
   Stack: 42 | &0 | 
7: assign
   Stack: 42 | 
8: pop // discarge expression result for ExprStatement
   Stack: 
9: push "AClass" // class name to initialize
   Stack: AClass | 
10: init_clazz // 
   Stack: 
11: clvr 1 // acls
   Stack: 
12: push Nil // initialize local value
   Stack: Nil | 
13: store 1 // initialize local value
   Stack: 
14: load 0 // i
   Stack: 42 | 
15: push "AClass" // class name
   Stack: 42 | AClass | 
16: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | AClass | 4294967296 | 
17: new
   Stack: 
0: load 0 // this
   Stack: AClass | 
1: push "IFace" // function name
   Stack: AClass | IFace | 
2: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: AClass | IFace | 2097216 | 
3: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
4: pop // remove invoke result
   Stack: 
5: load 1 // i_
   Stack: 42 | 
6: load 0 // this
   Stack: 42 | AClass | 
7: push "i" // fieldname
   Stack: 42 | AClass | i | 
8: push 0 // dmi flags
   Stack: 42 | AClass | i | 0 | 
9: poke
   Stack: 42 | 
10: pop // remove poke result
   Stack: 
11: __method_start: nop // 
   Stack: 
12: push <undefined> // void return
   Stack: Nil | 
13: ret  // 
   Stack: AClass | 
18: loadref 1 // acls
   Stack: AClass | &Nil | 
19: assign
   Stack: AClass | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: push "Closure1" // class name to initialize
   Stack: Closure1 | 
22: init_clazz // 
   Stack: 
23: clvr 2 // iface
   Stack: 
24: push Nil // initialize local value
   Stack: Nil | 
25: store 2 // initialize local value
   Stack: 
26: load 0 // i
   Stack: 42 | 
27: push "Closure1" // class name
   Stack: 42 | Closure1 | 
28: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | Closure1 | 4294967296 | 
29: new
   Stack: 
0: load 0 // this
   Stack: Closure1 | 
1: push "IFace" // function name
   Stack: Closure1 | IFace | 
2: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: Closure1 | IFace | 2097216 | 
3: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
4: pop // remove invoke result
   Stack: 
5: load 1 // i_
   Stack: 42 | 
6: load 0 // this
   Stack: 42 | Closure1 | 
7: push "i" // fieldname
   Stack: 42 | Closure1 | i | 
8: push 0 // dmi flags
   Stack: 42 | Closure1 | i | 0 | 
9: poke
   Stack: 42 | 
10: pop // remove poke result
   Stack: 
11: __method_start: nop // 
   Stack: 
12: push <undefined> // void return
   Stack: Nil | 
13: ret  // 
   Stack: Closure1 | 
30: loadref 2 // iface
   Stack: Closure1 | &Nil | 
31: assign
   Stack: Closure1 | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: load 2 // iface
   Stack: Closure1 | 
34: clvr 3 // ClassName or object instance
   Stack: Closure1 | 
35: store 3
   Stack: 
36: load 3 // ClassName or object instance
   Stack: Closure1 | 
37: push 3148825 // function name: _0_foo
   Stack: Closure1 | 3148825 | 
38: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: Closure1 | 3148825 | 67108880 | 
39: hash_invoke
[AUNIT:ERRR][Closure_Test.standard] Error in Test: Closure_Test.standard: EvalEnv::pop: Stack underflow
</pre>
<h2><a id="Compiler_Test.standard">Compiler_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Closure_Test.standard] End Test
[AUNIT:STRT][Compiler_Test.standard] Start Test
Test:
  ARule:
    'A'
</pre>
<h2><a id="Compiler_Test.grammar">Compiler_Test.grammar</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Compiler_Test.standard] End Test
[AUNIT:STRT][Compiler_Test.grammar] Start Test
DRule:
  ' '
  'C'
</pre>
<h2><a id="Compiler_Test.errors">Compiler_Test.errors</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Compiler_Test.grammar] End Test
[AUNIT:STRT][Compiler_Test.errors] Start Test
Expected Ex: cannot find matching terminal: 'AX'
</pre>
<h2><a id="DefunStatements_Test.standard">DefunStatements_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Method not found: public:  AClass::1555235382(...)<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::lang::RuntimeException::RuntimeException (acdk_core_d.dll)
  called in acdk::lang::DmiException::DmiException (acdk_core_d.dll)
  called in acdk::lang::NoSuchDmiElementException::NoSuchDmiElementException (acdk_core_d.dll)
  called in acdk::lang::NoSuchMethodException::NoSuchMethodException (acdk_core_d.dll)
  called in acdk::lang::dmi::throwMethodNotFound (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::_lookupMethod (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::lookupMethod (acdk_core_d.dll)
  called in acdk::aal::AalObject::standardDispatch (acdk_aal_d.dll)
  called in acdk::aal::AalCompiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::Compiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::OpCodeStm::execute_inner (acdk_aal_d.dll)
  called in acdk::aci::Executable::execute (acdk_aal_d.dll)
  called in acdk::aci::EvalEnv::execute (acdk_aal_d.dll)
  called in acdk::aci::Compiler::execute (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::DefunStatements_Test::standard (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::DefunStatements_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Compiler_Test.errors] End Test
[AUNIT:STRT][DefunStatements_Test.standard] Start Test
Parsed: [defun Incrementator static int (int value);
class AClass { public int adder(int value) { return value + 1; } }
AClass acls = new AClass();
Incrementator inc = acls.adder;
inc(41);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    DefunDecl:
      TypeName:
        Incrementator
      ClassMemberAttr:
        'static'
      ReturnType:
        FqTypeName:
          
      FunctionParamsDecl:
        Parameter:
          FqTypeName:
            
          VarName:
            value
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          adder
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              value
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    value
                  '+'
                  Literal:
                    : 1
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        acls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        inc
      VarInitializer:
        SubscribeExpr:
          VarName:
            acls
          MemberSubscribeExpr:
            '.'
            VarName:
              adder
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          inc
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 41
Create Var value at idx: 0
int value
Create Var value at idx: 0
int value
Create Var this at idx: 0
AClass this
int value
Create Var this at idx: 0
AClass this
Create Var acls at idx: 0
Create Var inc at idx: 1
Subtext: [ class AClass_method_caller1
 implements Incrementator
{
  private AClass _calltarget;
  public AClass_method_caller1(AClass calltarget) : _calltarget(calltarget) {}
  public  int operator_po_pc(int value){ return _calltarget.adder(value); }
}

]

Create Var calltarget at idx: 0
AClass calltarget
Create Var this at idx: 0
AClass_method_caller1 this
AClass calltarget
Create Var value at idx: 0
int value
Create Var this at idx: 0
AClass_method_caller1 this
int value
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        calltarget
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
Code already postParsed: Argument: 
__method_start: nop // 
load 1 // value
add
ret  // return statement
Function adder[
__method_start: nop // 
load 1 // value
push 1 // Terminal
add
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // acls
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // acls
assign
pop // discarge expression result for ExprStatement
clvr 1 // inc
push Nil // initialize local value
store 1 // initialize local value
load 0 // acls
loadref 1 // inc
assign
pop // discarge expression result for ExprStatement
load 1 // inc
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1555235382 // function name: operator_po_pc
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // acls
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // acls
9: assign
10: pop // discarge expression result for ExprStatement
11: clvr 1 // inc
12: push Nil // initialize local value
13: store 1 // initialize local value
14: load 0 // acls
15: loadref 1 // inc
16: assign
17: pop // discarge expression result for ExprStatement
18: load 1 // inc
19: clvr 2 // ClassName or object instance
20: store 2
21: push 41 // Terminal
22: load 2 // ClassName or object instance
23: push 1555235382 // function name: operator_po_pc
24: push 4362076176 // dmi flags = PUBLIC, argcount = 1
25: hash_invoke
26: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // acls
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // acls
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: clvr 1 // inc
   Stack: 
12: push Nil // initialize local value
   Stack: Nil | 
13: store 1 // initialize local value
   Stack: 
14: load 0 // acls
   Stack: AClass | 
15: loadref 1 // inc
   Stack: AClass | &Nil | 
16: assign
   Stack: AClass | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: load 1 // inc
   Stack: AClass | 
19: clvr 2 // ClassName or object instance
   Stack: AClass | 
20: store 2
   Stack: 
21: push 41 // Terminal
   Stack: 41 | 
22: load 2 // ClassName or object instance
   Stack: 41 | AClass | 
23: push 1555235382 // function name: operator_po_pc
   Stack: 41 | AClass | 1555235382 | 
24: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 41 | AClass | 1555235382 | 4362076176 | 
25: hash_invoke
[AUNIT:ERRR][DefunStatements_Test.standard] Error in Test: DefunStatements_Test.standard: Method not found: public:  AClass::1555235382(...)
</pre>
<h2><a id="DeriveObject_Test.deriveAalObject">DeriveObject_Test.deriveAalObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Method not found: public:  ::acdk::lang::String::3148794(...)<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::lang::RuntimeException::RuntimeException (acdk_core_d.dll)
  called in acdk::lang::DmiException::DmiException (acdk_core_d.dll)
  called in acdk::lang::NoSuchDmiElementException::NoSuchDmiElementException (acdk_core_d.dll)
  called in acdk::lang::NoSuchMethodException::NoSuchMethodException (acdk_core_d.dll)
  called in acdk::lang::dmi::throwMethodNotFound (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::_lookupMethod (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::lookupMethod (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::_invoke_dynamic (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::standardDispatch (acdk_core_d.dll)
  called in acdk::aci::Compiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aal::AalCompiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::Compiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::OpCodeStm::execute_inner (acdk_aal_d.dll)
  called in acdk::aci::Executable::execute (acdk_aal_d.dll)
  called in acdk::aci::EvalEnv::execute (acdk_aal_d.dll)
  called in acdk::aal::AalObject::executeFunctionCall (acdk_aal_d.dll)
  called in acdk::aal::AalObject::standardDispatch (acdk_aal_d.dll)
  called in acdk::aal::AalCompiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::Compiler::compInvokeHashMethod (acdk_aal_d.dll)
  called in acdk::aci::OpCodeStm::execute_inner (acdk_aal_d.dll)
  called in acdk::aci::Executable::execute (acdk_aal_d.dll)
  called in acdk::aci::EvalEnv::execute (acdk_aal_d.dll)
  called in acdk::aci::Compiler::execute (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::DeriveObject_Test::deriveAalObject (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::DeriveObject_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][DefunStatements_Test.standard] End Test
[AUNIT:STRT][DeriveObject_Test.deriveAalObject] Start Test
Parsed: [using acdk.lang;
class BaseClass { public int _ivar; public BaseClass(int i) : _ivar(i) {} }
class ExtClass extends BaseClass { public ExtClass(int i) : BaseClass(i) {} } 
ExtClass extcls = new ExtClass(42);
__assert(extcls._ivar == 42, "Base Aal class Contructor initialization failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
        FqTypeName:
          
        VarName:
          _ivar
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    ClassDeclDef:
      TypeName:
        ExtClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          ExtClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        extcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      extcls
                    MemberSubscribeExpr:
                      '.'
                      VarName:
                        _ivar
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : Base Aal class Contructor initialization failed
Create Var i at idx: 0
int i
Create Var this at idx: 0
BaseClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i
Create Var i at idx: 0
int i
Create Var this at idx: 0
ExtClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i
Create Var extcls at idx: 0
load 1 // i
load 0 // this
push "_ivar" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
load 1 // i
load 0 // this
push "_ivar" // fieldname
push 0 // dmi flags
poke
pop // remove poke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
load 1 // i
load 0 // this
push "BaseClass" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function ExtClass[
load 1 // i
load 0 // this
push "BaseClass" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "ExtClass" // class name to initialize
init_clazz // 
clvr 0 // extcls
push Nil // initialize local value
store 0 // initialize local value
push "ExtClass" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // extcls
assign
pop // discarge expression result for ExprStatement
load 0 // extcls
push "_ivar" // fieldname
push 0 // dmi flags
peek
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: push "ExtClass" // class name to initialize
3: init_clazz // 
4: clvr 0 // extcls
5: push Nil // initialize local value
6: store 0 // initialize local value
7: push 42 // Terminal
8: push "ExtClass" // class name
9: push 4294967296 // dmi flags = 0, argcount = 1
10: new
11: loadref 0 // extcls
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // extcls
15: push "_ivar" // fieldname
16: push 0 // dmi flags
17: peek
18: push 42 // Terminal
19: eq
20: push "Base Aal class Contructor initialization failed" // Terminal
21: assert
22: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
2: push "ExtClass" // class name to initialize
   Stack: ExtClass | 
3: init_clazz // 
   Stack: 
4: clvr 0 // extcls
   Stack: 
5: push Nil // initialize local value
   Stack: Nil | 
6: store 0 // initialize local value
   Stack: 
7: push 42 // Terminal
   Stack: 42 | 
8: push "ExtClass" // class name
   Stack: 42 | ExtClass | 
9: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | ExtClass | 4294967296 | 
10: new
   Stack: 
0: load 1 // i
   Stack: 42 | 
1: load 0 // this
   Stack: 42 | ExtClass | 
2: push "BaseClass" // function name
   Stack: 42 | ExtClass | BaseClass | 
3: push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
   Stack: 42 | ExtClass | BaseClass | 4297064512 | 
4: invoke
   Stack: 
0: load 1 // i
   Stack: 42 | 
1: load 0 // this
   Stack: 42 | ExtClass | 
2: push "_ivar" // fieldname
   Stack: 42 | ExtClass | _ivar | 
3: push 0 // dmi flags
   Stack: 42 | ExtClass | _ivar | 0 | 
4: poke
   Stack: 42 | 
5: pop // remove poke result
   Stack: 
6: __method_start: nop // 
   Stack: 
7: push <undefined> // void return
   Stack: Nil | 
8: ret  // 
   Stack: Nil | 
5: pop // remove invoke result
   Stack: 
6: __method_start: nop // 
   Stack: 
7: push <undefined> // void return
   Stack: Nil | 
8: ret  // 
   Stack: ExtClass | 
11: loadref 0 // extcls
   Stack: ExtClass | &Nil | 
12: assign
   Stack: ExtClass | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // extcls
   Stack: ExtClass | 
15: push "_ivar" // fieldname
   Stack: ExtClass | _ivar | 
16: push 0 // dmi flags
   Stack: ExtClass | _ivar | 0 | 
17: peek
   Stack: 42 | 
18: push 42 // Terminal
   Stack: 42 | 42 | 
19: eq
   Stack: true | 
20: push "Base Aal class Contructor initialization failed" // Terminal
   Stack: true | Base Aal class Contructor initialization failed | 
21: assert
   Stack: true | 
22: pop // discarge expression result for ExprStatement
Parsed: [using acdk.lang;
class BaseClass { public int foo() { return 42; } }
class ExtClass extends BaseClass { public int foo() { return ((BaseClass)this).foo(); } } 
ExtClass extcls = new ExtClass();
__assert(extcls.foo() == 42, "Base Aal super method invocation failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : 42
  Statement:
    ClassDeclDef:
      TypeName:
        ExtClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                SubscribeExpr:
                  CastExpr:
                    FqTypeName:
                      
                    VarName:
                      this
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        foo
                      FuncSubscribeExpr:
                        Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        extcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      extcls
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          foo
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : Base Aal super method invocation failed
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
ExtClass this
Create Var this at idx: 0
ExtClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
Create Var extcls at idx: 0
__method_start: nop // 
ret  // return statement
Function foo[
__method_start: nop // 
push 42 // Terminal
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
__method_start: nop // 
load 0 // this
push "BaseClass" // class name to cast to
classcast // 
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
Function foo[
__method_start: nop // 
load 0 // this
push "BaseClass" // class name to cast to
classcast // 
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
]
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function ExtClass[
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "ExtClass" // class name to initialize
init_clazz // 
clvr 0 // extcls
push Nil // initialize local value
store 0 // initialize local value
push "ExtClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // extcls
assign
pop // discarge expression result for ExprStatement
load 0 // extcls
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: push "ExtClass" // class name to initialize
3: init_clazz // 
4: clvr 0 // extcls
5: push Nil // initialize local value
6: store 0 // initialize local value
7: push "ExtClass" // class name
8: push 0 // dmi flags = 0, argcount = 0
9: new
10: loadref 0 // extcls
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // extcls
14: clvr 1 // ClassName or object instance
15: store 1
16: load 1 // ClassName or object instance
17: push 3148794 // function name: _0_foo
18: push 67108880 // dmi flags = PUBLIC, argcount = 0
19: hash_invoke
20: push 42 // Terminal
21: eq
22: push "Base Aal super method invocation failed" // Terminal
23: assert
24: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
2: push "ExtClass" // class name to initialize
   Stack: ExtClass | 
3: init_clazz // 
   Stack: 
4: clvr 0 // extcls
   Stack: 
5: push Nil // initialize local value
   Stack: Nil | 
6: store 0 // initialize local value
   Stack: 
7: push "ExtClass" // class name
   Stack: ExtClass | 
8: push 0 // dmi flags = 0, argcount = 0
   Stack: ExtClass | 0 | 
9: new
   Stack: 
0: load 0 // this
   Stack: ExtClass | 
1: push "BaseClass" // function name
   Stack: ExtClass | BaseClass | 
2: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: ExtClass | BaseClass | 2097216 | 
3: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
4: pop // remove invoke result
   Stack: 
5: load 0 // this
   Stack: ExtClass | 
6: push "BaseClass" // function name
   Stack: ExtClass | BaseClass | 
7: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: ExtClass | BaseClass | 2097216 | 
8: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
9: pop // remove invoke result
   Stack: 
10: __method_start: nop // 
   Stack: 
11: push <undefined> // void return
   Stack: Nil | 
12: ret  // 
   Stack: ExtClass | 
10: loadref 0 // extcls
   Stack: ExtClass | &Nil | 
11: assign
   Stack: ExtClass | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // extcls
   Stack: ExtClass | 
14: clvr 1 // ClassName or object instance
   Stack: ExtClass | 
15: store 1
   Stack: 
16: load 1 // ClassName or object instance
   Stack: ExtClass | 
17: push 3148794 // function name: _0_foo
   Stack: ExtClass | 3148794 | 
18: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: ExtClass | 3148794 | 67108880 | 
19: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 0 // this
   Stack: ExtClass | 
2: push "BaseClass" // class name to cast to
   Stack: ExtClass | BaseClass | 
3: classcast // 
   Stack: acdk/lang/Object | 
4: clvr 1 // ClassName or object instance
   Stack: acdk/lang/Object | 
5: store 1
   Stack: 
6: load 1 // ClassName or object instance
   Stack: acdk/lang/Object | 
7: push 3148794 // function name: _0_foo
   Stack: acdk/lang/Object | 3148794 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/Object | 3148794 | 67108880 | 
9: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: ret  // return statement
   Stack: 42 | 
10: ret  // return statement
   Stack: 42 | 
20: push 42 // Terminal
   Stack: 42 | 42 | 
21: eq
   Stack: true | 
22: push "Base Aal super method invocation failed" // Terminal
   Stack: true | Base Aal super method invocation failed | 
23: assert
   Stack: true | 
24: pop // discarge expression result for ExprStatement
Parsed: [using acdk.lang;
class BaseClass { public int foo() { return 42; } }
class ExtClass extends BaseClass {
  public int bar() { return ((BaseClass)this).foo(); }
  public int foo() { return BaseClass.foo(); }
} 
ExtClass extcls = new ExtClass();
__assert(extcls.foo() == 42, "Base Aal super method invocation failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : 42
  Statement:
    ClassDeclDef:
      TypeName:
        ExtClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          bar
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                SubscribeExpr:
                  CastExpr:
                    FqTypeName:
                      
                    VarName:
                      this
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        foo
                      FuncSubscribeExpr:
                        Arguments:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                SubscribeExpr:
                  VarName:
                    BaseClass
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        foo
                      FuncSubscribeExpr:
                        Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        extcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      extcls
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          foo
                        FuncSubscribeExpr:
                          Arguments:
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : Base Aal super method invocation failed
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
BaseClass this
Create Var this at idx: 0
ExtClass this
Create Var this at idx: 0
ExtClass this
Create Var this at idx: 0
ExtClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
Create Var extcls at idx: 0
__method_start: nop // 
ret  // return statement
Function foo[
__method_start: nop // 
push 42 // Terminal
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function BaseClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "BaseClass" // class name to initialize
init_clazz // 
__method_start: nop // 
load 0 // this
push "BaseClass" // class name to cast to
classcast // 
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
Function bar[
__method_start: nop // 
load 0 // this
push "BaseClass" // class name to cast to
classcast // 
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
]
__method_start: nop // 
push "BaseClass" // class name
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
Function foo[
__method_start: nop // 
push "BaseClass" // class name
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _0_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
ret  // return statement
]
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function ExtClass[
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "BaseClass" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "ExtClass" // class name to initialize
init_clazz // 
clvr 0 // extcls
push Nil // initialize local value
store 0 // initialize local value
push "ExtClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // extcls
assign
pop // discarge expression result for ExprStatement
load 0 // extcls
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 3148794 // function name: _1_foo
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
eq
assert
pop // discarge expression result for ExprStatement
0: push "BaseClass" // class name to initialize
1: init_clazz // 
2: push "ExtClass" // class name to initialize
3: init_clazz // 
4: clvr 0 // extcls
5: push Nil // initialize local value
6: store 0 // initialize local value
7: push "ExtClass" // class name
8: push 0 // dmi flags = 0, argcount = 0
9: new
10: loadref 0 // extcls
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // extcls
14: clvr 1 // ClassName or object instance
15: store 1
16: load 1 // ClassName or object instance
17: push 3148794 // function name: _1_foo
18: push 67108880 // dmi flags = PUBLIC, argcount = 0
19: hash_invoke
20: push 42 // Terminal
21: eq
22: push "Base Aal super method invocation failed" // Terminal
23: assert
24: pop // discarge expression result for ExprStatement
   Stack: 
0: push "BaseClass" // class name to initialize
   Stack: BaseClass | 
1: init_clazz // 
   Stack: 
2: push "ExtClass" // class name to initialize
   Stack: ExtClass | 
3: init_clazz // 
   Stack: 
4: clvr 0 // extcls
   Stack: 
5: push Nil // initialize local value
   Stack: Nil | 
6: store 0 // initialize local value
   Stack: 
7: push "ExtClass" // class name
   Stack: ExtClass | 
8: push 0 // dmi flags = 0, argcount = 0
   Stack: ExtClass | 0 | 
9: new
   Stack: 
0: load 0 // this
   Stack: ExtClass | 
1: push "BaseClass" // function name
   Stack: ExtClass | BaseClass | 
2: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: ExtClass | BaseClass | 2097216 | 
3: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
4: pop // remove invoke result
   Stack: 
5: load 0 // this
   Stack: ExtClass | 
6: push "BaseClass" // function name
   Stack: ExtClass | BaseClass | 
7: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: ExtClass | BaseClass | 2097216 | 
8: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
9: pop // remove invoke result
   Stack: 
10: __method_start: nop // 
   Stack: 
11: push <undefined> // void return
   Stack: Nil | 
12: ret  // 
   Stack: ExtClass | 
10: loadref 0 // extcls
   Stack: ExtClass | &Nil | 
11: assign
   Stack: ExtClass | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // extcls
   Stack: ExtClass | 
14: clvr 1 // ClassName or object instance
   Stack: ExtClass | 
15: store 1
   Stack: 
16: load 1 // ClassName or object instance
   Stack: ExtClass | 
17: push 3148794 // function name: _1_foo
   Stack: ExtClass | 3148794 | 
18: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: ExtClass | 3148794 | 67108880 | 
19: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "BaseClass" // class name
   Stack: BaseClass | 
2: clvr 1 // ClassName or object instance
   Stack: BaseClass | 
3: store 1
   Stack: 
4: load 1 // ClassName or object instance
   Stack: BaseClass | 
5: push 3148794 // function name: _0_foo
   Stack: BaseClass | 3148794 | 
6: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: BaseClass | 3148794 | 67108880 | 
7: hash_invoke
[AUNIT:ERRR][DeriveObject_Test.deriveAalObject] Error in Test: DeriveObject_Test.deriveAalObject: Method not found: public:  ::acdk::lang::String::3148794(...)
</pre>
<h2><a id="DeriveObject_Test.deriveAcdkObject">DeriveObject_Test.deriveAcdkObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][DeriveObject_Test.deriveAalObject] End Test
[AUNIT:STRT][DeriveObject_Test.deriveAcdkObject] Start Test
Parsed: [using acdk.lang;
class ExtInteger extends acdk.lang.Integer { public ExtInteger(int i) : acdk.lang.Integer(i) {} } 
ExtInteger eint = new ExtInteger(42);
String s = eint.toString();
__assert(s.equals("42") == true, "calling super AcdkObject method failed");
s = ExtInteger.toString(42);
__assert(s.equals("42") == true, "calling super AcdkObject static method failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        ExtInteger
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          ExtInteger
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        eint
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          VarName:
            eint
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : calling super AcdkObject method failed
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            ExtInteger
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : calling super AcdkObject static method failed
Create Var i at idx: 0
int i
Create Var this at idx: 0
ExtInteger this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i
Create Var eint at idx: 0
Create Var s at idx: 1
load 1 // i
load 0 // this
push "Integer" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function ExtInteger[
load 1 // i
load 0 // this
push "Integer" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "ExtInteger" // class name to initialize
init_clazz // 
clvr 0 // eint
push Nil // initialize local value
store 0 // initialize local value
push "ExtInteger" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // eint
assign
pop // discarge expression result for ExprStatement
clvr 1 // s
push Nil // initialize local value
store 1 // initialize local value
load 0 // eint
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 749992755 // function name: _a_toString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
loadref 1 // s
assign
pop // discarge expression result for ExprStatement
load 1 // s
Create Var __tvar2 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
push true // true
eq
assert
pop // discarge expression result for ExprStatement
push "ExtInteger" // class name
Create Var __tvar3 at idx: 4
clvr 4 // ClassName or object instance
store 4
load 4 // ClassName or object instance
push 750097217 // function name: _c_toString
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke_static
loadref 1 // s
assign
pop // discarge expression result for ExprStatement
load 1 // s
Create Var __tvar4 at idx: 5
clvr 5 // ClassName or object instance
store 5
load 5 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
push true // true
eq
assert
pop // discarge expression result for ExprStatement
0: push "ExtInteger" // class name to initialize
1: init_clazz // 
2: clvr 0 // eint
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push 42 // Terminal
6: push "ExtInteger" // class name
7: push 4294967296 // dmi flags = 0, argcount = 1
8: new
9: loadref 0 // eint
10: assign
11: pop // discarge expression result for ExprStatement
12: clvr 1 // s
13: push Nil // initialize local value
14: store 1 // initialize local value
15: load 0 // eint
16: clvr 2 // ClassName or object instance
17: store 2
18: load 2 // ClassName or object instance
19: push 749992755 // function name: _a_toString
20: push 67108880 // dmi flags = PUBLIC, argcount = 0
21: hash_invoke
22: loadref 1 // s
23: assign
24: pop // discarge expression result for ExprStatement
25: load 1 // s
26: clvr 3 // ClassName or object instance
27: store 3
28: push "42" // Terminal
29: load 3 // ClassName or object instance
30: push 659573500 // function name: _u_equals
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
32: hash_invoke
33: push true // true
34: eq
35: push "calling super AcdkObject method failed" // Terminal
36: assert
37: pop // discarge expression result for ExprStatement
38: push "ExtInteger" // class name
39: clvr 4 // ClassName or object instance
40: store 4
41: push 42 // Terminal
42: load 4 // ClassName or object instance
43: push 750097217 // function name: _c_toString
44: push 4362076176 // dmi flags = PUBLIC, argcount = 1
45: hash_invoke_static
46: loadref 1 // s
47: assign
48: pop // discarge expression result for ExprStatement
49: load 1 // s
50: clvr 5 // ClassName or object instance
51: store 5
52: push "42" // Terminal
53: load 5 // ClassName or object instance
54: push 659573500 // function name: _u_equals
55: push 4362076176 // dmi flags = PUBLIC, argcount = 1
56: hash_invoke
57: push true // true
58: eq
59: push "calling super AcdkObject static method failed" // Terminal
60: assert
61: pop // discarge expression result for ExprStatement
   Stack: 
0: push "ExtInteger" // class name to initialize
   Stack: ExtInteger | 
1: init_clazz // 
   Stack: 
2: clvr 0 // eint
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push 42 // Terminal
   Stack: 42 | 
6: push "ExtInteger" // class name
   Stack: 42 | ExtInteger | 
7: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | ExtInteger | 4294967296 | 
8: new
   Stack: 
0: load 1 // i
   Stack: 42 | 
1: load 0 // this
   Stack: 42 | ExtInteger | 
2: push "Integer" // function name
   Stack: 42 | ExtInteger | Integer | 
3: push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
   Stack: 42 | ExtInteger | Integer | 4297064512 | 
4: invoke
   Stack: 42 | 
5: pop // remove invoke result
   Stack: 
6: __method_start: nop // 
   Stack: 
7: push <undefined> // void return
   Stack: Nil | 
8: ret  // 
   Stack: ExtInteger | 
9: loadref 0 // eint
   Stack: ExtInteger | &Nil | 
10: assign
   Stack: ExtInteger | 
11: pop // discarge expression result for ExprStatement
   Stack: 
12: clvr 1 // s
   Stack: 
13: push Nil // initialize local value
   Stack: Nil | 
14: store 1 // initialize local value
   Stack: 
15: load 0 // eint
   Stack: ExtInteger | 
16: clvr 2 // ClassName or object instance
   Stack: ExtInteger | 
17: store 2
   Stack: 
18: load 2 // ClassName or object instance
   Stack: ExtInteger | 
19: push 749992755 // function name: _a_toString
   Stack: ExtInteger | 749992755 | 
20: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: ExtInteger | 749992755 | 67108880 | 
21: hash_invoke
   Stack: 42 | 
22: loadref 1 // s
   Stack: 42 | &Nil | 
23: assign
   Stack: 42 | 
24: pop // discarge expression result for ExprStatement
   Stack: 
25: load 1 // s
   Stack: 42 | 
26: clvr 3 // ClassName or object instance
   Stack: 42 | 
27: store 3
   Stack: 
28: push "42" // Terminal
   Stack: 42 | 
29: load 3 // ClassName or object instance
   Stack: 42 | 42 | 
30: push 659573500 // function name: _u_equals
   Stack: 42 | 42 | 659573500 | 
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | 42 | 659573500 | 4362076176 | 
32: hash_invoke
   Stack: true | 
33: push true // true
   Stack: true | true | 
34: eq
   Stack: true | 
35: push "calling super AcdkObject method failed" // Terminal
   Stack: true | calling super AcdkObject method failed | 
36: assert
   Stack: true | 
37: pop // discarge expression result for ExprStatement
   Stack: 
38: push "ExtInteger" // class name
   Stack: ExtInteger | 
39: clvr 4 // ClassName or object instance
   Stack: ExtInteger | 
40: store 4
   Stack: 
41: push 42 // Terminal
   Stack: 42 | 
42: load 4 // ClassName or object instance
   Stack: 42 | ExtInteger | 
43: push 750097217 // function name: _c_toString
   Stack: 42 | ExtInteger | 750097217 | 
44: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | ExtInteger | 750097217 | 4362076176 | 
45: hash_invoke_static
   Stack: 42 | 
46: loadref 1 // s
   Stack: 42 | &42 | 
47: assign
   Stack: 42 | 
48: pop // discarge expression result for ExprStatement
   Stack: 
49: load 1 // s
   Stack: 42 | 
50: clvr 5 // ClassName or object instance
   Stack: 42 | 
51: store 5
   Stack: 
52: push "42" // Terminal
   Stack: 42 | 
53: load 5 // ClassName or object instance
   Stack: 42 | 42 | 
54: push 659573500 // function name: _u_equals
   Stack: 42 | 42 | 659573500 | 
55: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | 42 | 659573500 | 4362076176 | 
56: hash_invoke
   Stack: true | 
57: push true // true
   Stack: true | true | 
58: eq
   Stack: true | 
59: push "calling super AcdkObject static method failed" // Terminal
   Stack: true | calling super AcdkObject static method failed | 
60: assert
   Stack: true | 
61: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Exceptions_Test.basicThrow">Exceptions_Test.basicThrow</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][DeriveObject_Test.deriveAcdkObject] End Test
[AUNIT:STRT][Exceptions_Test.basicThrow] Start Test
Parsed: [using acdk.lang;
throw new Exception("asdf");

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ThrowStatement:
      NewExpr:
        FqTypeName:
          
        Arguments:
          Argument:
            Literal:
              : asdf
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
0: push "asdf" // Terminal
1: push "acdk.lang.Exception" // class name
2: push 4294967296 // dmi flags = 0, argcount = 1
3: new
4: throw // throws an exception
   Stack: 
0: push "asdf" // Terminal
   Stack: asdf | 
1: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
2: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
3: new
   Stack: acdk/lang/Exception | 
4: throw // throws an exception
</pre>
<h2><a id="Exceptions_Test.catchAalException">Exceptions_Test.catchAalException</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> asdf<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Throwable_MetainfoWrapper::Throwable_method_Throwable_INLRString__LRThrowable__dispatch (acdk_core_metainf_d.dll)
  called in acdk::lang::dmi::StdDispatch::_invoke_static (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::StandardDispatch (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::New (acdk_core_d.dll)
  called in acdk::lang::dmi::StdDispatch::New (acdk_core_d.dll)
  called in acdk::aci::Compiler::compNewObject (acdk_aal_d.dll)
  called in acdk::aci::Compiler::compNewObject (acdk_aal_d.dll)
  called in acdk::aci::OpCodeStm::execute_inner (acdk_aal_d.dll)
  called in acdk::aci::Executable::execute (acdk_aal_d.dll)
  called in acdk::aci::EvalEnv::execute (acdk_aal_d.dll)
  called in acdk::aci::Compiler::execute (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::Exceptions_Test::catchAalException (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::Exceptions_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Exceptions_Test.basicThrow] End Test
[AUNIT:STRT][Exceptions_Test.catchAalException] Start Test
Parsed: [using acdk.lang;
try {
  throw new Exception("asdf");
} catch (Exception ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ThrowStatement:
              NewExpr:
                FqTypeName:
                  
                Arguments:
                  Argument:
                    Literal:
                      : asdf
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var ex at idx: 0
try try1 // try label
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally2 // goto finally
try1: nop // 
dup // safe exception
push "acdk.lang.Exception" // exception name to test for catching
instanceof // 
brfalse finally2 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally2 // goto finally
finally2: nop // 
nop // 
0: try try1 // try label
1: push "asdf" // Terminal
2: push "acdk.lang.Exception" // class name
3: push 4294967296 // dmi flags = 0, argcount = 1
4: new
5: throw // throws an exception
6: br finally2 // goto finally
7: try1: nop // 
8: dup // safe exception
9: push "acdk.lang.Exception" // exception name to test for catching
10: instanceof // 
11: brfalse finally2 // goto next catch block
12: clvr 0 // ex
13: store 0
14: push "acdk.lang.System" // class name
15: push "out" // fieldname
16: push 0 // dmi flags
17: peek_static
18: clvr 1 // ClassName or object instance
19: store 1
20: load 0 // ex
21: clvr 2 // ClassName or object instance
22: store 2
23: load 2 // ClassName or object instance
24: push 1615806062 // function name: _3_getMessage
25: push 67108880 // dmi flags = PUBLIC, argcount = 0
26: hash_invoke
27: load 1 // ClassName or object instance
28: push 998516684 // function name: _t_println
29: push 4362076176 // dmi flags = PUBLIC, argcount = 1
30: hash_invoke
31: pop // discarge expression result for ExprStatement
32: catchend // clear exception
33: br finally2 // goto finally
34: finally2: nop // 
35: nop // 
   Stack: 
0: try try1 // try label
   Stack: 
1: push "asdf" // Terminal
   Stack: asdf | 
2: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
3: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
4: new
   Stack: acdk/lang/Exception | 
5: throw // throws an exception
   Stack: acdk/lang/Exception | 
8: dup // safe exception
   Stack: acdk/lang/Exception | acdk/lang/Exception | 
9: push "acdk.lang.Exception" // exception name to test for catching
   Stack: acdk/lang/Exception | acdk/lang/Exception | acdk.lang.Exception | 
10: instanceof // 
   Stack: acdk/lang/Exception | true | 
11: brfalse finally2 // goto next catch block
   Stack: acdk/lang/Exception | 
12: clvr 0 // ex
   Stack: acdk/lang/Exception | 
13: store 0
   Stack: 
14: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
15: push "out" // fieldname
   Stack: acdk.lang.System | out | 
16: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
17: peek_static
   Stack: acdk/io/PrintWriter | 
18: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
19: store 1
   Stack: 
20: load 0 // ex
   Stack: acdk/lang/Exception | 
21: clvr 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
22: store 2
   Stack: 
23: load 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
24: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/Exception | 1615806062 | 
25: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/Exception | 1615806062 | 67108880 | 
26: hash_invoke
   Stack: asdf | 
27: load 1 // ClassName or object instance
   Stack: asdf | acdk/io/PrintWriter | 
28: push 998516684 // function name: _t_println
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 
29: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 4362076176 | 
30: hash_invoke
asdf
   Stack: Nil | 
31: pop // discarge expression result for ExprStatement
   Stack: 
32: catchend // clear exception
   Stack: 
33: br finally2 // goto finally
   Stack: 
35: nop // 
Parsed: [using acdk.lang;
void throwEx() { throw new Exception("asdf"); }
try {
  throwEx();
} catch (Exception ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          throwEx
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ThrowStatement:
                NewExpr:
                  FqTypeName:
                    
                  Arguments:
                    Argument:
                      Literal:
                        : asdf
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  throwEx
                FuncSubscribeExpr:
                  Arguments:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:

after function:
ClassDeclDef:
  TypeName:
    throwEx
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
    FunctionBlock:
      Block:
        Statement:
          ThrowStatement:
            NewExpr:
              FqTypeName:
                
              Arguments:
                Argument:
                  Literal:
                    : asdf
Create Var this at idx: 0
throwEx this
Create Var ex at idx: 0
__method_start: nop // 
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
push <undefined> // void return
ret  // 
Function operator_po_pc[
__method_start: nop // 
push "asdf" // Terminal
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function throwEx[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "throwEx" // class name to initialize
init_clazz // 
try try4 // try label
push "throwEx" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555130951 // function name: _0_operator_po_pc
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
pop // discarge expression result for ExprStatement
br finally5 // goto finally
try4: nop // 
dup // safe exception
push "acdk.lang.Exception" // exception name to test for catching
instanceof // 
brfalse finally5 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally5 // goto finally
finally5: nop // 
nop // 
0: push "throwEx" // class name to initialize
1: init_clazz // 
2: try try4 // try label
3: push "throwEx" // class name
4: clvr 0 // ClassName or object instance
5: store 0
6: load 0 // ClassName or object instance
7: push 1555130951 // function name: _0_operator_po_pc
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke_static
10: pop // discarge expression result for ExprStatement
11: br finally5 // goto finally
12: try4: nop // 
13: dup // safe exception
14: push "acdk.lang.Exception" // exception name to test for catching
15: instanceof // 
16: brfalse finally5 // goto next catch block
17: clvr 0 // ex
18: store 0
19: push "acdk.lang.System" // class name
20: push "out" // fieldname
21: push 0 // dmi flags
22: peek_static
23: clvr 1 // ClassName or object instance
24: store 1
25: load 0 // ex
26: clvr 2 // ClassName or object instance
27: store 2
28: load 2 // ClassName or object instance
29: push 1615806062 // function name: _3_getMessage
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
31: hash_invoke
32: load 1 // ClassName or object instance
33: push 998516684 // function name: _t_println
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
35: hash_invoke
36: pop // discarge expression result for ExprStatement
37: catchend // clear exception
38: br finally5 // goto finally
39: finally5: nop // 
40: nop // 
   Stack: 
0: push "throwEx" // class name to initialize
   Stack: throwEx | 
1: init_clazz // 
   Stack: 
2: try try4 // try label
   Stack: 
3: push "throwEx" // class name
   Stack: throwEx | 
4: clvr 0 // ClassName or object instance
   Stack: throwEx | 
5: store 0
   Stack: 
6: load 0 // ClassName or object instance
   Stack: throwEx | 
7: push 1555130951 // function name: _0_operator_po_pc
   Stack: throwEx | 1555130951 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: throwEx | 1555130951 | 67108880 | 
9: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "asdf" // Terminal
   Stack: asdf | 
2: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
3: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
4: new
   Stack: acdk/lang/Exception | 
5: throw // throws an exception
   Stack: acdk/lang/Exception | 
13: dup // safe exception
   Stack: acdk/lang/Exception | acdk/lang/Exception | 
14: push "acdk.lang.Exception" // exception name to test for catching
   Stack: acdk/lang/Exception | acdk/lang/Exception | acdk.lang.Exception | 
15: instanceof // 
   Stack: acdk/lang/Exception | true | 
16: brfalse finally5 // goto next catch block
   Stack: acdk/lang/Exception | 
17: clvr 0 // ex
   Stack: acdk/lang/Exception | 
18: store 0
   Stack: 
19: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
20: push "out" // fieldname
   Stack: acdk.lang.System | out | 
21: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
22: peek_static
   Stack: acdk/io/PrintWriter | 
23: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
24: store 1
   Stack: 
25: load 0 // ex
   Stack: acdk/lang/Exception | 
26: clvr 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
27: store 2
   Stack: 
28: load 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
29: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/Exception | 1615806062 | 
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/Exception | 1615806062 | 67108880 | 
31: hash_invoke
   Stack: asdf | 
32: load 1 // ClassName or object instance
   Stack: asdf | acdk/io/PrintWriter | 
33: push 998516684 // function name: _t_println
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 4362076176 | 
35: hash_invoke
asdf
   Stack: Nil | 
36: pop // discarge expression result for ExprStatement
   Stack: 
37: catchend // clear exception
   Stack: 
38: br finally5 // goto finally
   Stack: 
40: nop // 
Parsed: [using acdk.lang;
void throwEx() { throw new Exception("asdf"); }
try {
  throwEx();
} catch (Exception ex) {
  System.out.println(ex.getMessage());
} finally {
  System.out.println("Finally called");
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          throwEx
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ThrowStatement:
                NewExpr:
                  FqTypeName:
                    
                  Arguments:
                    Argument:
                      Literal:
                        : asdf
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  throwEx
                FuncSubscribeExpr:
                  Arguments:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
      FinallyBlock:
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                Literal:
                                  : Finally called

after function:
ClassDeclDef:
  TypeName:
    throwEx
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
    FunctionBlock:
      Block:
        Statement:
          ThrowStatement:
            NewExpr:
              FqTypeName:
                
              Arguments:
                Argument:
                  Literal:
                    : asdf
Create Var this at idx: 0
throwEx this
Create Var ex at idx: 0
__method_start: nop // 
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
push <undefined> // void return
ret  // 
Function operator_po_pc[
__method_start: nop // 
push "asdf" // Terminal
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function throwEx[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "throwEx" // class name to initialize
init_clazz // 
try try7 // try label
push "throwEx" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555130951 // function name: _0_operator_po_pc
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
pop // discarge expression result for ExprStatement
br finally8 // goto finally
try7: nop // 
dup // safe exception
push "acdk.lang.Exception" // exception name to test for catching
instanceof // 
brfalse finally8 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally8 // goto finally
finally8: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
finallyend // goto to next level try-catch block or leafe method
nop // 
nop // 
0: push "throwEx" // class name to initialize
1: init_clazz // 
2: try try7 // try label
3: push "throwEx" // class name
4: clvr 0 // ClassName or object instance
5: store 0
6: load 0 // ClassName or object instance
7: push 1555130951 // function name: _0_operator_po_pc
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke_static
10: pop // discarge expression result for ExprStatement
11: br finally8 // goto finally
12: try7: nop // 
13: dup // safe exception
14: push "acdk.lang.Exception" // exception name to test for catching
15: instanceof // 
16: brfalse finally8 // goto next catch block
17: clvr 0 // ex
18: store 0
19: push "acdk.lang.System" // class name
20: push "out" // fieldname
21: push 0 // dmi flags
22: peek_static
23: clvr 1 // ClassName or object instance
24: store 1
25: load 0 // ex
26: clvr 2 // ClassName or object instance
27: store 2
28: load 2 // ClassName or object instance
29: push 1615806062 // function name: _3_getMessage
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
31: hash_invoke
32: load 1 // ClassName or object instance
33: push 998516684 // function name: _t_println
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
35: hash_invoke
36: pop // discarge expression result for ExprStatement
37: catchend // clear exception
38: br finally8 // goto finally
39: finally8: nop // 
40: push "acdk.lang.System" // class name
41: push "out" // fieldname
42: push 0 // dmi flags
43: peek_static
44: clvr 0 // ClassName or object instance
45: store 0
46: push "Finally called" // Terminal
47: load 0 // ClassName or object instance
48: push 998516684 // function name: _t_println
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
50: hash_invoke
51: pop // discarge expression result for ExprStatement
52: finallyend // goto to next level try-catch block or leafe method
53: nop // 
54: nop // 
   Stack: 
0: push "throwEx" // class name to initialize
   Stack: throwEx | 
1: init_clazz // 
   Stack: 
2: try try7 // try label
   Stack: 
3: push "throwEx" // class name
   Stack: throwEx | 
4: clvr 0 // ClassName or object instance
   Stack: throwEx | 
5: store 0
   Stack: 
6: load 0 // ClassName or object instance
   Stack: throwEx | 
7: push 1555130951 // function name: _0_operator_po_pc
   Stack: throwEx | 1555130951 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: throwEx | 1555130951 | 67108880 | 
9: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "asdf" // Terminal
   Stack: asdf | 
2: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
3: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
4: new
   Stack: acdk/lang/Exception | 
5: throw // throws an exception
   Stack: acdk/lang/Exception | 
13: dup // safe exception
   Stack: acdk/lang/Exception | acdk/lang/Exception | 
14: push "acdk.lang.Exception" // exception name to test for catching
   Stack: acdk/lang/Exception | acdk/lang/Exception | acdk.lang.Exception | 
15: instanceof // 
   Stack: acdk/lang/Exception | true | 
16: brfalse finally8 // goto next catch block
   Stack: acdk/lang/Exception | 
17: clvr 0 // ex
   Stack: acdk/lang/Exception | 
18: store 0
   Stack: 
19: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
20: push "out" // fieldname
   Stack: acdk.lang.System | out | 
21: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
22: peek_static
   Stack: acdk/io/PrintWriter | 
23: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
24: store 1
   Stack: 
25: load 0 // ex
   Stack: acdk/lang/Exception | 
26: clvr 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
27: store 2
   Stack: 
28: load 2 // ClassName or object instance
   Stack: acdk/lang/Exception | 
29: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/Exception | 1615806062 | 
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/Exception | 1615806062 | 67108880 | 
31: hash_invoke
   Stack: asdf | 
32: load 1 // ClassName or object instance
   Stack: asdf | acdk/io/PrintWriter | 
33: push 998516684 // function name: _t_println
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | acdk/io/PrintWriter | 998516684 | 4362076176 | 
35: hash_invoke
asdf
   Stack: Nil | 
36: pop // discarge expression result for ExprStatement
   Stack: 
37: catchend // clear exception
   Stack: 
38: br finally8 // goto finally
   Stack: 
40: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
41: push "out" // fieldname
   Stack: acdk.lang.System | out | 
42: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
43: peek_static
   Stack: acdk/io/PrintWriter | 
44: clvr 0 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
45: store 0
   Stack: 
46: push "Finally called" // Terminal
   Stack: Finally called | 
47: load 0 // ClassName or object instance
   Stack: Finally called | acdk/io/PrintWriter | 
48: push 998516684 // function name: _t_println
   Stack: Finally called | acdk/io/PrintWriter | 998516684 | 
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: Finally called | acdk/io/PrintWriter | 998516684 | 4362076176 | 
50: hash_invoke
Finally called
   Stack: Nil | 
51: pop // discarge expression result for ExprStatement
   Stack: 
52: finallyend // goto to next level try-catch block or leafe method
   Stack: 
53: nop // 
   Stack: 
54: nop // 
Parsed: [using acdk.lang;
void throwEx() { try { throw new Exception("asdf"); } finally { System.out.println("Finally called in throwEx"); } }
try {
  throwEx();
} catch (Exception ex) {
  System.out.println(ex.getMessage());
} finally {
  System.out.println("Finally called");
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          throwEx
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              TryCatchStatement:
                Statement:
                  Block:
                    Statement:
                      ThrowStatement:
                        NewExpr:
                          FqTypeName:
                            
                          Arguments:
                            Argument:
                              Literal:
                                : asdf
                FinallyBlock:
                  Statement:
                    Block:
                      Statement:
                        ExprStatement:
                          SubscribeExpr:
                            VarName:
                              System
                            MemberSubscribeExpr:
                              '.'
                              SubscribeExpr:
                                VarName:
                                  out
                                MemberSubscribeExpr:
                                  '.'
                                  SubscribeExpr:
                                    VarName:
                                      println
                                    FuncSubscribeExpr:
                                      Arguments:
                                        Argument:
                                          Literal:
                                            : Finally called in throwEx
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  throwEx
                FuncSubscribeExpr:
                  Arguments:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
      FinallyBlock:
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                Literal:
                                  : Finally called

after function:
ClassDeclDef:
  TypeName:
    throwEx
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
    FunctionBlock:
      Block:
        Statement:
          TryCatchStatement:
            Statement:
              Block:
                Statement:
                  ThrowStatement:
                    NewExpr:
                      FqTypeName:
                        
                      Arguments:
                        Argument:
                          Literal:
                            : asdf
            FinallyBlock:
              Statement:
                Block:
                  Statement:
                    ExprStatement:
                      SubscribeExpr:
                        VarName:
                          System
                        MemberSubscribeExpr:
                          '.'
                          SubscribeExpr:
                            VarName:
                              out
                            MemberSubscribeExpr:
                              '.'
                              SubscribeExpr:
                                VarName:
                                  println
                                FuncSubscribeExpr:
                                  Arguments:
                                    Argument:
                                      Literal:
                                        : Finally called in throwEx
Create Var this at idx: 0
throwEx this
Create Var ex at idx: 0
__method_start: nop // 
try try10 // try label
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally11 // goto finally
try10: nop // 
finally11: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
finallyend // goto to next level try-catch block or leafe method
try10: nop // 
nop // 
try10: nop // 
nop // 
push <undefined> // void return
ret  // 
Function operator_po_pc[
__method_start: nop // 
try try10 // try label
push "asdf" // Terminal
push "acdk.lang.Exception" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally11 // goto finally
try10: nop // 
finally11: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
clvr 0 // ClassName or object instance
store 0
push "Finally called in throwEx" // Terminal
load 0 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
finallyend // goto to next level try-catch block or leafe method
try10: nop // 
nop // 
try10: nop // 
nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function throwEx[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "throwEx" // class name to initialize
init_clazz // 
try try12 // try label
push "throwEx" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555130951 // function name: _0_operator_po_pc
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
pop // discarge expression result for ExprStatement
br finally13 // goto finally
try12: nop // 
dup // safe exception
push "acdk.lang.Exception" // exception name to test for catching
instanceof // 
brfalse finally13 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally13 // goto finally
finally13: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
finallyend // goto to next level try-catch block or leafe method
nop // 
nop // 
0: push "throwEx" // class name to initialize
1: init_clazz // 
2: try try12 // try label
3: push "throwEx" // class name
4: clvr 0 // ClassName or object instance
5: store 0
6: load 0 // ClassName or object instance
7: push 1555130951 // function name: _0_operator_po_pc
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke_static
10: pop // discarge expression result for ExprStatement
11: br finally13 // goto finally
12: try12: nop // 
13: dup // safe exception
14: push "acdk.lang.Exception" // exception name to test for catching
15: instanceof // 
16: brfalse finally13 // goto next catch block
17: clvr 0 // ex
18: store 0
19: push "acdk.lang.System" // class name
20: push "out" // fieldname
21: push 0 // dmi flags
22: peek_static
23: clvr 1 // ClassName or object instance
24: store 1
25: load 0 // ex
26: clvr 2 // ClassName or object instance
27: store 2
28: load 2 // ClassName or object instance
29: push 1615806062 // function name: _3_getMessage
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
31: hash_invoke
32: load 1 // ClassName or object instance
33: push 998516684 // function name: _t_println
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
35: hash_invoke
36: pop // discarge expression result for ExprStatement
37: catchend // clear exception
38: br finally13 // goto finally
39: finally13: nop // 
40: push "acdk.lang.System" // class name
41: push "out" // fieldname
42: push 0 // dmi flags
43: peek_static
44: clvr 0 // ClassName or object instance
45: store 0
46: push "Finally called" // Terminal
47: load 0 // ClassName or object instance
48: push 998516684 // function name: _t_println
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
50: hash_invoke
51: pop // discarge expression result for ExprStatement
52: finallyend // goto to next level try-catch block or leafe method
53: nop // 
54: nop // 
   Stack: 
0: push "throwEx" // class name to initialize
   Stack: throwEx | 
1: init_clazz // 
   Stack: 
2: try try12 // try label
   Stack: 
3: push "throwEx" // class name
   Stack: throwEx | 
4: clvr 0 // ClassName or object instance
   Stack: throwEx | 
5: store 0
   Stack: 
6: load 0 // ClassName or object instance
   Stack: throwEx | 
7: push 1555130951 // function name: _0_operator_po_pc
   Stack: throwEx | 1555130951 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: throwEx | 1555130951 | 67108880 | 
9: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: try try10 // try label
   Stack: 
2: push "asdf" // Terminal
   Stack: asdf | 
3: push "acdk.lang.Exception" // class name
   Stack: asdf | acdk.lang.Exception | 
4: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Exception | 4294967296 | 
5: new
   Stack: acdk/lang/Exception | 
6: throw // throws an exception
   Stack: acdk/lang/Exception | 
26: nop // 
   Stack: acdk/lang/Exception | 
27: push <undefined> // void return
   Stack: acdk/lang/Exception | Nil | 
28: ret  // 
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
13: dup // safe exception
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | acdk/lang/Exception | 
14: push "acdk.lang.Exception" // exception name to test for catching
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | acdk/lang/Exception | acdk.lang.Exception | 
15: instanceof // 
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | true | 
16: brfalse finally13 // goto next catch block
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
17: clvr 0 // ex
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
18: store 0
   Stack: acdk/lang/Exception | Nil | 
19: push "acdk.lang.System" // class name
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | 
20: push "out" // fieldname
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | out | 
21: push 0 // dmi flags
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | out | 0 | 
22: peek_static
   Stack: acdk/lang/Exception | Nil | acdk/io/PrintWriter | 
23: clvr 1 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | acdk/io/PrintWriter | 
24: store 1
   Stack: acdk/lang/Exception | Nil | 
25: load 0 // ex
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
26: clvr 2 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
27: store 2
   Stack: acdk/lang/Exception | Nil | 
28: load 2 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 
29: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 1615806062 | 
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/Exception | Nil | acdk/lang/Exception | 1615806062 | 67108880 | 
31: hash_invoke
   Stack: acdk/lang/Exception | Nil | asdf | 
32: load 1 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | asdf | acdk/io/PrintWriter | 
33: push 998516684 // function name: _t_println
   Stack: acdk/lang/Exception | Nil | asdf | acdk/io/PrintWriter | 998516684 | 
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: acdk/lang/Exception | Nil | asdf | acdk/io/PrintWriter | 998516684 | 4362076176 | 
35: hash_invoke
asdf
   Stack: acdk/lang/Exception | Nil | Nil | 
36: pop // discarge expression result for ExprStatement
   Stack: acdk/lang/Exception | Nil | 
37: catchend // clear exception
   Stack: acdk/lang/Exception | Nil | 
38: br finally13 // goto finally
   Stack: acdk/lang/Exception | Nil | 
40: push "acdk.lang.System" // class name
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | 
41: push "out" // fieldname
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | out | 
42: push 0 // dmi flags
   Stack: acdk/lang/Exception | Nil | acdk.lang.System | out | 0 | 
43: peek_static
   Stack: acdk/lang/Exception | Nil | acdk/io/PrintWriter | 
44: clvr 0 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | acdk/io/PrintWriter | 
45: store 0
   Stack: acdk/lang/Exception | Nil | 
46: push "Finally called" // Terminal
   Stack: acdk/lang/Exception | Nil | Finally called | 
47: load 0 // ClassName or object instance
   Stack: acdk/lang/Exception | Nil | Finally called | acdk/io/PrintWriter | 
48: push 998516684 // function name: _t_println
   Stack: acdk/lang/Exception | Nil | Finally called | acdk/io/PrintWriter | 998516684 | 
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: acdk/lang/Exception | Nil | Finally called | acdk/io/PrintWriter | 998516684 | 4362076176 | 
50: hash_invoke
Finally called
   Stack: acdk/lang/Exception | Nil | Nil | 
51: pop // discarge expression result for ExprStatement
   Stack: acdk/lang/Exception | Nil | 
52: finallyend // goto to next level try-catch block or leafe method
   Stack: acdk/lang/Exception | Nil | 
53: nop // 
   Stack: acdk/lang/Exception | Nil | 
54: nop // 
Parsed: [using acdk.lang;
void throwEx() { try { throw new acdk.io.IOException("asdf"); } catch (ClassNotFoundException ex) {  } }
try {
  throwEx();
} catch (acdk.io.IOException ex) {
  System.out.println(ex.getMessage());
} finally {
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          throwEx
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              TryCatchStatement:
                Statement:
                  Block:
                    Statement:
                      ThrowStatement:
                        NewExpr:
                          FqTypeName:
                            
                          Arguments:
                            Argument:
                              Literal:
                                : asdf
                CatchBlock:
                  FqTypeName:
                    
                  VarName:
                    ex
                  Statement:
                    Block:
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  throwEx
                FuncSubscribeExpr:
                  Arguments:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
      FinallyBlock:
        Statement:
          Block:

after function:
ClassDeclDef:
  TypeName:
    throwEx
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
    FunctionBlock:
      Block:
        Statement:
          TryCatchStatement:
            Statement:
              Block:
                Statement:
                  ThrowStatement:
                    NewExpr:
                      FqTypeName:
                        
                      Arguments:
                        Argument:
                          Literal:
                            : asdf
            CatchBlock:
              FqTypeName:
                
              VarName:
                ex
              Statement:
                Block:
Create Var this at idx: 0
throwEx this
Create Var ex at idx: 0
Create Var ex at idx: 0
__method_start: nop // 
try try15 // try label
push "acdk.io.IOException" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally16 // goto finally
try15: nop // 
dup // safe exception
push "acdk.lang.ClassNotFoundException" // exception name to test for catching
instanceof // 
brfalse finally16 // goto next catch block
clvr 0 // ex
store 0
catchend // clear exception
br finally16 // goto finally
finally16: nop // 
nop // 
push <undefined> // void return
ret  // 
Function operator_po_pc[
__method_start: nop // 
try try15 // try label
push "asdf" // Terminal
push "acdk.io.IOException" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally16 // goto finally
try15: nop // 
dup // safe exception
push "acdk.lang.ClassNotFoundException" // exception name to test for catching
instanceof // 
brfalse finally16 // goto next catch block
clvr 0 // ex
store 0
catchend // clear exception
br finally16 // goto finally
finally16: nop // 
nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function throwEx[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "throwEx" // class name to initialize
init_clazz // 
try try18 // try label
push "throwEx" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555130951 // function name: _0_operator_po_pc
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
pop // discarge expression result for ExprStatement
br finally19 // goto finally
try18: nop // 
dup // safe exception
push "acdk.io.IOException" // exception name to test for catching
instanceof // 
brfalse finally19 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally19 // goto finally
finally19: nop // 
finallyend // goto to next level try-catch block or leafe method
nop // 
nop // 
0: push "throwEx" // class name to initialize
1: init_clazz // 
2: try try18 // try label
3: push "throwEx" // class name
4: clvr 0 // ClassName or object instance
5: store 0
6: load 0 // ClassName or object instance
7: push 1555130951 // function name: _0_operator_po_pc
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke_static
10: pop // discarge expression result for ExprStatement
11: br finally19 // goto finally
12: try18: nop // 
13: dup // safe exception
14: push "acdk.io.IOException" // exception name to test for catching
15: instanceof // 
16: brfalse finally19 // goto next catch block
17: clvr 0 // ex
18: store 0
19: push "acdk.lang.System" // class name
20: push "out" // fieldname
21: push 0 // dmi flags
22: peek_static
23: clvr 1 // ClassName or object instance
24: store 1
25: load 0 // ex
26: clvr 2 // ClassName or object instance
27: store 2
28: load 2 // ClassName or object instance
29: push 1615806062 // function name: _3_getMessage
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
31: hash_invoke
32: load 1 // ClassName or object instance
33: push 998516684 // function name: _t_println
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
35: hash_invoke
36: pop // discarge expression result for ExprStatement
37: catchend // clear exception
38: br finally19 // goto finally
39: finally19: nop // 
40: finallyend // goto to next level try-catch block or leafe method
41: nop // 
42: nop // 
   Stack: 
0: push "throwEx" // class name to initialize
   Stack: throwEx | 
1: init_clazz // 
   Stack: 
2: try try18 // try label
   Stack: 
3: push "throwEx" // class name
   Stack: throwEx | 
4: clvr 0 // ClassName or object instance
   Stack: throwEx | 
5: store 0
   Stack: 
6: load 0 // ClassName or object instance
   Stack: throwEx | 
7: push 1555130951 // function name: _0_operator_po_pc
   Stack: throwEx | 1555130951 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: throwEx | 1555130951 | 67108880 | 
9: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: try try15 // try label
   Stack: 
2: push "asdf" // Terminal
   Stack: asdf | 
3: push "acdk.io.IOException" // class name
   Stack: asdf | acdk.io.IOException | 
4: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.io.IOException | 4294967296 | 
5: new
   Stack: acdk/io/IOException | 
6: throw // throws an exception
   Stack: acdk/io/IOException | 
9: dup // safe exception
   Stack: acdk/io/IOException | acdk/io/IOException | 
10: push "acdk.lang.ClassNotFoundException" // exception name to test for catching
   Stack: acdk/io/IOException | acdk/io/IOException | acdk.lang.ClassNotFoundException | 
11: instanceof // 
   Stack: acdk/io/IOException | false | 
12: brfalse finally16 // goto next catch block
   Stack: acdk/io/IOException | 
18: nop // 
   Stack: acdk/io/IOException | 
19: push <undefined> // void return
   Stack: acdk/io/IOException | Nil | 
20: ret  // 
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
13: dup // safe exception
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | acdk/io/IOException | 
14: push "acdk.io.IOException" // exception name to test for catching
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | acdk/io/IOException | acdk.io.IOException | 
15: instanceof // 
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | true | 
16: brfalse finally19 // goto next catch block
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
17: clvr 0 // ex
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
18: store 0
   Stack: acdk/io/IOException | Nil | 
19: push "acdk.lang.System" // class name
   Stack: acdk/io/IOException | Nil | acdk.lang.System | 
20: push "out" // fieldname
   Stack: acdk/io/IOException | Nil | acdk.lang.System | out | 
21: push 0 // dmi flags
   Stack: acdk/io/IOException | Nil | acdk.lang.System | out | 0 | 
22: peek_static
   Stack: acdk/io/IOException | Nil | acdk/io/PrintWriter | 
23: clvr 1 // ClassName or object instance
   Stack: acdk/io/IOException | Nil | acdk/io/PrintWriter | 
24: store 1
   Stack: acdk/io/IOException | Nil | 
25: load 0 // ex
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
26: clvr 2 // ClassName or object instance
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
27: store 2
   Stack: acdk/io/IOException | Nil | 
28: load 2 // ClassName or object instance
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 
29: push 1615806062 // function name: _3_getMessage
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 1615806062 | 
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/io/IOException | Nil | acdk/io/IOException | 1615806062 | 67108880 | 
31: hash_invoke
   Stack: acdk/io/IOException | Nil | asdf | 
32: load 1 // ClassName or object instance
   Stack: acdk/io/IOException | Nil | asdf | acdk/io/PrintWriter | 
33: push 998516684 // function name: _t_println
   Stack: acdk/io/IOException | Nil | asdf | acdk/io/PrintWriter | 998516684 | 
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: acdk/io/IOException | Nil | asdf | acdk/io/PrintWriter | 998516684 | 4362076176 | 
35: hash_invoke
asdf
   Stack: acdk/io/IOException | Nil | Nil | 
36: pop // discarge expression result for ExprStatement
   Stack: acdk/io/IOException | Nil | 
37: catchend // clear exception
   Stack: acdk/io/IOException | Nil | 
38: br finally19 // goto finally
   Stack: acdk/io/IOException | Nil | 
40: finallyend // goto to next level try-catch block or leafe method
   Stack: acdk/io/IOException | Nil | 
41: nop // 
   Stack: acdk/io/IOException | Nil | 
42: nop // 
Parsed: [using acdk.lang;
try {
  try {
    throw new Throwable("asdf");
  } catch (Exception ex) {
  }
} catch (Throwable ex) {
  System.out.println("trowable called");
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            TryCatchStatement:
              Statement:
                Block:
                  Statement:
                    ThrowStatement:
                      NewExpr:
                        FqTypeName:
                          
                        Arguments:
                          Argument:
                            Literal:
                              : asdf
              CatchBlock:
                FqTypeName:
                  
                VarName:
                  ex
                Statement:
                  Block:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                Literal:
                                  : trowable called
Create Var ex at idx: 0
Create Var ex at idx: 0
try try21 // try label
try try22 // try label
push "acdk.lang.Throwable" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally23 // goto finally
try22: nop // 
dup // safe exception
push "acdk.lang.Exception" // exception name to test for catching
instanceof // 
brfalse finally23 // goto next catch block
clvr 0 // ex
store 0
catchend // clear exception
br finally23 // goto finally
finally23: nop // 
nop // 
br finally25 // goto finally
try21: nop // 
dup // safe exception
push "acdk.lang.Throwable" // exception name to test for catching
instanceof // 
brfalse finally25 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally25 // goto finally
finally25: nop // 
nop // 
0: try try21 // try label
1: try try22 // try label
2: push "asdf" // Terminal
3: push "acdk.lang.Throwable" // class name
4: push 4294967296 // dmi flags = 0, argcount = 1
5: new
6: throw // throws an exception
7: br finally23 // goto finally
8: try22: nop // 
9: dup // safe exception
10: push "acdk.lang.Exception" // exception name to test for catching
11: instanceof // 
12: brfalse finally23 // goto next catch block
13: clvr 0 // ex
14: store 0
15: catchend // clear exception
16: br finally23 // goto finally
17: finally23: nop // 
18: nop // 
19: br finally25 // goto finally
20: try21: nop // 
21: dup // safe exception
22: push "acdk.lang.Throwable" // exception name to test for catching
23: instanceof // 
24: brfalse finally25 // goto next catch block
25: clvr 0 // ex
26: store 0
27: push "acdk.lang.System" // class name
28: push "out" // fieldname
29: push 0 // dmi flags
30: peek_static
31: clvr 1 // ClassName or object instance
32: store 1
33: push "trowable called" // Terminal
34: load 1 // ClassName or object instance
35: push 998516684 // function name: _t_println
36: push 4362076176 // dmi flags = PUBLIC, argcount = 1
37: hash_invoke
38: pop // discarge expression result for ExprStatement
39: catchend // clear exception
40: br finally25 // goto finally
41: finally25: nop // 
42: nop // 
   Stack: 
0: try try21 // try label
   Stack: 
1: try try22 // try label
   Stack: 
2: push "asdf" // Terminal
   Stack: asdf | 
3: push "acdk.lang.Throwable" // class name
   Stack: asdf | acdk.lang.Throwable | 
4: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.Throwable | 4294967296 | 
5: new
   Stack: acdk/lang/Throwable | 
6: throw // throws an exception
   Stack: acdk/lang/Throwable | 
9: dup // safe exception
   Stack: acdk/lang/Throwable | acdk/lang/Throwable | 
10: push "acdk.lang.Exception" // exception name to test for catching
   Stack: acdk/lang/Throwable | acdk/lang/Throwable | acdk.lang.Exception | 
11: instanceof // 
   Stack: acdk/lang/Throwable | false | 
12: brfalse finally23 // goto next catch block
   Stack: acdk/lang/Throwable | 
18: nop // 
   Stack: acdk/lang/Throwable | 
19: br finally25 // goto finally
   Stack: acdk/lang/Throwable | 
42: nop // 
[AUNIT:ERRR][Exceptions_Test.catchAalException] Error in Test: Exceptions_Test.catchAalException: asdf
</pre>
<h2><a id="Exceptions_Test.throwAckdCatchAalException">Exceptions_Test.throwAckdCatchAalException</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Exceptions_Test.catchAalException] End Test
[AUNIT:STRT][Exceptions_Test.throwAckdCatchAalException] Start Test
Parsed: [using acdk.lang;
try {
  Object o;
  o.toString();
} catch (NullPointerException ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            LVarDecl:
              FqTypeName:
                
              VarName:
                o
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  o
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      toString
                    FuncSubscribeExpr:
                      Arguments:
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var o at idx: 0
Create Var ex at idx: 0
try try1 // try label
clvr 0 // o
push Nil // initialize local value
store 0 // initialize local value
load 0 // o
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 749992755 // function name: _a_toString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
pop // discarge expression result for ExprStatement
br finally2 // goto finally
try1: nop // 
dup // safe exception
push "acdk.lang.NullPointerException" // exception name to test for catching
instanceof // 
brfalse finally2 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally2 // goto finally
finally2: nop // 
nop // 
0: try try1 // try label
1: clvr 0 // o
2: push Nil // initialize local value
3: store 0 // initialize local value
4: load 0 // o
5: clvr 1 // ClassName or object instance
6: store 1
7: load 1 // ClassName or object instance
8: push 749992755 // function name: _a_toString
9: push 67108880 // dmi flags = PUBLIC, argcount = 0
10: hash_invoke
11: pop // discarge expression result for ExprStatement
12: br finally2 // goto finally
13: try1: nop // 
14: dup // safe exception
15: push "acdk.lang.NullPointerException" // exception name to test for catching
16: instanceof // 
17: brfalse finally2 // goto next catch block
18: clvr 0 // ex
19: store 0
20: push "acdk.lang.System" // class name
21: push "out" // fieldname
22: push 0 // dmi flags
23: peek_static
24: clvr 1 // ClassName or object instance
25: store 1
26: load 0 // ex
27: clvr 2 // ClassName or object instance
28: store 2
29: load 2 // ClassName or object instance
30: push 1615806062 // function name: _3_getMessage
31: push 67108880 // dmi flags = PUBLIC, argcount = 0
32: hash_invoke
33: load 1 // ClassName or object instance
34: push 998516684 // function name: _t_println
35: push 4362076176 // dmi flags = PUBLIC, argcount = 1
36: hash_invoke
37: pop // discarge expression result for ExprStatement
38: catchend // clear exception
39: br finally2 // goto finally
40: finally2: nop // 
41: nop // 
   Stack: 
0: try try1 // try label
   Stack: 
1: clvr 0 // o
   Stack: 
2: push Nil // initialize local value
   Stack: Nil | 
3: store 0 // initialize local value
   Stack: 
4: load 0 // o
   Stack: Nil | 
5: clvr 1 // ClassName or object instance
   Stack: Nil | 
6: store 1
   Stack: 
7: load 1 // ClassName or object instance
   Stack: Nil | 
8: push 749992755 // function name: _a_toString
   Stack: Nil | 749992755 | 
9: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: Nil | 749992755 | 67108880 | 
10: hash_invoke
   Stack: acdk/lang/NullPointerException | 
14: dup // safe exception
   Stack: acdk/lang/NullPointerException | acdk/lang/NullPointerException | 
15: push "acdk.lang.NullPointerException" // exception name to test for catching
   Stack: acdk/lang/NullPointerException | acdk/lang/NullPointerException | acdk.lang.NullPointerException | 
16: instanceof // 
   Stack: acdk/lang/NullPointerException | true | 
17: brfalse finally2 // goto next catch block
   Stack: acdk/lang/NullPointerException | 
18: clvr 0 // ex
   Stack: acdk/lang/NullPointerException | 
19: store 0
   Stack: 
20: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
21: push "out" // fieldname
   Stack: acdk.lang.System | out | 
22: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
23: peek_static
   Stack: acdk/io/PrintWriter | 
24: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
25: store 1
   Stack: 
26: load 0 // ex
   Stack: acdk/lang/NullPointerException | 
27: clvr 2 // ClassName or object instance
   Stack: acdk/lang/NullPointerException | 
28: store 2
   Stack: 
29: load 2 // ClassName or object instance
   Stack: acdk/lang/NullPointerException | 
30: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/NullPointerException | 1615806062 | 
31: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/NullPointerException | 1615806062 | 67108880 | 
32: hash_invoke
   Stack: NullPointerException | 
33: load 1 // ClassName or object instance
   Stack: NullPointerException | acdk/io/PrintWriter | 
34: push 998516684 // function name: _t_println
   Stack: NullPointerException | acdk/io/PrintWriter | 998516684 | 
35: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: NullPointerException | acdk/io/PrintWriter | 998516684 | 4362076176 | 
36: hash_invoke
NullPointerException
   Stack: Nil | 
37: pop // discarge expression result for ExprStatement
   Stack: 
38: catchend // clear exception
   Stack: 
39: br finally2 // goto finally
   Stack: 
41: nop // 
</pre>
<h2><a id="Exceptions_Test.aalExceptions">Exceptions_Test.aalExceptions</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Exceptions_Test.throwAckdCatchAalException] End Test
[AUNIT:STRT][Exceptions_Test.aalExceptions] Start Test
Parsed: [using acdk.lang;
class MyException extends acdk.lang.Exception { public MyException(String msg) : Exception(msg) {} }
try {
  throw new MyException("Test");
} catch (MyException ex) {
  System.out.println(ex.getMessage());
}

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        MyException
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          MyException
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              msg
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  msg
        FunctionBlock:
          Block:
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ThrowStatement:
              NewExpr:
                FqTypeName:
                  
                Arguments:
                  Argument:
                    Literal:
                      : Test
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var msg at idx: 0
acdk.lang.String msg
Create Var this at idx: 0
MyException this
acdk.lang.String msg
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        msg
Create Var ex at idx: 0
load 1 // msg
load 0 // this
push "Exception" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function MyException[
load 1 // msg
load 0 // this
push "Exception" // function name
push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "MyException" // class name to initialize
init_clazz // 
try try1 // try label
push "MyException" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
throw // throws an exception
br finally2 // goto finally
try1: nop // 
dup // safe exception
push "MyException" // exception name to test for catching
instanceof // 
brfalse finally2 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally2 // goto finally
finally2: nop // 
nop // 
0: push "MyException" // class name to initialize
1: init_clazz // 
2: try try1 // try label
3: push "Test" // Terminal
4: push "MyException" // class name
5: push 4294967296 // dmi flags = 0, argcount = 1
6: new
7: throw // throws an exception
8: br finally2 // goto finally
9: try1: nop // 
10: dup // safe exception
11: push "MyException" // exception name to test for catching
12: instanceof // 
13: brfalse finally2 // goto next catch block
14: clvr 0 // ex
15: store 0
16: push "acdk.lang.System" // class name
17: push "out" // fieldname
18: push 0 // dmi flags
19: peek_static
20: clvr 1 // ClassName or object instance
21: store 1
22: load 0 // ex
23: clvr 2 // ClassName or object instance
24: store 2
25: load 2 // ClassName or object instance
26: push 1615806062 // function name: _3_getMessage
27: push 67108880 // dmi flags = PUBLIC, argcount = 0
28: hash_invoke
29: load 1 // ClassName or object instance
30: push 998516684 // function name: _t_println
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
32: hash_invoke
33: pop // discarge expression result for ExprStatement
34: catchend // clear exception
35: br finally2 // goto finally
36: finally2: nop // 
37: nop // 
   Stack: 
0: push "MyException" // class name to initialize
   Stack: MyException | 
1: init_clazz // 
   Stack: 
2: try try1 // try label
   Stack: 
3: push "Test" // Terminal
   Stack: Test | 
4: push "MyException" // class name
   Stack: Test | MyException | 
5: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: Test | MyException | 4294967296 | 
6: new
   Stack: 
0: load 1 // msg
   Stack: Test | 
1: load 0 // this
   Stack: Test | MyException | 
2: push "Exception" // function name
   Stack: Test | MyException | Exception | 
3: push 4297064512 // flags = TRANSIENT | PROTECTED, argcount = 1
   Stack: Test | MyException | Exception | 4297064512 | 
4: invoke
   Stack: acdk/lang/Exception | 
5: pop // remove invoke result
   Stack: 
6: __method_start: nop // 
   Stack: 
7: push <undefined> // void return
   Stack: Nil | 
8: ret  // 
   Stack: MyException | 
7: throw // throws an exception
   Stack: MyException | 
10: dup // safe exception
   Stack: MyException | MyException | 
11: push "MyException" // exception name to test for catching
   Stack: MyException | MyException | MyException | 
12: instanceof // 
   Stack: MyException | true | 
13: brfalse finally2 // goto next catch block
   Stack: MyException | 
14: clvr 0 // ex
   Stack: MyException | 
15: store 0
   Stack: 
16: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
17: push "out" // fieldname
   Stack: acdk.lang.System | out | 
18: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
19: peek_static
   Stack: acdk/io/PrintWriter | 
20: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
21: store 1
   Stack: 
22: load 0 // ex
   Stack: MyException | 
23: clvr 2 // ClassName or object instance
   Stack: MyException | 
24: store 2
   Stack: 
25: load 2 // ClassName or object instance
   Stack: MyException | 
26: push 1615806062 // function name: _3_getMessage
   Stack: MyException | 1615806062 | 
27: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: MyException | 1615806062 | 67108880 | 
28: hash_invoke
   Stack: Test | 
29: load 1 // ClassName or object instance
   Stack: Test | acdk/io/PrintWriter | 
30: push 998516684 // function name: _t_println
   Stack: Test | acdk/io/PrintWriter | 998516684 | 
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: Test | acdk/io/PrintWriter | 998516684 | 4362076176 | 
32: hash_invoke
Test
   Stack: Nil | 
33: pop // discarge expression result for ExprStatement
   Stack: 
34: catchend // clear exception
   Stack: 
35: br finally2 // goto finally
   Stack: 
37: nop // 
</pre>
<h2><a id="ExtendClass_Test.extendClass">ExtendClass_Test.extendClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 2,48: Cannot find semantic element: _ivar<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::CodeException::CodeException (acdk_aal_d.dll)
  called in acdk::aal::VarName::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::AdditiveExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::Block::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::ExtendStatement::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::ExtendClass_Test::extendClass (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::ExtendClass_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Exceptions_Test.aalExceptions] End Test
[AUNIT:STRT][ExtendClass_Test.extendClass] Start Test
Parsed: [using acdk.lang;
class BaseClass { public int _ivar; public BaseClass(int i) : _ivar(i) {} }
extend int BaseClass.foo(int i) { return _ivar + i; }
BaseClass cls = new BaseClass(42);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        BaseClass
      DerivedDef:
      ClassDeclMember:
        ClassMemberAttr:
          'public'
        FqTypeName:
          
        VarName:
          _ivar
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BaseClass
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        ClassDeclConstructorInitializerList:
          ClassDeclConstructorInitializer:
            FqTypeName:
              
            Arguments:
              Argument:
                VarName:
                  i
        FunctionBlock:
          Block:
  Statement:
    ExtendStatement:
      'extend'
      ReturnType:
        FqTypeName:
          
      FqTypeName:
        
      FunctionParamsDecl:
        Parameter:
          FqTypeName:
            
          VarName:
            i
      FunctionBlock:
        Block:
          Statement:
            ReturnStatement:
              AdditiveExpr:
                VarName:
                  _ivar
                '+'
                VarName:
                  i
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        cls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 42
Create Var i at idx: 0
int i
Create Var this at idx: 0
BaseClass this
int i
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
    Argument:
      VarName:
        i
Create Var i at idx: 0
int i
[AUNIT:ERRR][ExtendClass_Test.extendClass] Error in Test: ExtendClass_Test.extendClass: 2,48: Cannot find semantic element: _ivar
</pre>
<h2><a id="Functions_Test.standard">Functions_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][ExtendClass_Test.extendClass] End Test
[AUNIT:STRT][Functions_Test.standard] Start Test
Parsed: [class Foo { public static int operator()(int i) { return i + 1; } }
int foo(int i) { return i + 1; }
foo(41);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        Foo
      DerivedDef:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            
        Operator:
          ()
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          foo
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 41
Create Var i at idx: 0
int i
Create Var this at idx: 0
Foo this

after function:
ClassDeclDef:
  TypeName:
    foo
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
      Parameter:
        FqTypeName:
          
        VarName:
          i
    FunctionBlock:
      Block:
        Statement:
          ReturnStatement:
            AdditiveExpr:
              VarName:
                i
              '+'
              Literal:
                : 1
Create Var i at idx: 0
int i
Create Var this at idx: 0
foo this
Code already postParsed: Argument: 
CodeText:
 SymbolTable: [
 ]
  Statement:
    ClassDeclDef:(Foo=Foo)
     SymbolTable: [
      Foo this
     ]
      TypeName:
        Foo
      DerivedDef:
      ClassDeclOperator:Sem=[operator_po_pc=int]
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            
        Operator:
          ()
        FunctionParamsDecl:
         SymbolTable: [
          int i
         ]
          Parameter:Sem=[i=int]
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
           SymbolTable: [
            int i
           ]
            Statement:
              ReturnStatement:
                AdditiveExpr:Sem=[byte=byte]
                  VarName:Sem=[i=int] ExprSem=[i=int]
                    i
                  '+'
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 1
      ClassDeclConstructor:Sem=[Foo=void]
        ClassMemberAttr:
          'public'
        MethodName:
          Foo
        FunctionParamsDecl:
         SymbolTable: [
          Foo this
         ]
        ClassDeclConstructorInitializerList:(Foo=Foo)
         SymbolTable: [
          Foo this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            Foo this
           ]
  Statement:
    FunctionDeclDef:
      ClassDeclDef:(foo=foo)
       SymbolTable: [
        foo this
       ]
        TypeName:
          foo
        DerivedDef:
        ClassDeclOperator:Sem=[operator_po_pc=int]
          ClassMemberAttr:
            'public'
            'static'
          ReturnType:
            FqTypeName:
              
          Operator:
            ()
          FunctionParamsDecl:
           SymbolTable: [
            int i
           ]
            Parameter:Sem=[i=int]
              FqTypeName:
                
              VarName:
                i
          FunctionBlock:
            Block:
             SymbolTable: [
              int i
             ]
              Statement:
                ReturnStatement:
                  AdditiveExpr:Sem=[byte=byte]
                    VarName:Sem=[i=int] ExprSem=[i=int]
                      i
                    '+'
                    Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                      : 1
        ClassDeclConstructor:Sem=[foo=void]
          ClassMemberAttr:
            'public'
          MethodName:
            foo
          FunctionParamsDecl:
           SymbolTable: [
            foo this
           ]
          ClassDeclConstructorInitializerList:(foo=foo)
           SymbolTable: [
            foo this
           ]
          FunctionBlock:
            Block:
             SymbolTable: [
              foo this
             ]
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
        VarName:Sem=[foo=foo] ExprSem=[foo=foo]
          foo
        MemberSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
          '.'
          SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
            VarName:Sem=[operator_po_pc=int] ExprSem=[operator_po_pc=int]
              operator_po_pc
            FuncSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
              Arguments:
                Argument:Sem=[byte=byte]
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 41
__method_start: nop // 
load 0 // i
add
ret  // return statement
Function operator_po_pc[
__method_start: nop // 
load 0 // i
push 1 // Terminal
add
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function Foo[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "Foo" // class name to initialize
init_clazz // 
__method_start: nop // 
load 0 // i
add
ret  // return statement
Function operator_po_pc[
__method_start: nop // 
load 0 // i
push 1 // Terminal
add
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function foo[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "foo" // class name to initialize
init_clazz // 
push "foo" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555235382 // function name: _0_operator_po_pc
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke_static
pop // discarge expression result for ExprStatement
0: push "Foo" // class name to initialize
1: init_clazz // 
2: push "foo" // class name to initialize
3: init_clazz // 
4: push "foo" // class name
5: clvr 0 // ClassName or object instance
6: store 0
7: push 41 // Terminal
8: load 0 // ClassName or object instance
9: push 1555235382 // function name: _0_operator_po_pc
10: push 4362076176 // dmi flags = PUBLIC, argcount = 1
11: hash_invoke_static
12: pop // discarge expression result for ExprStatement
   Stack: 
0: push "Foo" // class name to initialize
   Stack: Foo | 
1: init_clazz // 
   Stack: 
2: push "foo" // class name to initialize
   Stack: foo | 
3: init_clazz // 
   Stack: 
4: push "foo" // class name
   Stack: foo | 
5: clvr 0 // ClassName or object instance
   Stack: foo | 
6: store 0
   Stack: 
7: push 41 // Terminal
   Stack: 41 | 
8: load 0 // ClassName or object instance
   Stack: 41 | foo | 
9: push 1555235382 // function name: _0_operator_po_pc
   Stack: 41 | foo | 1555235382 | 
10: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 41 | foo | 1555235382 | 4362076176 | 
11: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 0 // i
   Stack: 41 | 
2: push 1 // Terminal
   Stack: 41 | 1 | 
3: add
   Stack: 42 | 
4: ret  // return statement
   Stack: 42 | 
12: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.standard">Interpret_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 1  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Functions_Test.standard] End Test
[AUNIT:STRT][Interpret_Test.standard] Start Test
Create Var erg at idx: 0
   Stack: 
-1: clvr 0 // global var
   Stack:  | 
-1: store 0 // global var
Parsed: [erg = new acdk.lang.String("asdf");] to
CodeText:
 SymbolTable: [
  acdk.lang.String erg
 ]
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          erg
        '='
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : asdf
push "acdk.lang.String" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // erg
assign
pop // discarge expression result for ExprStatement
0: push "asdf" // Terminal
1: push "acdk.lang.String" // class name
2: push 4294967296 // dmi flags = 0, argcount = 1
3: new
4: loadref 0 // erg
5: assign
6: pop // discarge expression result for ExprStatement
   Stack: 
0: push "asdf" // Terminal
   Stack: asdf | 
1: push "acdk.lang.String" // class name
   Stack: asdf | acdk.lang.String | 
2: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.String | 4294967296 | 
3: new
   Stack: asdf | 
4: loadref 0 // erg
   Stack: asdf | & | 
5: assign
   Stack: asdf | 
6: pop // discarge expression result for ExprStatement
   Stack: 
6: load 0 // read global var
Parsed: [acdk.lang.StringBuffer sb = new acdk.lang.StringBuffer("Hello ");
sb.append("ACDK");
acdk.lang.System.out.println(sb.toString());
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        sb
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : Hello 
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          sb
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              append
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : ACDK
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          acdk
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              lang
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  System
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      out
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          println
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              SubscribeExpr:
                                VarName:
                                  sb
                                MemberSubscribeExpr:
                                  '.'
                                  SubscribeExpr:
                                    VarName:
                                      toString
                                    FuncSubscribeExpr:
                                      Arguments:
Create Var sb at idx: 0
CodeText:
 SymbolTable: [
  acdk.lang.StringBuffer sb
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        sb
      ExprStatement:
        AssignmentExpr:Sem=[sb=acdk.lang.StringBuffer] ExprSem=[sb=acdk.lang.StringBuffer]
          VarName:Sem=[sb=acdk.lang.StringBuffer] ExprSem=[sb=acdk.lang.StringBuffer]
            sb
          '='
          NewExpr:Sem=[acdk.lang.StringBuffer=acdk.lang.StringBuffer]
            FqTypeName:
              
            Arguments:
              Argument:Sem=[acdk.lang.String=acdk.lang.String]
                Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  : Hello 
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[append=acdk.lang.StringBuffer] ExprSem=[acdk.lang.StringBuffer=acdk.lang.StringBuffer]
        VarName:Sem=[sb=acdk.lang.StringBuffer] ExprSem=[sb=acdk.lang.StringBuffer]
          sb
        MemberSubscribeExpr:Sem=[append=acdk.lang.StringBuffer] ExprSem=[acdk.lang.StringBuffer=acdk.lang.StringBuffer]
          '.'
          SubscribeExpr:Sem=[append=acdk.lang.StringBuffer] ExprSem=[acdk.lang.StringBuffer=acdk.lang.StringBuffer]
            VarName:Sem=[append=acdk.lang.StringBuffer] ExprSem=[append=acdk.lang.StringBuffer]
              append
            FuncSubscribeExpr:Sem=[append=acdk.lang.StringBuffer] ExprSem=[acdk.lang.StringBuffer=acdk.lang.StringBuffer]
              Arguments:
                Argument:Sem=[acdk.lang.String=acdk.lang.String]
                  Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                    : ACDK
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
        VarName:Sem=[acdk=<no-type>] ExprSem=[acdk=<no-type>]
          acdk
        MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
          '.'
          SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
            VarName:Sem=[acdk/lang=<no-type>] ExprSem=[acdk/lang=<no-type>]
              lang
            MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
              '.'
              SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                VarName:Sem=[acdk.lang.System=acdk.lang.System] ExprSem=[acdk.lang.System=acdk.lang.System]
                  System
                MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                  '.'
                  SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                    VarName:Sem=[out=acdk.io.PrintWriter] ExprSem=[out=acdk.io.PrintWriter]
                      out
                    MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                      '.'
                      SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                        VarName:Sem=[println=void] ExprSem=[println=void]
                          println
                        FuncSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                          Arguments:
                            Argument:Sem=[toString=acdk.lang.String]
                              SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                VarName:Sem=[sb=acdk.lang.StringBuffer] ExprSem=[sb=acdk.lang.StringBuffer]
                                  sb
                                MemberSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                  '.'
                                  SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                    VarName:Sem=[toString=acdk.lang.String] ExprSem=[toString=acdk.lang.String]
                                      toString
                                    FuncSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                      Arguments:
clvr 0 // sb
push Nil // initialize local value
store 0 // initialize local value
push "acdk.lang.StringBuffer" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // sb
assign
pop // discarge expression result for ExprStatement
load 0 // sb
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 1371399937 // function name: _f_append
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 0 // sb
Create Var __tvar3 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 749992755 // function name: _a_toString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 2 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
0: clvr 0 // sb
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push "Hello " // Terminal
4: push "acdk.lang.StringBuffer" // class name
5: push 4294967296 // dmi flags = 0, argcount = 1
6: new
7: loadref 0 // sb
8: assign
9: pop // discarge expression result for ExprStatement
10: load 0 // sb
11: clvr 1 // ClassName or object instance
12: store 1
13: push "ACDK" // Terminal
14: load 1 // ClassName or object instance
15: push 1371399937 // function name: _f_append
16: push 4362076176 // dmi flags = PUBLIC, argcount = 1
17: hash_invoke
18: pop // discarge expression result for ExprStatement
19: push "acdk.lang.System" // class name
20: push "out" // fieldname
21: push 0 // dmi flags
22: peek_static
23: clvr 2 // ClassName or object instance
24: store 2
25: load 0 // sb
26: clvr 3 // ClassName or object instance
27: store 3
28: load 3 // ClassName or object instance
29: push 749992755 // function name: _a_toString
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
31: hash_invoke
32: load 2 // ClassName or object instance
33: push 998516684 // function name: _t_println
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
35: hash_invoke
36: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // sb
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push "Hello " // Terminal
   Stack: Hello  | 
4: push "acdk.lang.StringBuffer" // class name
   Stack: Hello  | acdk.lang.StringBuffer | 
5: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: Hello  | acdk.lang.StringBuffer | 4294967296 | 
6: new
   Stack: Hello  | 
7: loadref 0 // sb
   Stack: Hello  | &Nil | 
8: assign
   Stack: Hello  | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: load 0 // sb
   Stack: Hello  | 
11: clvr 1 // ClassName or object instance
   Stack: Hello  | 
12: store 1
   Stack: 
13: push "ACDK" // Terminal
   Stack: ACDK | 
14: load 1 // ClassName or object instance
   Stack: ACDK | Hello  | 
15: push 1371399937 // function name: _f_append
   Stack: ACDK | Hello  | 1371399937 | 
16: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: ACDK | Hello  | 1371399937 | 4362076176 | 
17: hash_invoke
   Stack: Hello ACDK | 
18: pop // discarge expression result for ExprStatement
   Stack: 
19: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
20: push "out" // fieldname
   Stack: acdk.lang.System | out | 
21: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
22: peek_static
   Stack: acdk/io/PrintWriter | 
23: clvr 2 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
24: store 2
   Stack: 
25: load 0 // sb
   Stack: Hello ACDK | 
26: clvr 3 // ClassName or object instance
   Stack: Hello ACDK | 
27: store 3
   Stack: 
28: load 3 // ClassName or object instance
   Stack: Hello ACDK | 
29: push 749992755 // function name: _a_toString
   Stack: Hello ACDK | 749992755 | 
30: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: Hello ACDK | 749992755 | 67108880 | 
31: hash_invoke
   Stack: Hello ACDK | 
32: load 2 // ClassName or object instance
   Stack: Hello ACDK | acdk/io/PrintWriter | 
33: push 998516684 // function name: _t_println
   Stack: Hello ACDK | acdk/io/PrintWriter | 998516684 | 
34: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: Hello ACDK | acdk/io/PrintWriter | 998516684 | 4362076176 | 
35: hash_invoke
Hello ACDK
   Stack: Nil | 
36: pop // discarge expression result for ExprStatement
Parsed: [class AClass { AClass() {} acdk.lang.String foo(acdk.lang.String s) { return s; } }
AClass a = new AClass();
a.foo(new acdk.lang.String("asdf"));
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              s
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                VarName:
                  s
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          a
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  NewExpr:
                    FqTypeName:
                      
                    Arguments:
                      Argument:
                        Literal:
                          : asdf
Create Var this at idx: 0
AClass this
Create Var s at idx: 0
acdk.lang.String s
Create Var this at idx: 0
AClass this
acdk.lang.String s
Create Var a at idx: 0
CodeText:
 SymbolTable: [
  AClass a
 ]
  Statement:
    ClassDeclDef:(AClass=AClass)
     SymbolTable: [
      AClass this
      acdk.lang.String s
     ]
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:Sem=[AClass=void]
        MethodName:
          AClass
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        ClassDeclConstructorInitializerList:(AClass=AClass)
         SymbolTable: [
          AClass this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
      ClassDeclMethod:Sem=[foo=acdk.lang.String]
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
          acdk.lang.String s
         ]
          Parameter:Sem=[s=acdk.lang.String]
            FqTypeName:
              
            VarName:
              s
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
            acdk.lang.String s
           ]
            Statement:
              ReturnStatement:
                VarName:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
                  s
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      ExprStatement:
        AssignmentExpr:Sem=[a=AClass] ExprSem=[a=AClass]
          VarName:Sem=[a=AClass] ExprSem=[a=AClass]
            a
          '='
          NewExpr:Sem=[AClass=AClass]
            FqTypeName:
              
            Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[foo=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
        VarName:Sem=[a=AClass] ExprSem=[a=AClass]
          a
        MemberSubscribeExpr:Sem=[foo=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
          '.'
          SubscribeExpr:Sem=[foo=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
            VarName:Sem=[foo=acdk.lang.String] ExprSem=[foo=acdk.lang.String]
              foo
            FuncSubscribeExpr:Sem=[foo=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              Arguments:
                Argument:Sem=[acdk.lang.String=acdk.lang.String]
                  NewExpr:Sem=[acdk.lang.String=acdk.lang.String]
                    FqTypeName:
                      
                    Arguments:
                      Argument:Sem=[acdk.lang.String=acdk.lang.String]
                        Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                          : asdf
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 1 // s
ret  // return statement
Function foo[
__method_start: nop // 
load 1 // s
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // a
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // a
assign
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
push "acdk.lang.String" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
load 1 // ClassName or object instance
push -2126979433 // function name: _1_foo
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // a
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // a
9: assign
10: pop // discarge expression result for ExprStatement
11: load 0 // a
12: clvr 1 // ClassName or object instance
13: store 1
14: push "asdf" // Terminal
15: push "acdk.lang.String" // class name
16: push 4294967296 // dmi flags = 0, argcount = 1
17: new
18: load 1 // ClassName or object instance
19: push -2126979433 // function name: _1_foo
20: push 4362076176 // dmi flags = PUBLIC, argcount = 1
21: hash_invoke
22: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // a
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // a
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: load 0 // a
   Stack: AClass | 
12: clvr 1 // ClassName or object instance
   Stack: AClass | 
13: store 1
   Stack: 
14: push "asdf" // Terminal
   Stack: asdf | 
15: push "acdk.lang.String" // class name
   Stack: asdf | acdk.lang.String | 
16: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: asdf | acdk.lang.String | 4294967296 | 
17: new
   Stack: asdf | 
18: load 1 // ClassName or object instance
   Stack: asdf | AClass | 
19: push -2126979433 // function name: _1_foo
   Stack: asdf | AClass | -2126979433 | 
20: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | AClass | -2126979433 | 4362076176 | 
21: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 1 // s
   Stack: asdf | 
2: ret  // return statement
   Stack: asdf | 
22: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.assignment">Interpret_Test.assignment</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.standard] End Test
[AUNIT:STRT][Interpret_Test.assignment] Start Test
Parsed: [int i = 0;
int j = 0; i = j = 42;
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        AssignmentExpr:
          VarName:
            j
          '='
          Literal:
            : 42
Create Var i at idx: 0
Create Var j at idx: 1
CodeText:
 SymbolTable: [
  int i
  int j
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      ExprStatement:
        AssignmentExpr:Sem=[j=int] ExprSem=[j=int]
          VarName:Sem=[j=int] ExprSem=[j=int]
            j
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    ExprStatement:
      AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '='
        AssignmentExpr:Sem=[j=int] ExprSem=[j=int]
          VarName:Sem=[j=int] ExprSem=[j=int]
            j
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 42
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
loadref 1 // j
assign
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: push 0 // Terminal
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: push 42 // Terminal
15: loadref 1 // j
16: assign
17: loadref 0 // i
18: assign
19: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: push 0 // Terminal
   Stack: 0 | 
11: loadref 1 // j
   Stack: 0 | &0 | 
12: assign
   Stack: 0 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 42 // Terminal
   Stack: 42 | 
15: loadref 1 // j
   Stack: 42 | &0 | 
16: assign
   Stack: 42 | 
17: loadref 0 // i
   Stack: 42 | &0 | 
18: assign
   Stack: 42 | 
19: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.fqClassInvoke">Interpret_Test.fqClassInvoke</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.assignment] End Test
[AUNIT:STRT][Interpret_Test.fqClassInvoke] Start Test
Parsed: [acdk.lang.System.out.println("hello from Aal");
] to
CodeText:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          acdk
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              lang
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  System
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      out
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          println
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : hello from Aal
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
        VarName:Sem=[acdk=<no-type>] ExprSem=[acdk=<no-type>]
          acdk
        MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
          '.'
          SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
            VarName:Sem=[acdk/lang=<no-type>] ExprSem=[acdk/lang=<no-type>]
              lang
            MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
              '.'
              SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                VarName:Sem=[acdk.lang.System=acdk.lang.System] ExprSem=[acdk.lang.System=acdk.lang.System]
                  System
                MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                  '.'
                  SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                    VarName:Sem=[out=acdk.io.PrintWriter] ExprSem=[out=acdk.io.PrintWriter]
                      out
                    MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                      '.'
                      SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                        VarName:Sem=[println=void] ExprSem=[println=void]
                          println
                        FuncSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                          Arguments:
                            Argument:Sem=[acdk.lang.String=acdk.lang.String]
                              Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                : hello from Aal
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
0: push "acdk.lang.System" // class name
1: push "out" // fieldname
2: push 0 // dmi flags
3: peek_static
4: clvr 0 // ClassName or object instance
5: store 0
6: push "hello from Aal" // Terminal
7: load 0 // ClassName or object instance
8: push 998516684 // function name: _t_println
9: push 4362076176 // dmi flags = PUBLIC, argcount = 1
10: hash_invoke
11: pop // discarge expression result for ExprStatement
   Stack: 
0: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
1: push "out" // fieldname
   Stack: acdk.lang.System | out | 
2: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
3: peek_static
   Stack: acdk/io/PrintWriter | 
4: clvr 0 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
5: store 0
   Stack: 
6: push "hello from Aal" // Terminal
   Stack: hello from Aal | 
7: load 0 // ClassName or object instance
   Stack: hello from Aal | acdk/io/PrintWriter | 
8: push 998516684 // function name: _t_println
   Stack: hello from Aal | acdk/io/PrintWriter | 998516684 | 
9: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: hello from Aal | acdk/io/PrintWriter | 998516684 | 4362076176 | 
10: hash_invoke
hello from Aal
   Stack: Nil | 
11: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.classOperator">Interpret_Test.classOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.fqClassInvoke] End Test
[AUNIT:STRT][Interpret_Test.classOperator] Start Test
Parsed: [class AClass { AClass() { } acdk.lang.String operator+(acdk.lang.String s) { return "AClass String"; } }
AClass a = new AClass();
acdk.lang.String s1 = a.operator_pl("asdf");
s1 = a + "asdf";
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ReturnType:
          FqTypeName:
            
        Operator:
          +
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              s
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : AClass String
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s1
      VarInitializer:
        SubscribeExpr:
          VarName:
            a
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                operator_pl
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : asdf
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s1
        '='
        AdditiveExpr:
          VarName:
            a
          '+'
          Literal:
            : asdf
Create Var this at idx: 0
AClass this
Create Var s at idx: 0
acdk.lang.String s
Create Var this at idx: 0
AClass this
acdk.lang.String s
Create Var a at idx: 0
Create Var s1 at idx: 1
Code already postParsed: VarName: a
Code already postParsed: Literal: 
CodeText:
 SymbolTable: [
  AClass a
  acdk.lang.String s1
 ]
  Statement:
    ClassDeclDef:(AClass=AClass)
     SymbolTable: [
      AClass this
      acdk.lang.String s
     ]
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:Sem=[AClass=void]
        MethodName:
          AClass
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        ClassDeclConstructorInitializerList:(AClass=AClass)
         SymbolTable: [
          AClass this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
      ClassDeclOperator:Sem=[operator_pl=acdk.lang.String]
        ReturnType:
          FqTypeName:
            
        Operator:
          +
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
          acdk.lang.String s
         ]
          Parameter:Sem=[s=acdk.lang.String]
            FqTypeName:
              
            VarName:
              s
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
            acdk.lang.String s
           ]
            Statement:
              ReturnStatement:
                Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  : AClass String
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      ExprStatement:
        AssignmentExpr:Sem=[a=AClass] ExprSem=[a=AClass]
          VarName:Sem=[a=AClass] ExprSem=[a=AClass]
            a
          '='
          NewExpr:Sem=[AClass=AClass]
            FqTypeName:
              
            Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s1
      ExprStatement:
        AssignmentExpr:Sem=[s1=acdk.lang.String] ExprSem=[s1=acdk.lang.String]
          VarName:Sem=[s1=acdk.lang.String] ExprSem=[s1=acdk.lang.String]
            s1
          '='
          SubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
            VarName:Sem=[a=AClass] ExprSem=[a=AClass]
              a
            MemberSubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              '.'
              SubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                VarName:Sem=[operator_pl=acdk.lang.String] ExprSem=[operator_pl=acdk.lang.String]
                  operator_pl
                FuncSubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  Arguments:
                    Argument:Sem=[acdk.lang.String=acdk.lang.String]
                      Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                        : asdf
  Statement:
    ExprStatement:
      AssignmentExpr:Sem=[s1=acdk.lang.String] ExprSem=[s1=acdk.lang.String]
        VarName:Sem=[s1=acdk.lang.String] ExprSem=[s1=acdk.lang.String]
          s1
        '='
        SubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
          VarName:Sem=[a=AClass] ExprSem=[a=AClass]
            a
          MemberSubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
            '.'
            SubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              VarName:Sem=[operator_pl=acdk.lang.String] ExprSem=[operator_pl=acdk.lang.String]
                operator_pl
              FuncSubscribeExpr:Sem=[operator_pl=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                Arguments:
                  Argument:Sem=[acdk.lang.String=acdk.lang.String]
                    Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                      : asdf
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
ret  // return statement
Function operator_pl[
__method_start: nop // 
push "AClass String" // Terminal
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // a
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // a
assign
pop // discarge expression result for ExprStatement
clvr 1 // s1
push Nil // initialize local value
store 1 // initialize local value
load 0 // a
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 2064837126 // function name: _1_operator_pl
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
loadref 1 // s1
assign
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar2 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 2064837126 // function name: _1_operator_pl
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
loadref 1 // s1
assign
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // a
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // a
9: assign
10: pop // discarge expression result for ExprStatement
11: clvr 1 // s1
12: push Nil // initialize local value
13: store 1 // initialize local value
14: load 0 // a
15: clvr 2 // ClassName or object instance
16: store 2
17: push "asdf" // Terminal
18: load 2 // ClassName or object instance
19: push 2064837126 // function name: _1_operator_pl
20: push 4362076176 // dmi flags = PUBLIC, argcount = 1
21: hash_invoke
22: loadref 1 // s1
23: assign
24: pop // discarge expression result for ExprStatement
25: load 0 // a
26: clvr 3 // ClassName or object instance
27: store 3
28: push "asdf" // Terminal
29: load 3 // ClassName or object instance
30: push 2064837126 // function name: _1_operator_pl
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
32: hash_invoke
33: loadref 1 // s1
34: assign
35: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // a
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // a
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: clvr 1 // s1
   Stack: 
12: push Nil // initialize local value
   Stack: Nil | 
13: store 1 // initialize local value
   Stack: 
14: load 0 // a
   Stack: AClass | 
15: clvr 2 // ClassName or object instance
   Stack: AClass | 
16: store 2
   Stack: 
17: push "asdf" // Terminal
   Stack: asdf | 
18: load 2 // ClassName or object instance
   Stack: asdf | AClass | 
19: push 2064837126 // function name: _1_operator_pl
   Stack: asdf | AClass | 2064837126 | 
20: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | AClass | 2064837126 | 4362076176 | 
21: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "AClass String" // Terminal
   Stack: AClass String | 
2: ret  // return statement
   Stack: AClass String | 
22: loadref 1 // s1
   Stack: AClass String | &Nil | 
23: assign
   Stack: AClass String | 
24: pop // discarge expression result for ExprStatement
   Stack: 
25: load 0 // a
   Stack: AClass | 
26: clvr 3 // ClassName or object instance
   Stack: AClass | 
27: store 3
   Stack: 
28: push "asdf" // Terminal
   Stack: asdf | 
29: load 3 // ClassName or object instance
   Stack: asdf | AClass | 
30: push 2064837126 // function name: _1_operator_pl
   Stack: asdf | AClass | 2064837126 | 
31: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: asdf | AClass | 2064837126 | 4362076176 | 
32: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "AClass String" // Terminal
   Stack: AClass String | 
2: ret  // return statement
   Stack: AClass String | 
33: loadref 1 // s1
   Stack: AClass String | &AClass String | 
34: assign
   Stack: AClass String | 
35: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Interpret_Test.derivedClass">Interpret_Test.derivedClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 0,58: Cannot find matching function  in AClass<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::CodeException::CodeException (acdk_aal_d.dll)
  called in acdk::aal::FuncSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::Block::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::ClassDeclMethod::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::ClassDeclDef::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in tests::acdk::aal::parseTreeInterpret (acdk_aal_Test_d.exe)
  called in tests::acdk::aal::Interpret_Test::derivedClass (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::Interpret_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.classOperator] End Test
[AUNIT:STRT][Interpret_Test.derivedClass] Start Test
Parsed: [class AClass { protected AClass() { this.print(); print(); } public void print() { acdk.lang.System.out.println("Call AClass.print "); } }
class BClass extends AClass { public BClass() { } }
BClass bcls = new BClass();
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'protected'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    this
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        print
                      FuncSubscribeExpr:
                        Arguments:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    print
                  FuncSubscribeExpr:
                    Arguments:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          print
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    acdk
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        lang
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            System
                          MemberSubscribeExpr:
                            '.'
                            SubscribeExpr:
                              VarName:
                                out
                              MemberSubscribeExpr:
                                '.'
                                SubscribeExpr:
                                  VarName:
                                    println
                                  FuncSubscribeExpr:
                                    Arguments:
                                      Argument:
                                        Literal:
                                          : Call AClass.print 
  Statement:
    ClassDeclDef:
      TypeName:
        BClass
      DerivedDef:
        DerivedSuperDef:
          FqTypeName:
            
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          BClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        bcls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
Create Var this at idx: 0
AClass this
Create Var this at idx: 0
AClass this
[AUNIT:ERRR][Interpret_Test.derivedClass] Error in Test: Interpret_Test.derivedClass: 0,58: Cannot find matching function  in AClass
</pre>
<h2><a id="Interpret_Test.interfaceClass">Interpret_Test.interfaceClass</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.derivedClass] End Test
[AUNIT:STRT][Interpret_Test.interfaceClass] Start Test
Parsed: [interface AInterface { AInterface() {} void foo(); }
class AClass implements AInterface { AClass() {} void foo() { acdk.lang.System.out.println("Hello from InterfaceImplemenation"); } }
AInterface iface = new AClass();
iface->foo();
] to
CodeText:
  Statement:
    InterfaceDeclDef:
      TypeName:
        AInterface
      InterfaceDerivedDef:
      ClassDeclConstructor:
        MethodName:
          AInterface
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        ';'
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
          FqTypeName:
            
      ClassDeclConstructor:
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    acdk
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        lang
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            System
                          MemberSubscribeExpr:
                            '.'
                            SubscribeExpr:
                              VarName:
                                out
                              MemberSubscribeExpr:
                                '.'
                                SubscribeExpr:
                                  VarName:
                                    println
                                  FuncSubscribeExpr:
                                    Arguments:
                                      Argument:
                                        Literal:
                                          : Hello from InterfaceImplemenation
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        iface
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          iface
        MemberSubscribeExpr:
          '->'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
Create Var this at idx: 0
AInterface this
Create Var this at idx: 0
AInterface this
Create Var this at idx: 0
AClass this
Create Var this at idx: 0
AClass this
ClassDeclConstructorInitializer:
  FqTypeName:
    
  Arguments:
Create Var iface at idx: 0
CodeText:
 SymbolTable: [
  AInterface iface
 ]
  Statement:
    InterfaceDeclDef:(AInterface=AInterface)
     SymbolTable: [
      AInterface this
     ]
      TypeName:
        AInterface
      InterfaceDerivedDef:
      ClassDeclConstructor:Sem=[AInterface=void]
        MethodName:
          AInterface
        FunctionParamsDecl:
         SymbolTable: [
          AInterface this
         ]
        ClassDeclConstructorInitializerList:(AInterface=AInterface)
         SymbolTable: [
          AInterface this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AInterface this
           ]
      ClassDeclMethod:Sem=[foo=void]
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          AInterface this
         ]
        ';'
  Statement:
    ClassDeclDef:(AClass=AClass)
     SymbolTable: [
      AClass this
     ]
      TypeName:
        AClass
      DerivedDef:
        DerivedInterfaceDef:
         SymbolTable: [
         ]
          FqTypeName:
            
      ClassDeclConstructor:Sem=[AClass=void]
        MethodName:
          AClass
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        ClassDeclConstructorInitializerList:(AClass=AClass)
         SymbolTable: [
          AClass this
         ]
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[AInterface=void]
              
            Arguments:
          ClassDeclConstructorInitializer:
            FqTypeName:Sem=[AInterface=void]
              
            Arguments:
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
      ClassDeclMethod:Sem=[foo=void]
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
            Statement:
              ExprStatement:
                SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                  VarName:Sem=[acdk=<no-type>] ExprSem=[acdk=<no-type>]
                    acdk
                  MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                    '.'
                    SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                      VarName:Sem=[acdk/lang=<no-type>] ExprSem=[acdk/lang=<no-type>]
                        lang
                      MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                        '.'
                        SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                          VarName:Sem=[acdk.lang.System=acdk.lang.System] ExprSem=[acdk.lang.System=acdk.lang.System]
                            System
                          MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                            '.'
                            SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                              VarName:Sem=[out=acdk.io.PrintWriter] ExprSem=[out=acdk.io.PrintWriter]
                                out
                              MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                                '.'
                                SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                                  VarName:Sem=[println=void] ExprSem=[println=void]
                                    println
                                  FuncSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                                    Arguments:
                                      Argument:Sem=[acdk.lang.String=acdk.lang.String]
                                        Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                          : Hello from InterfaceImplemenation
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        iface
      ExprStatement:
        AssignmentExpr:Sem=[iface=AInterface] ExprSem=[iface=AInterface]
          VarName:Sem=[iface=AInterface] ExprSem=[iface=AInterface]
            iface
          '='
          NewExpr:Sem=[AClass=AClass]
            FqTypeName:
              
            Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[foo=void] ExprSem=[acdk.lang.dmi.DmiObject=acdk.lang.dmi.DmiObject]
        VarName:Sem=[iface=AInterface] ExprSem=[iface=AInterface]
          iface
        MemberSubscribeExpr:Sem=[foo=void] ExprSem=[acdk.lang.dmi.DmiObject=acdk.lang.dmi.DmiObject]
          '->'
          SubscribeExpr:Sem=[foo=void] ExprSem=[acdk.lang.dmi.DmiObject=acdk.lang.dmi.DmiObject]
            VarName:Sem=[foo=void] ExprSem=[foo=void]
              foo
            FuncSubscribeExpr:Sem=[foo=void] ExprSem=[acdk.lang.dmi.DmiObject=acdk.lang.dmi.DmiObject]
              Arguments:
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AInterface[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
Function foo[
]
push "AInterface" // class name to initialize
init_clazz // 
load 0 // this
push "AInterface" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "AInterface" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
load 0 // this
push "AInterface" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
load 0 // this
push "AInterface" // function name
push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
invoke
pop // remove invoke result
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
push <undefined> // void return
ret  // 
Function foo[
__method_start: nop // 
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
clvr 1 // ClassName or object instance
store 1
push "Hello from InterfaceImplemenation" // Terminal
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
push <undefined> // void return
ret  // 
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // iface
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // iface
assign
pop // discarge expression result for ExprStatement
load 0 // iface
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push "foo" // function name
push 1048592 // dmi flags = PUBLIC, argcount = 0
invoke
pop // discarge expression result for ExprStatement
0: push "AInterface" // class name to initialize
1: init_clazz // 
2: push "AClass" // class name to initialize
3: init_clazz // 
4: clvr 0 // iface
5: push Nil // initialize local value
6: store 0 // initialize local value
7: push "AClass" // class name
8: push 0 // dmi flags = 0, argcount = 0
9: new
10: loadref 0 // iface
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // iface
14: clvr 1 // ClassName or object instance
15: store 1
16: load 1 // ClassName or object instance
17: push "foo" // function name
18: push 1048592 // dmi flags = PUBLIC, argcount = 0
19: invoke
20: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AInterface" // class name to initialize
   Stack: AInterface | 
1: init_clazz // 
   Stack: 
2: push "AClass" // class name to initialize
   Stack: AClass | 
3: init_clazz // 
   Stack: 
4: clvr 0 // iface
   Stack: 
5: push Nil // initialize local value
   Stack: Nil | 
6: store 0 // initialize local value
   Stack: 
7: push "AClass" // class name
   Stack: AClass | 
8: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
9: new
   Stack: 
0: load 0 // this
   Stack: AClass | 
1: push "AInterface" // function name
   Stack: AClass | AInterface | 
2: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: AClass | AInterface | 2097216 | 
3: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
4: pop // remove invoke result
   Stack: 
5: load 0 // this
   Stack: AClass | 
6: push "AInterface" // function name
   Stack: AClass | AInterface | 
7: push 2097216 // flags = TRANSIENT | PROTECTED, argcount = 0
   Stack: AClass | AInterface | 2097216 | 
8: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: Nil | 
9: pop // remove invoke result
   Stack: 
10: __method_start: nop // 
   Stack: 
11: push <undefined> // void return
   Stack: Nil | 
12: ret  // 
   Stack: AClass | 
10: loadref 0 // iface
   Stack: AClass | &Nil | 
11: assign
   Stack: AClass | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // iface
   Stack: AClass | 
14: clvr 1 // ClassName or object instance
   Stack: AClass | 
15: store 1
   Stack: 
16: load 1 // ClassName or object instance
   Stack: AClass | 
17: push "foo" // function name
   Stack: AClass | foo | 
18: push 1048592 // dmi flags = PUBLIC, argcount = 0
   Stack: AClass | foo | 1048592 | 
19: invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
2: push "out" // fieldname
   Stack: acdk.lang.System | out | 
3: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
4: peek_static
   Stack: acdk/io/PrintWriter | 
5: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
6: store 1
   Stack: 
7: push "Hello from InterfaceImplemenation" // Terminal
   Stack: Hello from InterfaceImplemenation | 
8: load 1 // ClassName or object instance
   Stack: Hello from InterfaceImplemenation | acdk/io/PrintWriter | 
9: push 998516684 // function name: _t_println
   Stack: Hello from InterfaceImplemenation | acdk/io/PrintWriter | 998516684 | 
10: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: Hello from InterfaceImplemenation | acdk/io/PrintWriter | 998516684 | 4362076176 | 
11: hash_invoke
Hello from InterfaceImplemenation
   Stack: Nil | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: push <undefined> // void return
   Stack: Nil | 
14: ret  // 
   Stack: Nil | 
20: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="LiteralWrapping_Test.wrappedStrings">LiteralWrapping_Test.wrappedStrings</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Interpret_Test.interfaceClass] End Test
[AUNIT:STRT][LiteralWrapping_Test.wrappedStrings] Start Test
Parsed: [int i = "Text".length();
__assert(i == 4, "string literal object wrapper");
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        SubscribeExpr:
          Literal:
            : Text
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                length
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : string literal object wrapper
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          SubscribeExpr:Sem=[length=int] ExprSem=[int=int]
            Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              : Text
            MemberSubscribeExpr:Sem=[length=int] ExprSem=[int=int]
              '.'
              SubscribeExpr:Sem=[length=int] ExprSem=[int=int]
                VarName:Sem=[length=int] ExprSem=[length=int]
                  length
                FuncSubscribeExpr:Sem=[length=int] ExprSem=[int=int]
                  Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr: ExprSem=[bool=bool]
        VarName:
          __assert
        FuncSubscribeExpr: ExprSem=[bool=bool]
          Arguments:
            ArgumentList:
              Argument:Sem=[bool=bool]
                EqualityExpr:Sem=[bool=bool]
                  VarName:Sem=[i=int] ExprSem=[i=int]
                    i
                  '=='
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 4
              Argument:Sem=[acdk.lang.String=acdk.lang.String]
                Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  : string literal object wrapper
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 62464505 // function name: _z_length
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push "Text" // Terminal
4: clvr 1 // ClassName or object instance
5: store 1
6: load 1 // ClassName or object instance
7: push 62464505 // function name: _z_length
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke
10: loadref 0 // i
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // i
14: push 4 // Terminal
15: eq
16: push "string literal object wrapper" // Terminal
17: assert
18: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push "Text" // Terminal
   Stack: Text | 
4: clvr 1 // ClassName or object instance
   Stack: Text | 
5: store 1
   Stack: 
6: load 1 // ClassName or object instance
   Stack: Text | 
7: push 62464505 // function name: _z_length
   Stack: Text | 62464505 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: Text | 62464505 | 67108880 | 
9: hash_invoke
   Stack: 4 | 
10: loadref 0 // i
   Stack: 4 | &0 | 
11: assign
   Stack: 4 | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // i
   Stack: 4 | 
14: push 4 // Terminal
   Stack: 4 | 4 | 
15: eq
   Stack: true | 
16: push "string literal object wrapper" // Terminal
   Stack: true | string literal object wrapper | 
17: assert
   Stack: true | 
18: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="LiteralWrapping_Test.wrappedNumbers">LiteralWrapping_Test.wrappedNumbers</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][LiteralWrapping_Test.wrappedStrings] End Test
[AUNIT:STRT][LiteralWrapping_Test.wrappedNumbers] Start Test
Parsed: [acdk.lang.String s = 42.toString();
__assert(s.equals("42") == true, "string literal object wrapper");
int i = 41;
s = i.toString();
__assert(s.equals("41") == true, "string literal object wrapper");
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          Literal:
            : 42
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 42
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : string literal object wrapper
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 41
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            i
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      s
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              Literal:
                                : 41
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : string literal object wrapper
Create Var s at idx: 0
Create Var i at idx: 1
CodeText:
 SymbolTable: [
  acdk.lang.String s
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      ExprStatement:
        AssignmentExpr:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
          VarName:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
            s
          '='
          SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 42
            MemberSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              '.'
              SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                VarName:Sem=[toString=acdk.lang.String] ExprSem=[toString=acdk.lang.String]
                  toString
                FuncSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr: ExprSem=[bool=bool]
        VarName:
          __assert
        FuncSubscribeExpr: ExprSem=[bool=bool]
          Arguments:
            ArgumentList:
              Argument:Sem=[bool=bool]
                EqualityExpr:Sem=[bool=bool]
                  SubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                    VarName:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
                      s
                    MemberSubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                      '.'
                      SubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                        VarName:Sem=[equals=bool] ExprSem=[equals=bool]
                          equals
                        FuncSubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                          Arguments:
                            Argument:Sem=[acdk.lang.String=acdk.lang.String]
                              Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                : 42
                  '=='
                  Literal:Sem=[bool=bool] ExprSem=[bool=bool]
                    BOOLEAN_LITERAL:Sem=[bool=bool] ExprSem=[bool=bool]
                      'true'
              Argument:Sem=[acdk.lang.String=acdk.lang.String]
                Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  : string literal object wrapper
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 41
  Statement:
    ExprStatement:
      AssignmentExpr:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
        VarName:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
          s
        '='
        SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          MemberSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
            '.'
            SubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
              VarName:Sem=[toString=acdk.lang.String] ExprSem=[toString=acdk.lang.String]
                toString
              FuncSubscribeExpr:Sem=[toString=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr: ExprSem=[bool=bool]
        VarName:
          __assert
        FuncSubscribeExpr: ExprSem=[bool=bool]
          Arguments:
            ArgumentList:
              Argument:Sem=[bool=bool]
                EqualityExpr:Sem=[bool=bool]
                  SubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                    VarName:Sem=[s=acdk.lang.String] ExprSem=[s=acdk.lang.String]
                      s
                    MemberSubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                      '.'
                      SubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                        VarName:Sem=[equals=bool] ExprSem=[equals=bool]
                          equals
                        FuncSubscribeExpr:Sem=[equals=bool] ExprSem=[bool=bool]
                          Arguments:
                            Argument:Sem=[acdk.lang.String=acdk.lang.String]
                              Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                                : 41
                  '=='
                  Literal:Sem=[bool=bool] ExprSem=[bool=bool]
                    BOOLEAN_LITERAL:Sem=[bool=bool] ExprSem=[bool=bool]
                      'true'
              Argument:Sem=[acdk.lang.String=acdk.lang.String]
                Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
                  : string literal object wrapper
clvr 0 // s
push Nil // initialize local value
store 0 // initialize local value
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 749992755 // function name: _a_toString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
loadref 0 // s
assign
pop // discarge expression result for ExprStatement
load 0 // s
Create Var __tvar2 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
push true // true
eq
assert
pop // discarge expression result for ExprStatement
clvr 1 // i
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // i
assign
pop // discarge expression result for ExprStatement
load 1 // i
Create Var __tvar3 at idx: 4
clvr 4 // ClassName or object instance
store 4
load 4 // ClassName or object instance
push 749992755 // function name: _a_toString
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
loadref 0 // s
assign
pop // discarge expression result for ExprStatement
load 0 // s
Create Var __tvar4 at idx: 5
clvr 5 // ClassName or object instance
store 5
load 5 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
push true // true
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // s
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 42 // Terminal
4: clvr 2 // ClassName or object instance
5: store 2
6: load 2 // ClassName or object instance
7: push 749992755 // function name: _a_toString
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
9: hash_invoke
10: loadref 0 // s
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // s
14: clvr 3 // ClassName or object instance
15: store 3
16: push "42" // Terminal
17: load 3 // ClassName or object instance
18: push 659573500 // function name: _u_equals
19: push 4362076176 // dmi flags = PUBLIC, argcount = 1
20: hash_invoke
21: push true // true
22: eq
23: push "string literal object wrapper" // Terminal
24: assert
25: pop // discarge expression result for ExprStatement
26: clvr 1 // i
27: push 0 // initialize local value
28: store 1 // initialize local value
29: push 41 // Terminal
30: loadref 1 // i
31: assign
32: pop // discarge expression result for ExprStatement
33: load 1 // i
34: clvr 4 // ClassName or object instance
35: store 4
36: load 4 // ClassName or object instance
37: push 749992755 // function name: _a_toString
38: push 67108880 // dmi flags = PUBLIC, argcount = 0
39: hash_invoke
40: loadref 0 // s
41: assign
42: pop // discarge expression result for ExprStatement
43: load 0 // s
44: clvr 5 // ClassName or object instance
45: store 5
46: push "41" // Terminal
47: load 5 // ClassName or object instance
48: push 659573500 // function name: _u_equals
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
50: hash_invoke
51: push true // true
52: eq
53: push "string literal object wrapper" // Terminal
54: assert
55: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // s
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 42 // Terminal
   Stack: 42 | 
4: clvr 2 // ClassName or object instance
   Stack: 42 | 
5: store 2
   Stack: 
6: load 2 // ClassName or object instance
   Stack: 42 | 
7: push 749992755 // function name: _a_toString
   Stack: 42 | 749992755 | 
8: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: 42 | 749992755 | 67108880 | 
9: hash_invoke
   Stack: 42 | 
10: loadref 0 // s
   Stack: 42 | &Nil | 
11: assign
   Stack: 42 | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // s
   Stack: 42 | 
14: clvr 3 // ClassName or object instance
   Stack: 42 | 
15: store 3
   Stack: 
16: push "42" // Terminal
   Stack: 42 | 
17: load 3 // ClassName or object instance
   Stack: 42 | 42 | 
18: push 659573500 // function name: _u_equals
   Stack: 42 | 42 | 659573500 | 
19: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | 42 | 659573500 | 4362076176 | 
20: hash_invoke
   Stack: true | 
21: push true // true
   Stack: true | true | 
22: eq
   Stack: true | 
23: push "string literal object wrapper" // Terminal
   Stack: true | string literal object wrapper | 
24: assert
   Stack: true | 
25: pop // discarge expression result for ExprStatement
   Stack: 
26: clvr 1 // i
   Stack: 
27: push 0 // initialize local value
   Stack: 0 | 
28: store 1 // initialize local value
   Stack: 
29: push 41 // Terminal
   Stack: 41 | 
30: loadref 1 // i
   Stack: 41 | &0 | 
31: assign
   Stack: 41 | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: load 1 // i
   Stack: 41 | 
34: clvr 4 // ClassName or object instance
   Stack: 41 | 
35: store 4
   Stack: 
36: load 4 // ClassName or object instance
   Stack: 41 | 
37: push 749992755 // function name: _a_toString
   Stack: 41 | 749992755 | 
38: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: 41 | 749992755 | 67108880 | 
39: hash_invoke
   Stack: 41 | 
40: loadref 0 // s
   Stack: 41 | &42 | 
41: assign
   Stack: 41 | 
42: pop // discarge expression result for ExprStatement
   Stack: 
43: load 0 // s
   Stack: 41 | 
44: clvr 5 // ClassName or object instance
   Stack: 41 | 
45: store 5
   Stack: 
46: push "41" // Terminal
   Stack: 41 | 
47: load 5 // ClassName or object instance
   Stack: 41 | 41 | 
48: push 659573500 // function name: _u_equals
   Stack: 41 | 41 | 659573500 | 
49: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 41 | 41 | 659573500 | 4362076176 | 
50: hash_invoke
   Stack: true | 
51: push true // true
   Stack: true | true | 
52: eq
   Stack: true | 
53: push "string literal object wrapper" // Terminal
   Stack: true | string literal object wrapper | 
54: assert
   Stack: true | 
55: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="LogicalExpr_Test.basicRels">LogicalExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][LiteralWrapping_Test.wrappedNumbers] End Test
[AUNIT:STRT][LogicalExpr_Test.basicRels] Start Test
Parsed: [false && __assert(false, "should never reached");
true || __assert(false, "should never reached");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      LogicalANDExpr:
        Literal:
          BOOLEAN_LITERAL:
            'false'
        '&&'
        SubscribeExpr:
          VarName:
            __assert
          FuncSubscribeExpr:
            Arguments:
              ArgumentList:
                Argument:
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
                Argument:
                  Literal:
                    : should never reached
  Statement:
    ExprStatement:
      LogicalORExpr:
        Literal:
          BOOLEAN_LITERAL:
            'true'
        '||'
        SubscribeExpr:
          VarName:
            __assert
          FuncSubscribeExpr:
            Arguments:
              ArgumentList:
                Argument:
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
                Argument:
                  Literal:
                    : should never reached
push false // false
dup // safe lh expr result
brfalse logexprend1 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend1: nop // 
pop // discarge expression result for ExprStatement
push true // true
dup // safe lh expr result
brtrue logexprend2 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend2: nop // 
pop // discarge expression result for ExprStatement
0: push false // false
1: dup // safe lh expr result
2: brfalse logexprend1 // bool short-circuit
3: pop // remove lh expr result
4: push false // false
5: push "should never reached" // Terminal
6: assert
7: logexprend1: nop // 
8: pop // discarge expression result for ExprStatement
9: push true // true
10: dup // safe lh expr result
11: brtrue logexprend2 // bool short-circuit
12: pop // remove lh expr result
13: push false // false
14: push "should never reached" // Terminal
15: assert
16: logexprend2: nop // 
17: pop // discarge expression result for ExprStatement
   Stack: 
0: push false // false
   Stack: false | 
1: dup // safe lh expr result
   Stack: false | false | 
2: brfalse logexprend1 // bool short-circuit
   Stack: false | 
8: pop // discarge expression result for ExprStatement
   Stack: 
9: push true // true
   Stack: true | 
10: dup // safe lh expr result
   Stack: true | true | 
11: brtrue logexprend2 // bool short-circuit
   Stack: true | 
17: pop // discarge expression result for ExprStatement
Parsed: [42 == 42 && 41 > 42 && __assert(false, "should never reached");
42 == 41 && 41 > 42 && __assert(false, "should never reached");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      LogicalANDExpr:
        EqualityExpr:
          Literal:
            : 42
          '=='
          Literal:
            : 42
        '&&'
        LogicalANDExpr:
          RelationalExpr:
            Literal:
              : 41
            '>'
            Literal:
              : 42
          '&&'
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      BOOLEAN_LITERAL:
                        'false'
                  Argument:
                    Literal:
                      : should never reached
  Statement:
    ExprStatement:
      LogicalANDExpr:
        EqualityExpr:
          Literal:
            : 42
          '=='
          Literal:
            : 41
        '&&'
        LogicalANDExpr:
          RelationalExpr:
            Literal:
              : 41
            '>'
            Literal:
              : 42
          '&&'
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      BOOLEAN_LITERAL:
                        'false'
                  Argument:
                    Literal:
                      : should never reached
eq
dup // safe lh expr result
brfalse logexprend3 // bool short-circuit
pop // remove lh expr result
gt
dup // safe lh expr result
brfalse logexprend4 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend4: nop // 
logexprend3: nop // 
pop // discarge expression result for ExprStatement
eq
dup // safe lh expr result
brfalse logexprend5 // bool short-circuit
pop // remove lh expr result
gt
dup // safe lh expr result
brfalse logexprend6 // bool short-circuit
pop // remove lh expr result
push false // false
assert
logexprend6: nop // 
logexprend5: nop // 
pop // discarge expression result for ExprStatement
0: push 42 // Terminal
1: push 42 // Terminal
2: eq
3: dup // safe lh expr result
4: brfalse logexprend3 // bool short-circuit
5: pop // remove lh expr result
6: push 41 // Terminal
7: push 42 // Terminal
8: gt
9: dup // safe lh expr result
10: brfalse logexprend4 // bool short-circuit
11: pop // remove lh expr result
12: push false // false
13: push "should never reached" // Terminal
14: assert
15: logexprend4: nop // 
16: logexprend3: nop // 
17: pop // discarge expression result for ExprStatement
18: push 42 // Terminal
19: push 41 // Terminal
20: eq
21: dup // safe lh expr result
22: brfalse logexprend5 // bool short-circuit
23: pop // remove lh expr result
24: push 41 // Terminal
25: push 42 // Terminal
26: gt
27: dup // safe lh expr result
28: brfalse logexprend6 // bool short-circuit
29: pop // remove lh expr result
30: push false // false
31: push "should never reached" // Terminal
32: assert
33: logexprend6: nop // 
34: logexprend5: nop // 
35: pop // discarge expression result for ExprStatement
   Stack: 
0: push 42 // Terminal
   Stack: 42 | 
1: push 42 // Terminal
   Stack: 42 | 42 | 
2: eq
   Stack: true | 
3: dup // safe lh expr result
   Stack: true | true | 
4: brfalse logexprend3 // bool short-circuit
   Stack: true | 
5: pop // remove lh expr result
   Stack: 
6: push 41 // Terminal
   Stack: 41 | 
7: push 42 // Terminal
   Stack: 41 | 42 | 
8: gt
   Stack: false | 
9: dup // safe lh expr result
   Stack: false | false | 
10: brfalse logexprend4 // bool short-circuit
   Stack: false | 
16: logexprend3: nop // 
   Stack: false | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: push 42 // Terminal
   Stack: 42 | 
19: push 41 // Terminal
   Stack: 42 | 41 | 
20: eq
   Stack: false | 
21: dup // safe lh expr result
   Stack: false | false | 
22: brfalse logexprend5 // bool short-circuit
   Stack: false | 
35: pop // discarge expression result for ExprStatement
Parsed: [__assert(! false, "not does not work");
__assert(! (41 == 42), "not does not work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                PrefixExpr:
                  '!'
                  Literal:
                    BOOLEAN_LITERAL:
                      'false'
              Argument:
                Literal:
                  : not does not work
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                PrefixExpr:
                  '!'
                  EqualityExpr:
                    Literal:
                      : 41
                    '=='
                    Literal:
                      : 42
              Argument:
                Literal:
                  : not does not work
push false // false
not // negation
assert
pop // discarge expression result for ExprStatement
eq
not // negation
assert
pop // discarge expression result for ExprStatement
0: push false // false
1: not // negation
2: push "not does not work" // Terminal
3: assert
4: pop // discarge expression result for ExprStatement
5: push 41 // Terminal
6: push 42 // Terminal
7: eq
8: not // negation
9: push "not does not work" // Terminal
10: assert
11: pop // discarge expression result for ExprStatement
   Stack: 
0: push false // false
   Stack: false | 
1: not // negation
   Stack: true | 
2: push "not does not work" // Terminal
   Stack: true | not does not work | 
3: assert
   Stack: true | 
4: pop // discarge expression result for ExprStatement
   Stack: 
5: push 41 // Terminal
   Stack: 41 | 
6: push 42 // Terminal
   Stack: 41 | 42 | 
7: eq
   Stack: false | 
8: not // negation
   Stack: true | 
9: push "not does not work" // Terminal
   Stack: true | not does not work | 
10: assert
   Stack: true | 
11: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="LogicalExpr_Test.operatorRels">LogicalExpr_Test.operatorRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][LogicalExpr_Test.basicRels] End Test
[AUNIT:STRT][LogicalExpr_Test.operatorRels] Start Test
</pre>
<h2><a id="Operator_Test.plusOperator">Operator_Test.plusOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][LogicalExpr_Test.operatorRels] End Test
[AUNIT:STRT][Operator_Test.plusOperator] Start Test
Parsed: [using acdk.lang;
String s = "A";
String e = s + "B";
__assert(e.equals("AB"), "Plus operator on strings failed");
__assert("A" + "B" === "AB", "Plus operator on strings failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        Literal:
          : A
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        e
      VarInitializer:
        AdditiveExpr:
          VarName:
            s
          '+'
          Literal:
            : B
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                SubscribeExpr:
                  VarName:
                    e
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        equals
                      FuncSubscribeExpr:
                        Arguments:
                          Argument:
                            Literal:
                              : AB
              Argument:
                Literal:
                  : Plus operator on strings failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  AdditiveExpr:
                    Literal:
                      : A
                    '+'
                    Literal:
                      : B
                  '==='
                  Literal:
                    : AB
              Argument:
                Literal:
                  : Plus operator on strings failed
Create Var s at idx: 0
Create Var e at idx: 1
Code already postParsed: VarName: s
Code already postParsed: Literal: 
Code already postParsed: Literal: 
Code already postParsed: Literal: 
Code already postParsed: Literal: 
Code already postParsed: MemberSubscribeExpr: 
Code already postParsed: Keyword: 
Code already postParsed: Literal: 
Code already postParsed: SubscribeExpr: 
Code already postParsed: Literal: 
clvr 0 // s
push Nil // initialize local value
store 0 // initialize local value
loadref 0 // s
assign
pop // discarge expression result for ExprStatement
clvr 1 // e
push Nil // initialize local value
store 1 // initialize local value
load 0 // s
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 2064837188 // function name: _1D_operator_pl
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
loadref 1 // e
assign
pop // discarge expression result for ExprStatement
load 1 // e
Create Var __tvar2 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
Create Var __tvar3 at idx: 4
clvr 4 // ClassName or object instance
store 4
load 4 // ClassName or object instance
push 2064837188 // function name: _1D_operator_pl
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
Create Var __tvar4 at idx: 5
clvr 5 // ClassName or object instance
store 5
load 5 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // s
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push "A" // Terminal
4: loadref 0 // s
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // e
8: push Nil // initialize local value
9: store 1 // initialize local value
10: load 0 // s
11: clvr 2 // ClassName or object instance
12: store 2
13: push "B" // Terminal
14: load 2 // ClassName or object instance
15: push 2064837188 // function name: _1D_operator_pl
16: push 4362076176 // dmi flags = PUBLIC, argcount = 1
17: hash_invoke
18: loadref 1 // e
19: assign
20: pop // discarge expression result for ExprStatement
21: load 1 // e
22: clvr 3 // ClassName or object instance
23: store 3
24: push "AB" // Terminal
25: load 3 // ClassName or object instance
26: push 659573500 // function name: _u_equals
27: push 4362076176 // dmi flags = PUBLIC, argcount = 1
28: hash_invoke
29: push "Plus operator on strings failed" // Terminal
30: assert
31: pop // discarge expression result for ExprStatement
32: push "A" // Terminal
33: clvr 4 // ClassName or object instance
34: store 4
35: push "B" // Terminal
36: load 4 // ClassName or object instance
37: push 2064837188 // function name: _1D_operator_pl
38: push 4362076176 // dmi flags = PUBLIC, argcount = 1
39: hash_invoke
40: clvr 5 // ClassName or object instance
41: store 5
42: push "AB" // Terminal
43: load 5 // ClassName or object instance
44: push 659573500 // function name: _u_equals
45: push 4362076176 // dmi flags = PUBLIC, argcount = 1
46: hash_invoke
47: push "Plus operator on strings failed" // Terminal
48: assert
49: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // s
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push "A" // Terminal
   Stack: A | 
4: loadref 0 // s
   Stack: A | &Nil | 
5: assign
   Stack: A | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // e
   Stack: 
8: push Nil // initialize local value
   Stack: Nil | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // s
   Stack: A | 
11: clvr 2 // ClassName or object instance
   Stack: A | 
12: store 2
   Stack: 
13: push "B" // Terminal
   Stack: B | 
14: load 2 // ClassName or object instance
   Stack: B | A | 
15: push 2064837188 // function name: _1D_operator_pl
   Stack: B | A | 2064837188 | 
16: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: B | A | 2064837188 | 4362076176 | 
17: hash_invoke
   Stack: AB | 
18: loadref 1 // e
   Stack: AB | &Nil | 
19: assign
   Stack: AB | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: load 1 // e
   Stack: AB | 
22: clvr 3 // ClassName or object instance
   Stack: AB | 
23: store 3
   Stack: 
24: push "AB" // Terminal
   Stack: AB | 
25: load 3 // ClassName or object instance
   Stack: AB | AB | 
26: push 659573500 // function name: _u_equals
   Stack: AB | AB | 659573500 | 
27: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: AB | AB | 659573500 | 4362076176 | 
28: hash_invoke
   Stack: true | 
29: push "Plus operator on strings failed" // Terminal
   Stack: true | Plus operator on strings failed | 
30: assert
   Stack: true | 
31: pop // discarge expression result for ExprStatement
   Stack: 
32: push "A" // Terminal
   Stack: A | 
33: clvr 4 // ClassName or object instance
   Stack: A | 
34: store 4
   Stack: 
35: push "B" // Terminal
   Stack: B | 
36: load 4 // ClassName or object instance
   Stack: B | A | 
37: push 2064837188 // function name: _1D_operator_pl
   Stack: B | A | 2064837188 | 
38: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: B | A | 2064837188 | 4362076176 | 
39: hash_invoke
   Stack: AB | 
40: clvr 5 // ClassName or object instance
   Stack: AB | 
41: store 5
   Stack: 
42: push "AB" // Terminal
   Stack: AB | 
43: load 5 // ClassName or object instance
   Stack: AB | AB | 
44: push 659573500 // function name: _u_equals
   Stack: AB | AB | 659573500 | 
45: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: AB | AB | 659573500 | 4362076176 | 
46: hash_invoke
   Stack: true | 
47: push "Plus operator on strings failed" // Terminal
   Stack: true | Plus operator on strings failed | 
48: assert
   Stack: true | 
49: pop // discarge expression result for ExprStatement
Parsed: [class AClass { public AClass() {} public int foo(int i) { return i; } public int operator+(int i) { return i + 2; } }
AClass acls = new AClass();
__assert(acls + 40 == 42, "Plus operator failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                VarName:
                  i
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          +
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 2
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        acls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  AdditiveExpr:
                    VarName:
                      acls
                    '+'
                    Literal:
                      : 40
                  '=='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : Plus operator failed
Create Var this at idx: 0
AClass this
Create Var i at idx: 0
int i
Create Var this at idx: 0
AClass this
int i
Create Var i at idx: 0
int i
Create Var this at idx: 0
AClass this
int i
Create Var acls at idx: 0
Code already postParsed: VarName: acls
Code already postParsed: Literal: 
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 1 // i
ret  // return statement
Function foo[
__method_start: nop // 
load 1 // i
ret  // return statement
]
__method_start: nop // 
load 1 // i
add
ret  // return statement
Function operator_pl[
__method_start: nop // 
load 1 // i
push 2 // Terminal
add
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // acls
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // acls
assign
pop // discarge expression result for ExprStatement
load 0 // acls
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push -99897512 // function name: _2_operator_pl
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
eq
assert
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // acls
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // acls
9: assign
10: pop // discarge expression result for ExprStatement
11: load 0 // acls
12: clvr 1 // ClassName or object instance
13: store 1
14: push 40 // Terminal
15: load 1 // ClassName or object instance
16: push -99897512 // function name: _2_operator_pl
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
18: hash_invoke
19: push 42 // Terminal
20: eq
21: push "Plus operator failed" // Terminal
22: assert
23: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // acls
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // acls
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: load 0 // acls
   Stack: AClass | 
12: clvr 1 // ClassName or object instance
   Stack: AClass | 
13: store 1
   Stack: 
14: push 40 // Terminal
   Stack: 40 | 
15: load 1 // ClassName or object instance
   Stack: 40 | AClass | 
16: push -99897512 // function name: _2_operator_pl
   Stack: 40 | AClass | -99897512 | 
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 40 | AClass | -99897512 | 4362076176 | 
18: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 1 // i
   Stack: 40 | 
2: push 2 // Terminal
   Stack: 40 | 2 | 
3: add
   Stack: 42 | 
4: ret  // return statement
   Stack: 42 | 
19: push 42 // Terminal
   Stack: 42 | 42 | 
20: eq
   Stack: true | 
21: push "Plus operator failed" // Terminal
   Stack: true | Plus operator failed | 
22: assert
   Stack: true | 
23: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Operator_Test.callOperator">Operator_Test.callOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Operator_Test.plusOperator] End Test
[AUNIT:STRT][Operator_Test.callOperator] Start Test
Parsed: [class AClass { public AClass() {} public static int operator()(int i) { return i + 2; } }
AClass.operator()(42);
AClass(42);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            
        Operator:
          ()
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          AClass
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            Operator:
              ()
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          AClass
        FuncSubscribeExpr:
          Arguments:
            Argument:
              Literal:
                : 42
Create Var this at idx: 0
AClass this
Create Var i at idx: 0
int i
Code already postParsed: Argument: 
CodeText:
 SymbolTable: [
 ]
  Statement:
    ClassDeclDef:(AClass=AClass)
     SymbolTable: [
      int i
     ]
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:Sem=[AClass=void]
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
         SymbolTable: [
          AClass this
         ]
        ClassDeclConstructorInitializerList:(AClass=AClass)
         SymbolTable: [
          AClass this
         ]
        FunctionBlock:
          Block:
           SymbolTable: [
            AClass this
           ]
      ClassDeclOperator:Sem=[operator_po_pc=int]
        ClassMemberAttr:
          'public'
          'static'
        ReturnType:
          FqTypeName:
            
        Operator:
          ()
        FunctionParamsDecl:
         SymbolTable: [
          int i
         ]
          Parameter:Sem=[i=int]
            FqTypeName:
              
            VarName:
              i
        FunctionBlock:
          Block:
           SymbolTable: [
            int i
           ]
            Statement:
              ReturnStatement:
                AdditiveExpr:Sem=[byte=byte]
                  VarName:Sem=[i=int] ExprSem=[i=int]
                    i
                  '+'
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 2
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
        VarName:Sem=[AClass=AClass] ExprSem=[AClass=AClass]
          AClass
        MemberSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
          '.'
          SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
            VarName:Sem=[operator_po_pc=int] ExprSem=[operator_po_pc=int]
              operator_po_pc
            FuncSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
              Arguments:
                Argument:Sem=[byte=byte]
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 42
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
        VarName:Sem=[AClass=AClass] ExprSem=[AClass=AClass]
          AClass
        MemberSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
          '.'
          SubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
            VarName:Sem=[operator_po_pc=int] ExprSem=[operator_po_pc=int]
              operator_po_pc
            FuncSubscribeExpr:Sem=[operator_po_pc=int] ExprSem=[int=int]
              Arguments:
                Argument:Sem=[byte=byte]
                  Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                    : 42
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 0 // i
add
ret  // return statement
Function operator_po_pc[
__method_start: nop // 
load 0 // i
push 2 // Terminal
add
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
push "AClass" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555235382 // function name: _1_operator_po_pc
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke_static
pop // discarge expression result for ExprStatement
push "AClass" // class name
Create Var __tvar2 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 1555235382 // function name: _1_operator_po_pc
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke_static
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: push "AClass" // class name
3: clvr 0 // ClassName or object instance
4: store 0
5: push 42 // Terminal
6: load 0 // ClassName or object instance
7: push 1555235382 // function name: _1_operator_po_pc
8: push 4362076176 // dmi flags = PUBLIC, argcount = 1
9: hash_invoke_static
10: pop // discarge expression result for ExprStatement
11: push "AClass" // class name
12: clvr 1 // ClassName or object instance
13: store 1
14: push 42 // Terminal
15: load 1 // ClassName or object instance
16: push 1555235382 // function name: _1_operator_po_pc
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
18: hash_invoke_static
19: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: push "AClass" // class name
   Stack: AClass | 
3: clvr 0 // ClassName or object instance
   Stack: AClass | 
4: store 0
   Stack: 
5: push 42 // Terminal
   Stack: 42 | 
6: load 0 // ClassName or object instance
   Stack: 42 | AClass | 
7: push 1555235382 // function name: _1_operator_po_pc
   Stack: 42 | AClass | 1555235382 | 
8: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | AClass | 1555235382 | 4362076176 | 
9: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 0 // i
   Stack: 42 | 
2: push 2 // Terminal
   Stack: 42 | 2 | 
3: add
   Stack: 44 | 
4: ret  // return statement
   Stack: 44 | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: push "AClass" // class name
   Stack: AClass | 
12: clvr 1 // ClassName or object instance
   Stack: AClass | 
13: store 1
   Stack: 
14: push 42 // Terminal
   Stack: 42 | 
15: load 1 // ClassName or object instance
   Stack: 42 | AClass | 
16: push 1555235382 // function name: _1_operator_po_pc
   Stack: 42 | AClass | 1555235382 | 
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | AClass | 1555235382 | 4362076176 | 
18: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: load 0 // i
   Stack: 42 | 
2: push 2 // Terminal
   Stack: 42 | 2 | 
3: add
   Stack: 44 | 
4: ret  // return statement
   Stack: 44 | 
19: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Operator_Test.arrayOperator">Operator_Test.arrayOperator</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Operator_Test.callOperator] End Test
[AUNIT:STRT][Operator_Test.arrayOperator] Start Test
Parsed: [using acdk.lang;
String[] sa = new String[](2);
sa[1] = "Hello";
System.out.println(sa[1]);
sa[1].length() == 5;
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        sa
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            sa
          ArraySubscribeExpr:
            Literal:
              : 1
        '='
        Literal:
          : Hello
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          System
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              out
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  println
                FuncSubscribeExpr:
                  Arguments:
                    Argument:
                      SubscribeExpr:
                        VarName:
                          sa
                        ArraySubscribeExpr:
                          Literal:
                            : 1
  Statement:
    ExprStatement:
      EqualityExpr:
        SubscribeExpr:
          VarName:
            sa
          ArraySubscribeExpr:
            Literal:
              : 1
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                length
              FuncSubscribeExpr:
                Arguments:
        '=='
        Literal:
          : 5
Create Var sa at idx: 0
CodeText:
 SymbolTable: [
  [acdk.lang.String sa
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        sa
      ExprStatement:
        AssignmentExpr:Sem=[sa=[acdk.lang.String] ExprSem=[sa=[acdk.lang.String]
          VarName:Sem=[sa=[acdk.lang.String] ExprSem=[sa=[acdk.lang.String]
            sa
          '='
          NewExpr:Sem=[[acdk.lang.String=[acdk.lang.String]
            FqTypeName:
              
            Arguments:
              Argument:Sem=[byte=byte]
                Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                  : 2
  Statement:
    ExprStatement:
      AssignmentExpr:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[byte=byte]
        SubscribeExpr:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[byte=byte]
          VarName:Sem=[sa=[acdk.lang.String] ExprSem=[sa=[acdk.lang.String]
            sa
          ArraySubscribeExpr:Sem=[acdk.lang.String=acdk.lang.String]
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 1
        '='
        Literal:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[acdk.lang.String=acdk.lang.String]
          : Hello
  Statement:
    ExprStatement:
      SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
        VarName:Sem=[acdk.lang.System=acdk.lang.System] ExprSem=[acdk.lang.System=acdk.lang.System]
          System
        MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
          '.'
          SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
            VarName:Sem=[out=acdk.io.PrintWriter] ExprSem=[out=acdk.io.PrintWriter]
              out
            MemberSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
              '.'
              SubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                VarName:Sem=[println=void] ExprSem=[println=void]
                  println
                FuncSubscribeExpr:Sem=[println=void] ExprSem=[void=void]
                  Arguments:
                    Argument:Sem=[acdk.lang.String=acdk.lang.String]
                      SubscribeExpr:Sem=[acdk.lang.String=acdk.lang.String] ExprSem=[byte=byte]
                        VarName:Sem=[sa=[acdk.lang.String] ExprSem=[sa=[acdk.lang.String]
                          sa
                        ArraySubscribeExpr:Sem=[acdk.lang.String=acdk.lang.String]
                          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                            : 1
  Statement:
    ExprStatement:
      EqualityExpr:Sem=[bool=bool]
        SubscribeExpr:Sem=[length=int] ExprSem=[int=int]
          VarName:Sem=[sa=[acdk.lang.String] ExprSem=[sa=[acdk.lang.String]
            sa
          ArraySubscribeExpr:Sem=[acdk.lang.String=acdk.lang.String]
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 1
          MemberSubscribeExpr:Sem=[length=int] ExprSem=[int=int]
            '.'
            SubscribeExpr:Sem=[length=int] ExprSem=[int=int]
              VarName:Sem=[length=int] ExprSem=[length=int]
                length
              FuncSubscribeExpr:Sem=[length=int] ExprSem=[int=int]
                Arguments:
        '=='
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 5
clvr 0 // sa
push Nil // initialize local value
store 0 // initialize local value
push "acdk.lang.String" // array element class name
push 1103806595072 // dmi flags = 0, argcount = 1
newarr
loadref 0 // sa
assign
pop // discarge expression result for ExprStatement
loadref 0 // sa
ldarelref // array element access
assign
pop // discarge expression result for ExprStatement
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // sa
ldarel // array element access
load 1 // ClassName or object instance
push -1163282889 // function name: _l_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
load 0 // sa
ldarel // array element access
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 62464505 // function name: _z_length
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
eq
pop // discarge expression result for ExprStatement
0: clvr 0 // sa
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: push "acdk.lang.String" // array element class name
5: push 1103806595072 // dmi flags = 0, argcount = 1
6: newarr
7: loadref 0 // sa
8: assign
9: pop // discarge expression result for ExprStatement
10: push "Hello" // Terminal
11: loadref 0 // sa
12: push 1 // Terminal
13: ldarelref // array element access
14: assign
15: pop // discarge expression result for ExprStatement
16: push "acdk.lang.System" // class name
17: push "out" // fieldname
18: push 0 // dmi flags
19: peek_static
20: clvr 1 // ClassName or object instance
21: store 1
22: load 0 // sa
23: push 1 // Terminal
24: ldarel // array element access
25: load 1 // ClassName or object instance
26: push -1163282889 // function name: _l_println
27: push 4362076176 // dmi flags = PUBLIC, argcount = 1
28: hash_invoke
29: pop // discarge expression result for ExprStatement
30: load 0 // sa
31: push 1 // Terminal
32: ldarel // array element access
33: clvr 2 // ClassName or object instance
34: store 2
35: load 2 // ClassName or object instance
36: push 62464505 // function name: _z_length
37: push 67108880 // dmi flags = PUBLIC, argcount = 0
38: hash_invoke
39: push 5 // Terminal
40: eq
41: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // sa
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: push "acdk.lang.String" // array element class name
   Stack: 2 | acdk.lang.String | 
5: push 1103806595072 // dmi flags = 0, argcount = 1
   Stack: 2 | acdk.lang.String | 1103806595072 | 
6: newarr
   Stack: acdk/lang/Object | 
7: loadref 0 // sa
   Stack: acdk/lang/Object | &Nil | 
8: assign
   Stack: acdk/lang/Object | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: push "Hello" // Terminal
   Stack: Hello | 
11: loadref 0 // sa
   Stack: Hello | &acdk/lang/Object | 
12: push 1 // Terminal
   Stack: Hello | &acdk/lang/Object | 1 | 
13: ldarelref // array element access
   Stack: Hello | &Nil | 
14: assign
   Stack: Hello | 
15: pop // discarge expression result for ExprStatement
   Stack: 
16: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
17: push "out" // fieldname
   Stack: acdk.lang.System | out | 
18: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
19: peek_static
   Stack: acdk/io/PrintWriter | 
20: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
21: store 1
   Stack: 
22: load 0 // sa
   Stack: acdk/lang/Object | 
23: push 1 // Terminal
   Stack: acdk/lang/Object | 1 | 
24: ldarel // array element access
   Stack: Hello | 
25: load 1 // ClassName or object instance
   Stack: Hello | acdk/io/PrintWriter | 
26: push -1163282889 // function name: _l_println
   Stack: Hello | acdk/io/PrintWriter | -1163282889 | 
27: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: Hello | acdk/io/PrintWriter | -1163282889 | 4362076176 | 
28: hash_invoke
</pre>
<h2><a id="ParameterPassing_Test.polymorph">ParameterPassing_Test.polymorph</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 4,39: Cannot find matching function polymorphFunc in acdk.tools.aunit.DmiTestClass<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::CodeException::CodeException (acdk_aal_d.dll)
  called in acdk::aal::FuncSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aal::MemberSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aal::AssignmentExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in tests::acdk::aal::parseTreeInterpret (acdk_aal_Test_d.exe)
  called in tests::acdk::aal::ParameterPassing_Test::polymorph (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::ParameterPassing_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Operator_Test.arrayOperator] End Test
[AUNIT:STRT][ParameterPassing_Test.polymorph] Start Test
Parsed: [using acdk.tools.aunit;
using acdk.lang;
DmiTestClass obj = new DmiTestClass();
String s;
s = obj.polymorphFunc(new Integer(42));
Number number = new Integer(41);
s = obj.polymorphFunc(number);
number = new Short(2);
s = obj.polymorphFunc(number);
s = obj.polymorphFunc("asdf");
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        obj
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    NewExpr:
                      FqTypeName:
                        
                      Arguments:
                        Argument:
                          Literal:
                            : 42
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        number
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 41
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    VarName:
                      number
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          number
        '='
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 2
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    VarName:
                      number
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          s
        '='
        SubscribeExpr:
          VarName:
            obj
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                polymorphFunc
              FuncSubscribeExpr:
                Arguments:
                  Argument:
                    Literal:
                      : asdf
Create Var obj at idx: 0
Create Var s at idx: 1
[AUNIT:ERRR][ParameterPassing_Test.polymorph] Error in Test: ParameterPassing_Test.polymorph: 4,39: Cannot find matching function polymorphFunc in acdk.tools.aunit.DmiTestClass
</pre>
<h2><a id="ParameterPassing_Test.namedParameter">ParameterPassing_Test.namedParameter</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 1,50: Cannot find matching function toString in acdk.lang.Integer<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::CodeException::CodeException (acdk_aal_d.dll)
  called in acdk::aal::FuncSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aal::MemberSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aal::AssignmentExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::LVarDecl::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in tests::acdk::aal::parseTreeInterpret (acdk_aal_Test_d.exe)
  called in tests::acdk::aal::ParameterPassing_Test::namedParameter (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::ParameterPassing_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][ParameterPassing_Test.polymorph] End Test
[AUNIT:STRT][ParameterPassing_Test.namedParameter] Start Test
Parsed: [using acdk.lang;
String s = Integer.toString(radix: 10, value: 42);
] to
CodeText:
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        SubscribeExpr:
          VarName:
            Integer
          MemberSubscribeExpr:
            '.'
            SubscribeExpr:
              VarName:
                toString
              FuncSubscribeExpr:
                Arguments:
                  ArgumentList:
                    Argument:
                      Label:
                        radix
                      Literal:
                        : 10
                    Argument:
                      Label:
                        value
                      Literal:
                        : 42
Create Var s at idx: 0
[AUNIT:ERRR][ParameterPassing_Test.namedParameter] Error in Test: ParameterPassing_Test.namedParameter: 1,50: Cannot find matching function toString in acdk.lang.Integer
</pre>
<h2><a id="ParameterPassing_Test.restParameter">ParameterPassing_Test.restParameter</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> (-1): unknown exception: unknown exception<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::tools::aunit::TestException::TestException (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][ParameterPassing_Test.namedParameter] End Test
[AUNIT:STRT][ParameterPassing_Test.restParameter] Start Test
Parsed: [class AClass { public AClass() {} public void foo(int i, acdk.lang.dmi.DmiObjectArray rest) { } }
AClass a = new AClass();
a.foo(2, 40, 41, 42);
] to
CodeText:
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              i
          Parameter:
            FqTypeName:
              
            VarName:
              rest
        FunctionBlock:
          Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          a
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              foo
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    Literal:
                      : 2
                  Argument:
                    Literal:
                      : 40
                  Argument:
                    Literal:
                      : 41
                  Argument:
                    Literal:
                      : 42
Create Var this at idx: 0
AClass this
Create Var i at idx: 0
Create Var rest at idx: 1
int i
[acdk.lang.dmi.DmiObject rest
Create Var this at idx: 0
AClass this
int i
[acdk.lang.dmi.DmiObject rest
Create Var a at idx: 0
[AUNIT:ERRR][ParameterPassing_Test.restParameter] Error in Test: ParameterPassing_Test.restParameter: (-1): unknown exception: unknown exception
</pre>
<h2><a id="RelExpr_Test.basicRels">RelExpr_Test.basicRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][ParameterPassing_Test.restParameter] End Test
[AUNIT:STRT][RelExpr_Test.basicRels] Start Test
Parsed: [using acdk.lang;
Integer integer1 = new Integer(42);
Integer integer2 = integer1;
__assert(integer1 == integer2, "compare object instances failed");
integer2 = new Integer(42);
__assert(integer1 != integer2, "compare object instances failed");
__assert(integer1.equals(integer2) == true, "compare object via equals failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        integer1
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        integer2
      VarInitializer:
        VarName:
          integer1
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    integer1
                  '=='
                  VarName:
                    integer2
              Argument:
                Literal:
                  : compare object instances failed
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          integer2
        '='
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : 42
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    integer1
                  '!='
                  VarName:
                    integer2
              Argument:
                Literal:
                  : compare object instances failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  SubscribeExpr:
                    VarName:
                      integer1
                    MemberSubscribeExpr:
                      '.'
                      SubscribeExpr:
                        VarName:
                          equals
                        FuncSubscribeExpr:
                          Arguments:
                            Argument:
                              VarName:
                                integer2
                  '=='
                  Literal:
                    BOOLEAN_LITERAL:
                      'true'
              Argument:
                Literal:
                  : compare object via equals failed
Create Var integer1 at idx: 0
Create Var integer2 at idx: 1
clvr 0 // integer1
push Nil // initialize local value
store 0 // initialize local value
push "acdk.lang.Integer" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 0 // integer1
assign
pop // discarge expression result for ExprStatement
clvr 1 // integer2
push Nil // initialize local value
store 1 // initialize local value
load 0 // integer1
loadref 1 // integer2
assign
pop // discarge expression result for ExprStatement
load 0 // integer1
load 1 // integer2
eq
assert
pop // discarge expression result for ExprStatement
push "acdk.lang.Integer" // class name
push 4294967296 // dmi flags = 0, argcount = 1
new
loadref 1 // integer2
assign
pop // discarge expression result for ExprStatement
load 0 // integer1
load 1 // integer2
ne
assert
pop // discarge expression result for ExprStatement
load 0 // integer1
Create Var __tvar1 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 1 // integer2
load 2 // ClassName or object instance
push 1795430377 // function name: _3_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
push true // true
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // integer1
1: push Nil // initialize local value
2: store 0 // initialize local value
3: push 42 // Terminal
4: push "acdk.lang.Integer" // class name
5: push 4294967296 // dmi flags = 0, argcount = 1
6: new
7: loadref 0 // integer1
8: assign
9: pop // discarge expression result for ExprStatement
10: clvr 1 // integer2
11: push Nil // initialize local value
12: store 1 // initialize local value
13: load 0 // integer1
14: loadref 1 // integer2
15: assign
16: pop // discarge expression result for ExprStatement
17: load 0 // integer1
18: load 1 // integer2
19: eq
20: push "compare object instances failed" // Terminal
21: assert
22: pop // discarge expression result for ExprStatement
23: push 42 // Terminal
24: push "acdk.lang.Integer" // class name
25: push 4294967296 // dmi flags = 0, argcount = 1
26: new
27: loadref 1 // integer2
28: assign
29: pop // discarge expression result for ExprStatement
30: load 0 // integer1
31: load 1 // integer2
32: ne
33: push "compare object instances failed" // Terminal
34: assert
35: pop // discarge expression result for ExprStatement
36: load 0 // integer1
37: clvr 2 // ClassName or object instance
38: store 2
39: load 1 // integer2
40: load 2 // ClassName or object instance
41: push 1795430377 // function name: _3_equals
42: push 4362076176 // dmi flags = PUBLIC, argcount = 1
43: hash_invoke
44: push true // true
45: eq
46: push "compare object via equals failed" // Terminal
47: assert
48: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // integer1
   Stack: 
1: push Nil // initialize local value
   Stack: Nil | 
2: store 0 // initialize local value
   Stack: 
3: push 42 // Terminal
   Stack: 42 | 
4: push "acdk.lang.Integer" // class name
   Stack: 42 | acdk.lang.Integer | 
5: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | acdk.lang.Integer | 4294967296 | 
6: new
   Stack: 42 | 
7: loadref 0 // integer1
   Stack: 42 | &Nil | 
8: assign
   Stack: 42 | 
9: pop // discarge expression result for ExprStatement
   Stack: 
10: clvr 1 // integer2
   Stack: 
11: push Nil // initialize local value
   Stack: Nil | 
12: store 1 // initialize local value
   Stack: 
13: load 0 // integer1
   Stack: 42 | 
14: loadref 1 // integer2
   Stack: 42 | &Nil | 
15: assign
   Stack: 42 | 
16: pop // discarge expression result for ExprStatement
   Stack: 
17: load 0 // integer1
   Stack: 42 | 
18: load 1 // integer2
   Stack: 42 | 42 | 
19: eq
   Stack: true | 
20: push "compare object instances failed" // Terminal
   Stack: true | compare object instances failed | 
21: assert
   Stack: true | 
22: pop // discarge expression result for ExprStatement
   Stack: 
23: push 42 // Terminal
   Stack: 42 | 
24: push "acdk.lang.Integer" // class name
   Stack: 42 | acdk.lang.Integer | 
25: push 4294967296 // dmi flags = 0, argcount = 1
   Stack: 42 | acdk.lang.Integer | 4294967296 | 
26: new
   Stack: 42 | 
27: loadref 1 // integer2
   Stack: 42 | &42 | 
28: assign
   Stack: 42 | 
29: pop // discarge expression result for ExprStatement
   Stack: 
30: load 0 // integer1
   Stack: 42 | 
31: load 1 // integer2
   Stack: 42 | 42 | 
32: ne
   Stack: true | 
33: push "compare object instances failed" // Terminal
   Stack: true | compare object instances failed | 
34: assert
   Stack: true | 
35: pop // discarge expression result for ExprStatement
   Stack: 
36: load 0 // integer1
   Stack: 42 | 
37: clvr 2 // ClassName or object instance
   Stack: 42 | 
38: store 2
   Stack: 
39: load 1 // integer2
   Stack: 42 | 
40: load 2 // ClassName or object instance
   Stack: 42 | 42 | 
41: push 1795430377 // function name: _3_equals
   Stack: 42 | 42 | 1795430377 | 
42: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | 42 | 1795430377 | 4362076176 | 
43: hash_invoke
   Stack: true | 
44: push true // true
   Stack: true | true | 
45: eq
   Stack: true | 
46: push "compare object via equals failed" // Terminal
   Stack: true | compare object via equals failed | 
47: assert
   Stack: true | 
48: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="RelExpr_Test.operatorRels">RelExpr_Test.operatorRels</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][RelExpr_Test.basicRels] End Test
[AUNIT:STRT][RelExpr_Test.operatorRels] Start Test
Parsed: [class AClass { public AClass() {}
  public bool operator<(int other) { return 42 < other; }
  public bool operator<=(int other) { return 42 <= other; }
  public bool operator>(int other) { return 42 > other; }
  public bool operator>=(int other) { return 42 >= other; }
  public bool operator==(int other) { return 42 == other; }
  public bool operator!=(int other) { return 42 != other; }
}
AClass a = new AClass();
__assert(a < 43, "compare int failed");
__assert(a > 41, "compare int failed");
__assert(a >= 41, "compare int failed");
__assert(a >= 42, "compare int failed");
__assert(a <= 43, "compare int failed");
__assert(a <= 42, "compare int failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclConstructor:
        ClassMemberAttr:
          'public'
        MethodName:
          AClass
        FunctionParamsDecl:
        ClassDeclConstructorInitializerList:
        FunctionBlock:
          Block:
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          <
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '<'
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          <=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '<='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          >
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '>'
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          >=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                RelationalExpr:
                  Literal:
                    : 42
                  '>='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          ==
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                EqualityExpr:
                  Literal:
                    : 42
                  '=='
                  VarName:
                    other
      ClassDeclOperator:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        Operator:
          !=
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              other
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                EqualityExpr:
                  Literal:
                    : 42
                  '!='
                  VarName:
                    other
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        a
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<'
                  Literal:
                    : 43
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>'
                  Literal:
                    : 41
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>='
                  Literal:
                    : 41
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '>='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<='
                  Literal:
                    : 43
              Argument:
                Literal:
                  : compare int failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                RelationalExpr:
                  VarName:
                    a
                  '<='
                  Literal:
                    : 42
              Argument:
                Literal:
                  : compare int failed
Create Var this at idx: 0
AClass this
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var other at idx: 0
int other
Create Var this at idx: 0
AClass this
int other
Create Var a at idx: 0
Code already postParsed: VarName: a
Code already postParsed: Literal: 
Code already postParsed: VarName: a
Code already postParsed: Literal: 
Code already postParsed: VarName: a
Code already postParsed: Literal: 
Code already postParsed: VarName: a
Code already postParsed: Literal: 
Code already postParsed: VarName: a
Code already postParsed: Literal: 
Code already postParsed: VarName: a
Code already postParsed: Literal: 
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
load 1 // other
lt
ret  // return statement
Function operator_lt[
__method_start: nop // 
push 42 // Terminal
load 1 // other
lt
ret  // return statement
]
__method_start: nop // 
load 1 // other
lteq
ret  // return statement
Function operator_lt_eq[
__method_start: nop // 
push 42 // Terminal
load 1 // other
lteq
ret  // return statement
]
__method_start: nop // 
load 1 // other
gt
ret  // return statement
Function operator_gt[
__method_start: nop // 
push 42 // Terminal
load 1 // other
gt
ret  // return statement
]
__method_start: nop // 
load 1 // other
gteq
ret  // return statement
Function operator_gt_eq[
__method_start: nop // 
push 42 // Terminal
load 1 // other
gteq
ret  // return statement
]
__method_start: nop // 
load 1 // other
eq
ret  // return statement
Function operator_eq_eq[
__method_start: nop // 
push 42 // Terminal
load 1 // other
eq
ret  // return statement
]
__method_start: nop // 
load 1 // other
ne
ret  // return statement
Function operator_nt_eq[
__method_start: nop // 
push 42 // Terminal
load 1 // other
ne
ret  // return statement
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // a
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // a
assign
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push -99901108 // function name: _1_operator_lt
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push -99905913 // function name: _3_operator_gt
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar3 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 1302180460 // function name: _4_operator_gt_eq
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar4 at idx: 4
clvr 4 // ClassName or object instance
store 4
load 4 // ClassName or object instance
push 1302180460 // function name: _4_operator_gt_eq
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar5 at idx: 5
clvr 5 // ClassName or object instance
store 5
load 5 // ClassName or object instance
push 1445326215 // function name: _2_operator_lt_eq
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
load 0 // a
Create Var __tvar6 at idx: 6
clvr 6 // ClassName or object instance
store 6
load 6 // ClassName or object instance
push 1445326215 // function name: _2_operator_lt_eq
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // a
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // a
9: assign
10: pop // discarge expression result for ExprStatement
11: load 0 // a
12: clvr 1 // ClassName or object instance
13: store 1
14: push 43 // Terminal
15: load 1 // ClassName or object instance
16: push -99901108 // function name: _1_operator_lt
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
18: hash_invoke
19: push "compare int failed" // Terminal
20: assert
21: pop // discarge expression result for ExprStatement
22: load 0 // a
23: clvr 2 // ClassName or object instance
24: store 2
25: push 41 // Terminal
26: load 2 // ClassName or object instance
27: push -99905913 // function name: _3_operator_gt
28: push 4362076176 // dmi flags = PUBLIC, argcount = 1
29: hash_invoke
30: push "compare int failed" // Terminal
31: assert
32: pop // discarge expression result for ExprStatement
33: load 0 // a
34: clvr 3 // ClassName or object instance
35: store 3
36: push 41 // Terminal
37: load 3 // ClassName or object instance
38: push 1302180460 // function name: _4_operator_gt_eq
39: push 4362076176 // dmi flags = PUBLIC, argcount = 1
40: hash_invoke
41: push "compare int failed" // Terminal
42: assert
43: pop // discarge expression result for ExprStatement
44: load 0 // a
45: clvr 4 // ClassName or object instance
46: store 4
47: push 42 // Terminal
48: load 4 // ClassName or object instance
49: push 1302180460 // function name: _4_operator_gt_eq
50: push 4362076176 // dmi flags = PUBLIC, argcount = 1
51: hash_invoke
52: push "compare int failed" // Terminal
53: assert
54: pop // discarge expression result for ExprStatement
55: load 0 // a
56: clvr 5 // ClassName or object instance
57: store 5
58: push 43 // Terminal
59: load 5 // ClassName or object instance
60: push 1445326215 // function name: _2_operator_lt_eq
61: push 4362076176 // dmi flags = PUBLIC, argcount = 1
62: hash_invoke
63: push "compare int failed" // Terminal
64: assert
65: pop // discarge expression result for ExprStatement
66: load 0 // a
67: clvr 6 // ClassName or object instance
68: store 6
69: push 42 // Terminal
70: load 6 // ClassName or object instance
71: push 1445326215 // function name: _2_operator_lt_eq
72: push 4362076176 // dmi flags = PUBLIC, argcount = 1
73: hash_invoke
74: push "compare int failed" // Terminal
75: assert
76: pop // discarge expression result for ExprStatement
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // a
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // a
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: load 0 // a
   Stack: AClass | 
12: clvr 1 // ClassName or object instance
   Stack: AClass | 
13: store 1
   Stack: 
14: push 43 // Terminal
   Stack: 43 | 
15: load 1 // ClassName or object instance
   Stack: 43 | AClass | 
16: push -99901108 // function name: _1_operator_lt
   Stack: 43 | AClass | -99901108 | 
17: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 43 | AClass | -99901108 | 4362076176 | 
18: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 43 | 
3: lt
   Stack: true | 
4: ret  // return statement
   Stack: true | 
19: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
20: assert
   Stack: true | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: load 0 // a
   Stack: AClass | 
23: clvr 2 // ClassName or object instance
   Stack: AClass | 
24: store 2
   Stack: 
25: push 41 // Terminal
   Stack: 41 | 
26: load 2 // ClassName or object instance
   Stack: 41 | AClass | 
27: push -99905913 // function name: _3_operator_gt
   Stack: 41 | AClass | -99905913 | 
28: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 41 | AClass | -99905913 | 4362076176 | 
29: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 41 | 
3: gt
   Stack: true | 
4: ret  // return statement
   Stack: true | 
30: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
31: assert
   Stack: true | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: load 0 // a
   Stack: AClass | 
34: clvr 3 // ClassName or object instance
   Stack: AClass | 
35: store 3
   Stack: 
36: push 41 // Terminal
   Stack: 41 | 
37: load 3 // ClassName or object instance
   Stack: 41 | AClass | 
38: push 1302180460 // function name: _4_operator_gt_eq
   Stack: 41 | AClass | 1302180460 | 
39: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 41 | AClass | 1302180460 | 4362076176 | 
40: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 41 | 
3: gteq
   Stack: true | 
4: ret  // return statement
   Stack: true | 
41: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
42: assert
   Stack: true | 
43: pop // discarge expression result for ExprStatement
   Stack: 
44: load 0 // a
   Stack: AClass | 
45: clvr 4 // ClassName or object instance
   Stack: AClass | 
46: store 4
   Stack: 
47: push 42 // Terminal
   Stack: 42 | 
48: load 4 // ClassName or object instance
   Stack: 42 | AClass | 
49: push 1302180460 // function name: _4_operator_gt_eq
   Stack: 42 | AClass | 1302180460 | 
50: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | AClass | 1302180460 | 4362076176 | 
51: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 42 | 
3: gteq
   Stack: true | 
4: ret  // return statement
   Stack: true | 
52: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
53: assert
   Stack: true | 
54: pop // discarge expression result for ExprStatement
   Stack: 
55: load 0 // a
   Stack: AClass | 
56: clvr 5 // ClassName or object instance
   Stack: AClass | 
57: store 5
   Stack: 
58: push 43 // Terminal
   Stack: 43 | 
59: load 5 // ClassName or object instance
   Stack: 43 | AClass | 
60: push 1445326215 // function name: _2_operator_lt_eq
   Stack: 43 | AClass | 1445326215 | 
61: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 43 | AClass | 1445326215 | 4362076176 | 
62: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 43 | 
3: lteq
   Stack: true | 
4: ret  // return statement
   Stack: true | 
63: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
64: assert
   Stack: true | 
65: pop // discarge expression result for ExprStatement
   Stack: 
66: load 0 // a
   Stack: AClass | 
67: clvr 6 // ClassName or object instance
   Stack: AClass | 
68: store 6
   Stack: 
69: push 42 // Terminal
   Stack: 42 | 
70: load 6 // ClassName or object instance
   Stack: 42 | AClass | 
71: push 1445326215 // function name: _2_operator_lt_eq
   Stack: 42 | AClass | 1445326215 | 
72: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | AClass | 1445326215 | 4362076176 | 
73: hash_invoke
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push 42 // Terminal
   Stack: 42 | 
2: load 1 // other
   Stack: 42 | 42 | 
3: lteq
   Stack: true | 
4: ret  // return statement
   Stack: true | 
74: push "compare int failed" // Terminal
   Stack: true | compare int failed | 
75: assert
   Stack: true | 
76: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="RelExpr_Test.equalsExpr">RelExpr_Test.equalsExpr</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][RelExpr_Test.operatorRels] End Test
[AUNIT:STRT][RelExpr_Test.equalsExpr] Start Test
Parsed: [__assert(1 !== 2, "equals operator fails");
acdk.lang.String s = "a";
s.equals("a");
__assert(s === "a", "equals operator fails");
__assert(s !== "b", "equals operator fails");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  Literal:
                    : 1
                  '!=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : equals operator fails
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        s
      VarInitializer:
        Literal:
          : a
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          s
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              equals
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  Literal:
                    : a
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  VarName:
                    s
                  '==='
                  Literal:
                    : a
              Argument:
                Literal:
                  : equals operator fails
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualsExpr:
                  VarName:
                    s
                  '!=='
                  Literal:
                    : b
              Argument:
                Literal:
                  : equals operator fails
Code already postParsed: Literal: 
Code already postParsed: Literal: 
Create Var s at idx: 0
Code already postParsed: VarName: s
Code already postParsed: Keyword: 
Code already postParsed: Literal: 
Code already postParsed: VarName: s
Code already postParsed: Literal: 
Code already postParsed: VarName: s
Code already postParsed: Keyword: 
Code already postParsed: Literal: 
Code already postParsed: VarName: s
Code already postParsed: Literal: 
ne
assert
pop // discarge expression result for ExprStatement
clvr 0 // s
push Nil // initialize local value
store 0 // initialize local value
loadref 0 // s
assign
pop // discarge expression result for ExprStatement
load 0 // s
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
load 0 // s
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
assert
pop // discarge expression result for ExprStatement
loadref 0 // s
Create Var __tvar3 at idx: 3
clvr 3 // ClassName or object instance
store 3
load 3 // ClassName or object instance
push 659573500 // function name: _u_equals
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
not // negation
assert
pop // discarge expression result for ExprStatement
0: push 1 // Terminal
1: push 2 // Terminal
2: ne
3: push "equals operator fails" // Terminal
4: assert
5: pop // discarge expression result for ExprStatement
6: clvr 0 // s
7: push Nil // initialize local value
8: store 0 // initialize local value
9: push "a" // Terminal
10: loadref 0 // s
11: assign
12: pop // discarge expression result for ExprStatement
13: load 0 // s
14: clvr 1 // ClassName or object instance
15: store 1
16: push "a" // Terminal
17: load 1 // ClassName or object instance
18: push 659573500 // function name: _u_equals
19: push 4362076176 // dmi flags = PUBLIC, argcount = 1
20: hash_invoke
21: pop // discarge expression result for ExprStatement
22: load 0 // s
23: clvr 2 // ClassName or object instance
24: store 2
25: push "a" // Terminal
26: load 2 // ClassName or object instance
27: push 659573500 // function name: _u_equals
28: push 4362076176 // dmi flags = PUBLIC, argcount = 1
29: hash_invoke
30: push "equals operator fails" // Terminal
31: assert
32: pop // discarge expression result for ExprStatement
33: loadref 0 // s
34: clvr 3 // ClassName or object instance
35: store 3
36: push "b" // Terminal
37: load 3 // ClassName or object instance
38: push 659573500 // function name: _u_equals
39: push 4362076176 // dmi flags = PUBLIC, argcount = 1
40: hash_invoke
41: not // negation
42: push "equals operator fails" // Terminal
43: assert
44: pop // discarge expression result for ExprStatement
   Stack: 
0: push 1 // Terminal
   Stack: 1 | 
1: push 2 // Terminal
   Stack: 1 | 2 | 
2: ne
   Stack: true | 
3: push "equals operator fails" // Terminal
   Stack: true | equals operator fails | 
4: assert
   Stack: true | 
5: pop // discarge expression result for ExprStatement
   Stack: 
6: clvr 0 // s
   Stack: 
7: push Nil // initialize local value
   Stack: Nil | 
8: store 0 // initialize local value
   Stack: 
9: push "a" // Terminal
   Stack: a | 
10: loadref 0 // s
   Stack: a | &Nil | 
11: assign
   Stack: a | 
12: pop // discarge expression result for ExprStatement
   Stack: 
13: load 0 // s
   Stack: a | 
14: clvr 1 // ClassName or object instance
   Stack: a | 
15: store 1
   Stack: 
16: push "a" // Terminal
   Stack: a | 
17: load 1 // ClassName or object instance
   Stack: a | a | 
18: push 659573500 // function name: _u_equals
   Stack: a | a | 659573500 | 
19: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: a | a | 659573500 | 4362076176 | 
20: hash_invoke
   Stack: true | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: load 0 // s
   Stack: a | 
23: clvr 2 // ClassName or object instance
   Stack: a | 
24: store 2
   Stack: 
25: push "a" // Terminal
   Stack: a | 
26: load 2 // ClassName or object instance
   Stack: a | a | 
27: push 659573500 // function name: _u_equals
   Stack: a | a | 659573500 | 
28: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: a | a | 659573500 | 4362076176 | 
29: hash_invoke
   Stack: true | 
30: push "equals operator fails" // Terminal
   Stack: true | equals operator fails | 
31: assert
   Stack: true | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: loadref 0 // s
   Stack: &a | 
34: clvr 3 // ClassName or object instance
   Stack: &a | 
35: store 3
   Stack: 
36: push "b" // Terminal
   Stack: b | 
37: load 3 // ClassName or object instance
   Stack: b | &a | 
38: push 659573500 // function name: _u_equals
   Stack: b | &a | 659573500 | 
39: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: b | &a | 659573500 | 4362076176 | 
40: hash_invoke
   Stack: false | 
41: not // negation
   Stack: true | 
42: push "equals operator fails" // Terminal
   Stack: true | equals operator fails | 
43: assert
   Stack: true | 
44: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Scanner_Test.standard">Scanner_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][RelExpr_Test.equalsExpr] End Test
[AUNIT:STRT][Scanner_Test.standard] Start Test
</pre>
<h2><a id="Scanner_Test.string">Scanner_Test.string</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Scanner_Test.standard] End Test
[AUNIT:STRT][Scanner_Test.string] Start Test
</pre>
<h2><a id="Scanner_Test.interactive">Scanner_Test.interactive</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Scanner_Test.string] End Test
[AUNIT:STRT][Scanner_Test.interactive] Start Test
</pre>
<h2><a id="Scanner_Test.cComments">Scanner_Test.cComments</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Scanner_Test.interactive] End Test
[AUNIT:STRT][Scanner_Test.cComments] Start Test
</pre>
<h2><a id="Statements_Test.standard">Statements_Test.standard</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Scanner_Test.cComments] End Test
[AUNIT:STRT][Statements_Test.standard] Start Test
Parsed: [] to
CodeText:
CodeText:
</pre>
<h2><a id="Statements_Test.varDecl">Statements_Test.varDecl</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.standard] End Test
[AUNIT:STRT][Statements_Test.varDecl] Start Test
Parsed: [int i;
__assert(i == 0, "varDecl without initalizer don't work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 0
              Argument:
                Literal:
                  : varDecl without initalizer don't work
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: load 0 // i
4: push 0 // Terminal
5: eq
6: push "varDecl without initalizer don't work" // Terminal
7: assert
8: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: load 0 // i
   Stack: 0 | 
4: push 0 // Terminal
   Stack: 0 | 0 | 
5: eq
   Stack: true | 
6: push "varDecl without initalizer don't work" // Terminal
   Stack: true | varDecl without initalizer don't work | 
7: assert
   Stack: true | 
8: pop // discarge expression result for ExprStatement
Parsed: [int i = 2;
__assert(i == 2, "varDecl with initalizer don't work");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : varDecl with initalizer don't work
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 2 // Terminal
9: eq
10: push "varDecl with initalizer don't work" // Terminal
11: assert
12: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 2 | 
8: push 2 // Terminal
   Stack: 2 | 2 | 
9: eq
   Stack: true | 
10: push "varDecl with initalizer don't work" // Terminal
   Stack: true | varDecl with initalizer don't work | 
11: assert
   Stack: true | 
12: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.block">Statements_Test.block</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.varDecl] End Test
[AUNIT:STRT][Statements_Test.block] Start Test
Parsed: [int i = 2;
int j = 10;
{
  int j = i;
  __assert(j == 2, "Scoped Block local vars");
}
i = j;
__assert(i == 10, "Scoped Block local vars");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        Literal:
          : 10
  Statement:
    Block:
      Statement:
        LVarDecl:
          FqTypeName:
            
          VarName:
            j
          VarInitializer:
            VarName:
              i
      Statement:
        ExprStatement:
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    EqualityExpr:
                      VarName:
                        j
                      '=='
                      Literal:
                        : 2
                  Argument:
                    Literal:
                      : Scoped Block local vars
  Statement:
    ExprStatement:
      AssignmentExpr:
        VarName:
          i
        '='
        VarName:
          j
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 10
              Argument:
                Literal:
                  : Scoped Block local vars
Create Var i at idx: 0
Create Var j at idx: 1
Create Var j at idx: 2
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
clvr 2 // j
push 0 // initialize local value
store 2 // initialize local value
load 0 // i
loadref 2 // j
assign
pop // discarge expression result for ExprStatement
load 2 // j
eq
assert
pop // discarge expression result for ExprStatement
load 1 // j
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: push 10 // Terminal
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: clvr 2 // j
15: push 0 // initialize local value
16: store 2 // initialize local value
17: load 0 // i
18: loadref 2 // j
19: assign
20: pop // discarge expression result for ExprStatement
21: load 2 // j
22: push 2 // Terminal
23: eq
24: push "Scoped Block local vars" // Terminal
25: assert
26: pop // discarge expression result for ExprStatement
27: load 1 // j
28: loadref 0 // i
29: assign
30: pop // discarge expression result for ExprStatement
31: load 0 // i
32: push 10 // Terminal
33: eq
34: push "Scoped Block local vars" // Terminal
35: assert
36: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: push 10 // Terminal
   Stack: 10 | 
11: loadref 1 // j
   Stack: 10 | &0 | 
12: assign
   Stack: 10 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: clvr 2 // j
   Stack: 
15: push 0 // initialize local value
   Stack: 0 | 
16: store 2 // initialize local value
   Stack: 
17: load 0 // i
   Stack: 2 | 
18: loadref 2 // j
   Stack: 2 | &0 | 
19: assign
   Stack: 2 | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: load 2 // j
   Stack: 2 | 
22: push 2 // Terminal
   Stack: 2 | 2 | 
23: eq
   Stack: true | 
24: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
25: assert
   Stack: true | 
26: pop // discarge expression result for ExprStatement
   Stack: 
27: load 1 // j
   Stack: 10 | 
28: loadref 0 // i
   Stack: 10 | &2 | 
29: assign
   Stack: 10 | 
30: pop // discarge expression result for ExprStatement
   Stack: 
31: load 0 // i
   Stack: 10 | 
32: push 10 // Terminal
   Stack: 10 | 10 | 
33: eq
   Stack: true | 
34: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
35: assert
   Stack: true | 
36: pop // discarge expression result for ExprStatement
Parsed: [int i = 2;
{
  int j = i;
  __assert(j == 2, "Scoped Block local vars");
}
int j = 4;
__assert(i == 2, "Scoped Block local vars");
__assert(j == 4, "Scoped Block local vars");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    Block:
      Statement:
        LVarDecl:
          FqTypeName:
            
          VarName:
            j
          VarInitializer:
            VarName:
              i
      Statement:
        ExprStatement:
          SubscribeExpr:
            VarName:
              __assert
            FuncSubscribeExpr:
              Arguments:
                ArgumentList:
                  Argument:
                    EqualityExpr:
                      VarName:
                        j
                      '=='
                      Literal:
                        : 2
                  Argument:
                    Literal:
                      : Scoped Block local vars
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        Literal:
          : 4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 2
              Argument:
                Literal:
                  : Scoped Block local vars
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    j
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : Scoped Block local vars
Create Var i at idx: 0
Create Var j at idx: 1
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 2 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: clvr 1 // j
8: push 0 // initialize local value
9: store 1 // initialize local value
10: load 0 // i
11: loadref 1 // j
12: assign
13: pop // discarge expression result for ExprStatement
14: load 1 // j
15: push 2 // Terminal
16: eq
17: push "Scoped Block local vars" // Terminal
18: assert
19: pop // discarge expression result for ExprStatement
20: clvr 1 // j
21: push 0 // initialize local value
22: store 1 // initialize local value
23: push 4 // Terminal
24: loadref 1 // j
25: assign
26: pop // discarge expression result for ExprStatement
27: load 0 // i
28: push 2 // Terminal
29: eq
30: push "Scoped Block local vars" // Terminal
31: assert
32: pop // discarge expression result for ExprStatement
33: load 1 // j
34: push 4 // Terminal
35: eq
36: push "Scoped Block local vars" // Terminal
37: assert
38: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 2 // Terminal
   Stack: 2 | 
4: loadref 0 // i
   Stack: 2 | &0 | 
5: assign
   Stack: 2 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: clvr 1 // j
   Stack: 
8: push 0 // initialize local value
   Stack: 0 | 
9: store 1 // initialize local value
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: loadref 1 // j
   Stack: 2 | &0 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 1 // j
   Stack: 2 | 
15: push 2 // Terminal
   Stack: 2 | 2 | 
16: eq
   Stack: true | 
17: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
18: assert
   Stack: true | 
19: pop // discarge expression result for ExprStatement
   Stack: 
20: clvr 1 // j
   Stack: 
21: push 0 // initialize local value
   Stack: 0 | 
22: store 1 // initialize local value
   Stack: 
23: push 4 // Terminal
   Stack: 4 | 
24: loadref 1 // j
   Stack: 4 | &0 | 
25: assign
   Stack: 4 | 
26: pop // discarge expression result for ExprStatement
   Stack: 
27: load 0 // i
   Stack: 2 | 
28: push 2 // Terminal
   Stack: 2 | 2 | 
29: eq
   Stack: true | 
30: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
31: assert
   Stack: true | 
32: pop // discarge expression result for ExprStatement
   Stack: 
33: load 1 // j
   Stack: 4 | 
34: push 4 // Terminal
   Stack: 4 | 4 | 
35: eq
   Stack: true | 
36: push "Scoped Block local vars" // Terminal
   Stack: true | Scoped Block local vars | 
37: assert
   Stack: true | 
38: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.whileStatement">Statements_Test.whileStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.block] End Test
[AUNIT:STRT][Statements_Test.whileStatement] Start Test
Parsed: [int i = 0;
while (i < 10)
{
  i = i + 1;
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    WhileStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
whilebegin1: nop // whilebegin
load 0 // i
lt
brfalse whileend1 // break while loop
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br whilebegin1 // next while loop
whileend1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: whilebegin1: nop // whilebegin
8: load 0 // i
9: push 10 // Terminal
10: lt
11: brfalse whileend1 // break while loop
12: load 0 // i
13: push 1 // Terminal
14: add
15: loadref 0 // i
16: assign
17: pop // discarge expression result for ExprStatement
18: br whilebegin1 // next while loop
19: whileend1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: whilebegin1: nop // whilebegin
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 10 // Terminal
   Stack: 0 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 0 | 
13: push 1 // Terminal
   Stack: 0 | 1 | 
14: add
   Stack: 1 | 
15: loadref 0 // i
   Stack: 1 | &0 | 
16: assign
   Stack: 1 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 10 // Terminal
   Stack: 1 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 1 | 
13: push 1 // Terminal
   Stack: 1 | 1 | 
14: add
   Stack: 2 | 
15: loadref 0 // i
   Stack: 2 | &1 | 
16: assign
   Stack: 2 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 10 // Terminal
   Stack: 2 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 2 | 
13: push 1 // Terminal
   Stack: 2 | 1 | 
14: add
   Stack: 3 | 
15: loadref 0 // i
   Stack: 3 | &2 | 
16: assign
   Stack: 3 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 10 // Terminal
   Stack: 3 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 3 | 
13: push 1 // Terminal
   Stack: 3 | 1 | 
14: add
   Stack: 4 | 
15: loadref 0 // i
   Stack: 4 | &3 | 
16: assign
   Stack: 4 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 4 | 
9: push 10 // Terminal
   Stack: 4 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 4 | 
13: push 1 // Terminal
   Stack: 4 | 1 | 
14: add
   Stack: 5 | 
15: loadref 0 // i
   Stack: 5 | &4 | 
16: assign
   Stack: 5 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 5 | 
9: push 10 // Terminal
   Stack: 5 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 5 | 
13: push 1 // Terminal
   Stack: 5 | 1 | 
14: add
   Stack: 6 | 
15: loadref 0 // i
   Stack: 6 | &5 | 
16: assign
   Stack: 6 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 6 | 
9: push 10 // Terminal
   Stack: 6 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 6 | 
13: push 1 // Terminal
   Stack: 6 | 1 | 
14: add
   Stack: 7 | 
15: loadref 0 // i
   Stack: 7 | &6 | 
16: assign
   Stack: 7 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 7 | 
9: push 10 // Terminal
   Stack: 7 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 7 | 
13: push 1 // Terminal
   Stack: 7 | 1 | 
14: add
   Stack: 8 | 
15: loadref 0 // i
   Stack: 8 | &7 | 
16: assign
   Stack: 8 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 8 | 
9: push 10 // Terminal
   Stack: 8 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 8 | 
13: push 1 // Terminal
   Stack: 8 | 1 | 
14: add
   Stack: 9 | 
15: loadref 0 // i
   Stack: 9 | &8 | 
16: assign
   Stack: 9 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 9 | 
9: push 10 // Terminal
   Stack: 9 | 10 | 
10: lt
   Stack: true | 
11: brfalse whileend1 // break while loop
   Stack: 
12: load 0 // i
   Stack: 9 | 
13: push 1 // Terminal
   Stack: 9 | 1 | 
14: add
   Stack: 10 | 
15: loadref 0 // i
   Stack: 10 | &9 | 
16: assign
   Stack: 10 | 
17: pop // discarge expression result for ExprStatement
   Stack: 
18: br whilebegin1 // next while loop
   Stack: 
8: load 0 // i
   Stack: 10 | 
9: push 10 // Terminal
   Stack: 10 | 10 | 
10: lt
   Stack: false | 
11: brfalse whileend1 // break while loop
Parsed: [int i = 0;
while (true)
{
  if (i >= 10)
    break;
  i = i + 1;
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    WhileStatement:
      Literal:
        BOOLEAN_LITERAL:
          'true'
      Statement:
        Block:
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>='
                Literal:
                  : 10
              Statement:
                BreakStatement:
                  'break'
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
whilebegin2: nop // whilebegin
push true // true
brfalse whileend2 // break while loop
load 0 // i
gteq
brfalse endif3 // goto endif
br whileend2 // break/continue
endif3: nop // 
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br whilebegin2 // next while loop
whileend2: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: whilebegin2: nop // whilebegin
8: push true // true
9: brfalse whileend2 // break while loop
10: load 0 // i
11: push 10 // Terminal
12: gteq
13: brfalse endif3 // goto endif
14: br whileend2 // break/continue
15: endif3: nop // 
16: load 0 // i
17: push 1 // Terminal
18: add
19: loadref 0 // i
20: assign
21: pop // discarge expression result for ExprStatement
22: br whilebegin2 // next while loop
23: whileend2: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: whilebegin2: nop // whilebegin
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 0 | 
11: push 10 // Terminal
   Stack: 0 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 0 | 
17: push 1 // Terminal
   Stack: 0 | 1 | 
18: add
   Stack: 1 | 
19: loadref 0 // i
   Stack: 1 | &0 | 
20: assign
   Stack: 1 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 1 | 
11: push 10 // Terminal
   Stack: 1 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 1 | 
17: push 1 // Terminal
   Stack: 1 | 1 | 
18: add
   Stack: 2 | 
19: loadref 0 // i
   Stack: 2 | &1 | 
20: assign
   Stack: 2 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 2 | 
11: push 10 // Terminal
   Stack: 2 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 2 | 
17: push 1 // Terminal
   Stack: 2 | 1 | 
18: add
   Stack: 3 | 
19: loadref 0 // i
   Stack: 3 | &2 | 
20: assign
   Stack: 3 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 3 | 
11: push 10 // Terminal
   Stack: 3 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 3 | 
17: push 1 // Terminal
   Stack: 3 | 1 | 
18: add
   Stack: 4 | 
19: loadref 0 // i
   Stack: 4 | &3 | 
20: assign
   Stack: 4 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 4 | 
11: push 10 // Terminal
   Stack: 4 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 4 | 
17: push 1 // Terminal
   Stack: 4 | 1 | 
18: add
   Stack: 5 | 
19: loadref 0 // i
   Stack: 5 | &4 | 
20: assign
   Stack: 5 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 5 | 
11: push 10 // Terminal
   Stack: 5 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 5 | 
17: push 1 // Terminal
   Stack: 5 | 1 | 
18: add
   Stack: 6 | 
19: loadref 0 // i
   Stack: 6 | &5 | 
20: assign
   Stack: 6 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 6 | 
11: push 10 // Terminal
   Stack: 6 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 6 | 
17: push 1 // Terminal
   Stack: 6 | 1 | 
18: add
   Stack: 7 | 
19: loadref 0 // i
   Stack: 7 | &6 | 
20: assign
   Stack: 7 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 7 | 
11: push 10 // Terminal
   Stack: 7 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 7 | 
17: push 1 // Terminal
   Stack: 7 | 1 | 
18: add
   Stack: 8 | 
19: loadref 0 // i
   Stack: 8 | &7 | 
20: assign
   Stack: 8 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 8 | 
11: push 10 // Terminal
   Stack: 8 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 8 | 
17: push 1 // Terminal
   Stack: 8 | 1 | 
18: add
   Stack: 9 | 
19: loadref 0 // i
   Stack: 9 | &8 | 
20: assign
   Stack: 9 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 9 | 
11: push 10 // Terminal
   Stack: 9 | 10 | 
12: gteq
   Stack: false | 
13: brfalse endif3 // goto endif
   Stack: 
16: load 0 // i
   Stack: 9 | 
17: push 1 // Terminal
   Stack: 9 | 1 | 
18: add
   Stack: 10 | 
19: loadref 0 // i
   Stack: 10 | &9 | 
20: assign
   Stack: 10 | 
21: pop // discarge expression result for ExprStatement
   Stack: 
22: br whilebegin2 // next while loop
   Stack: 
8: push true // true
   Stack: true | 
9: brfalse whileend2 // break while loop
   Stack: 
10: load 0 // i
   Stack: 10 | 
11: push 10 // Terminal
   Stack: 10 | 10 | 
12: gteq
   Stack: true | 
13: brfalse endif3 // goto endif
   Stack: 
14: br whileend2 // break/continue
</pre>
<h2><a id="Statements_Test.doStatement">Statements_Test.doStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.whileStatement] End Test
[AUNIT:STRT][Statements_Test.doStatement] Start Test
Parsed: [int i = 0;
do
{
  i = i + 1;
} while  (i < 4);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 4
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin1: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse doend1 // break do loop
br dobegin1 // next do loop
doend1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin1: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 4 // Terminal
16: lt
17: brfalse doend1 // break do loop
18: br dobegin1 // next do loop
19: doend1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin1: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 4 // Terminal
   Stack: 1 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 4 // Terminal
   Stack: 2 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 4 // Terminal
   Stack: 3 | 4 | 
16: lt
   Stack: true | 
17: brfalse doend1 // break do loop
   Stack: 
18: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 4 // Terminal
   Stack: 4 | 4 | 
16: lt
   Stack: false | 
17: brfalse doend1 // break do loop
Parsed: [int i = 0;
do
{
  i = i + 1;
  if (i > 3) break;
} while  (i < 10);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>'
                Literal:
                  : 3
              Statement:
                BreakStatement:
                  'break'
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin2: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
gt
brfalse endif3 // goto endif
br doend2 // break/continue
endif3: nop // 
load 0 // i
lt
brfalse doend2 // break do loop
br dobegin2 // next do loop
doend2: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin2: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 3 // Terminal
16: gt
17: brfalse endif3 // goto endif
18: br doend2 // break/continue
19: endif3: nop // 
20: load 0 // i
21: push 10 // Terminal
22: lt
23: brfalse doend2 // break do loop
24: br dobegin2 // next do loop
25: doend2: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin2: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 3 // Terminal
   Stack: 1 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 1 | 
21: push 10 // Terminal
   Stack: 1 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 3 // Terminal
   Stack: 2 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 2 | 
21: push 10 // Terminal
   Stack: 2 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 3 // Terminal
   Stack: 3 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif3 // goto endif
   Stack: 
20: load 0 // i
   Stack: 3 | 
21: push 10 // Terminal
   Stack: 3 | 10 | 
22: lt
   Stack: true | 
23: brfalse doend2 // break do loop
   Stack: 
24: br dobegin2 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 3 // Terminal
   Stack: 4 | 3 | 
16: gt
   Stack: true | 
17: brfalse endif3 // goto endif
   Stack: 
18: br doend2 // break/continue
</pre>
<h2><a id="Statements_Test.forStatement">Statements_Test.forStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.doStatement] End Test
[AUNIT:STRT][Statements_Test.forStatement] Start Test
Parsed: [for (int i = 0; i < 1; ++i)
{
}
int i = 0;
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ForStatement:
      LVarDecl:
        FqTypeName:
          
        VarName:
          i
        VarInitializer:
          Literal:
            : 0
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 1
      PrefixExpr:
        '++'
        VarName:
          i
      Statement:
        Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
Create Var i at idx: 0
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst1 // first for loop
fornext1: nop // 
loadref 0 // i
inc // prefix inc/dec
pop // remove step expression result
forfirst1: nop // 
load 0 // i
lt
brfalse forlast1 // break for loop
br fornext1 // next for loop
forlast1: nop // 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst1 // first for loop
8: fornext1: nop // 
9: loadref 0 // i
10: inc // prefix inc/dec
11: pop // remove step expression result
12: forfirst1: nop // 
13: load 0 // i
14: push 1 // Terminal
15: lt
16: brfalse forlast1 // break for loop
17: br fornext1 // next for loop
18: forlast1: nop // 
19: clvr 0 // i
20: push 0 // initialize local value
21: store 0 // initialize local value
22: push 0 // Terminal
23: loadref 0 // i
24: assign
25: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst1 // first for loop
   Stack: 
13: load 0 // i
   Stack: 0 | 
14: push 1 // Terminal
   Stack: 0 | 1 | 
15: lt
   Stack: true | 
16: brfalse forlast1 // break for loop
   Stack: 
17: br fornext1 // next for loop
   Stack: 
9: loadref 0 // i
   Stack: &0 | 
10: inc // prefix inc/dec
   Stack: 1 | 
11: pop // remove step expression result
   Stack: 
12: forfirst1: nop // 
   Stack: 
13: load 0 // i
   Stack: 1 | 
14: push 1 // Terminal
   Stack: 1 | 1 | 
15: lt
   Stack: false | 
16: brfalse forlast1 // break for loop
   Stack: 
19: clvr 0 // i
   Stack: 
20: push 0 // initialize local value
   Stack: 0 | 
21: store 0 // initialize local value
   Stack: 
22: push 0 // Terminal
   Stack: 0 | 
23: loadref 0 // i
   Stack: 0 | &0 | 
24: assign
   Stack: 0 | 
25: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
for (; i < 1; ++i)
{
}
int j = i;
__assert(j == 1, "for loop local var handling");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ForStatement:
      EmptyStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 1
      PrefixExpr:
        '++'
        VarName:
          i
      Statement:
        Block:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        j
      VarInitializer:
        VarName:
          i
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    j
                  '=='
                  Literal:
                    : 1
              Argument:
                Literal:
                  : for loop local var handling
Create Var i at idx: 0
Create Var j at idx: 1
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst2 // first for loop
fornext2: nop // 
loadref 0 // i
inc // prefix inc/dec
pop // remove step expression result
forfirst2: nop // 
load 0 // i
lt
brfalse forlast2 // break for loop
br fornext2 // next for loop
forlast2: nop // 
clvr 1 // j
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // j
assign
pop // discarge expression result for ExprStatement
load 1 // j
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst2 // first for loop
8: fornext2: nop // 
9: loadref 0 // i
10: inc // prefix inc/dec
11: pop // remove step expression result
12: forfirst2: nop // 
13: load 0 // i
14: push 1 // Terminal
15: lt
16: brfalse forlast2 // break for loop
17: br fornext2 // next for loop
18: forlast2: nop // 
19: clvr 1 // j
20: push 0 // initialize local value
21: store 1 // initialize local value
22: load 0 // i
23: loadref 1 // j
24: assign
25: pop // discarge expression result for ExprStatement
26: load 1 // j
27: push 1 // Terminal
28: eq
29: push "for loop local var handling" // Terminal
30: assert
31: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst2 // first for loop
   Stack: 
13: load 0 // i
   Stack: 0 | 
14: push 1 // Terminal
   Stack: 0 | 1 | 
15: lt
   Stack: true | 
16: brfalse forlast2 // break for loop
   Stack: 
17: br fornext2 // next for loop
   Stack: 
9: loadref 0 // i
   Stack: &0 | 
10: inc // prefix inc/dec
   Stack: 1 | 
11: pop // remove step expression result
   Stack: 
12: forfirst2: nop // 
   Stack: 
13: load 0 // i
   Stack: 1 | 
14: push 1 // Terminal
   Stack: 1 | 1 | 
15: lt
   Stack: false | 
16: brfalse forlast2 // break for loop
   Stack: 
19: clvr 1 // j
   Stack: 
20: push 0 // initialize local value
   Stack: 0 | 
21: store 1 // initialize local value
   Stack: 
22: load 0 // i
   Stack: 1 | 
23: loadref 1 // j
   Stack: 1 | &0 | 
24: assign
   Stack: 1 | 
25: pop // discarge expression result for ExprStatement
   Stack: 
26: load 1 // j
   Stack: 1 | 
27: push 1 // Terminal
   Stack: 1 | 1 | 
28: eq
   Stack: true | 
29: push "for loop local var handling" // Terminal
   Stack: true | for loop local var handling | 
30: assert
   Stack: true | 
31: pop // discarge expression result for ExprStatement
Parsed: [int i = 0;
for (;;)
  if (++i > 2)
    break;
__assert(i == 3, "for loop local var handling");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    ForStatement:
      EmptyStatement:
      EmptyExpression:
      EmptyExpression:
      Statement:
        IfStatement:
          RelationalExpr:
            PrefixExpr:
              '++'
              VarName:
                i
            '>'
            Literal:
              : 2
          Statement:
            BreakStatement:
              'break'
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : for loop local var handling
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br forfirst3 // first for loop
fornext3: nop // 
forfirst3: nop // 
loadref 0 // i
inc // prefix inc/dec
gt
brfalse endif4 // goto endif
br forlast3 // break/continue
endif4: nop // 
br fornext3 // next for loop
forlast3: nop // 
load 0 // i
eq
assert
pop // discarge expression result for ExprStatement
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: br forfirst3 // first for loop
8: fornext3: nop // 
9: forfirst3: nop // 
10: loadref 0 // i
11: inc // prefix inc/dec
12: push 2 // Terminal
13: gt
14: brfalse endif4 // goto endif
15: br forlast3 // break/continue
16: endif4: nop // 
17: br fornext3 // next for loop
18: forlast3: nop // 
19: load 0 // i
20: push 3 // Terminal
21: eq
22: push "for loop local var handling" // Terminal
23: assert
24: pop // discarge expression result for ExprStatement
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: br forfirst3 // first for loop
   Stack: 
10: loadref 0 // i
   Stack: &0 | 
11: inc // prefix inc/dec
   Stack: 1 | 
12: push 2 // Terminal
   Stack: 1 | 2 | 
13: gt
   Stack: false | 
14: brfalse endif4 // goto endif
   Stack: 
17: br fornext3 // next for loop
   Stack: 
9: forfirst3: nop // 
   Stack: 
10: loadref 0 // i
   Stack: &1 | 
11: inc // prefix inc/dec
   Stack: 2 | 
12: push 2 // Terminal
   Stack: 2 | 2 | 
13: gt
   Stack: false | 
14: brfalse endif4 // goto endif
   Stack: 
17: br fornext3 // next for loop
   Stack: 
9: forfirst3: nop // 
   Stack: 
10: loadref 0 // i
   Stack: &2 | 
11: inc // prefix inc/dec
   Stack: 3 | 
12: push 2 // Terminal
   Stack: 3 | 2 | 
13: gt
   Stack: true | 
14: brfalse endif4 // goto endif
   Stack: 
15: br forlast3 // break/continue
   Stack: 
19: load 0 // i
   Stack: 3 | 
20: push 3 // Terminal
   Stack: 3 | 3 | 
21: eq
   Stack: true | 
22: push "for loop local var handling" // Terminal
   Stack: true | for loop local var handling | 
23: assert
   Stack: true | 
24: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.gotoStatement">Statements_Test.gotoStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.forStatement] End Test
[AUNIT:STRT][Statements_Test.gotoStatement] Start Test
Parsed: [int i = 0;
do
{
  i = i + 1;
  if (i > 3) goto ende;
} while  (i < 4);
__assert(false, "unreachable. goto doesn't work expected");
ende:

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    DoStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              AssignmentExpr:
                VarName:
                  i
                '='
                AdditiveExpr:
                  VarName:
                    i
                  '+'
                  Literal:
                    : 1
          Statement:
            IfStatement:
              RelationalExpr:
                VarName:
                  i
                '>'
                Literal:
                  : 3
              Statement:
                GotoStatement:
                  Label:
                    ende
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 4
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                Literal:
                  BOOLEAN_LITERAL:
                    'false'
              Argument:
                Literal:
                  : unreachable. goto doesn't work expected
  Statement:
    LabeledStatement:
      Label:
        ende
Create Var i at idx: 0
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
dobegin1: nop // dostart
load 0 // i
add
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
gt
brfalse endif2 // goto endif
br ende // goto
endif2: nop // 
load 0 // i
lt
brfalse doend1 // break do loop
br dobegin1 // next do loop
doend1: nop // 
push false // false
assert
pop // discarge expression result for ExprStatement
ende: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: dobegin1: nop // dostart
8: load 0 // i
9: push 1 // Terminal
10: add
11: loadref 0 // i
12: assign
13: pop // discarge expression result for ExprStatement
14: load 0 // i
15: push 3 // Terminal
16: gt
17: brfalse endif2 // goto endif
18: br ende // goto
19: endif2: nop // 
20: load 0 // i
21: push 4 // Terminal
22: lt
23: brfalse doend1 // break do loop
24: br dobegin1 // next do loop
25: doend1: nop // 
26: push false // false
27: push "unreachable. goto doesn't work expected" // Terminal
28: assert
29: pop // discarge expression result for ExprStatement
30: ende: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: dobegin1: nop // dostart
   Stack: 
8: load 0 // i
   Stack: 0 | 
9: push 1 // Terminal
   Stack: 0 | 1 | 
10: add
   Stack: 1 | 
11: loadref 0 // i
   Stack: 1 | &0 | 
12: assign
   Stack: 1 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 1 | 
15: push 3 // Terminal
   Stack: 1 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 1 | 
21: push 4 // Terminal
   Stack: 1 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 1 | 
9: push 1 // Terminal
   Stack: 1 | 1 | 
10: add
   Stack: 2 | 
11: loadref 0 // i
   Stack: 2 | &1 | 
12: assign
   Stack: 2 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 2 | 
15: push 3 // Terminal
   Stack: 2 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 2 | 
21: push 4 // Terminal
   Stack: 2 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 2 | 
9: push 1 // Terminal
   Stack: 2 | 1 | 
10: add
   Stack: 3 | 
11: loadref 0 // i
   Stack: 3 | &2 | 
12: assign
   Stack: 3 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 3 | 
15: push 3 // Terminal
   Stack: 3 | 3 | 
16: gt
   Stack: false | 
17: brfalse endif2 // goto endif
   Stack: 
20: load 0 // i
   Stack: 3 | 
21: push 4 // Terminal
   Stack: 3 | 4 | 
22: lt
   Stack: true | 
23: brfalse doend1 // break do loop
   Stack: 
24: br dobegin1 // next do loop
   Stack: 
8: load 0 // i
   Stack: 3 | 
9: push 1 // Terminal
   Stack: 3 | 1 | 
10: add
   Stack: 4 | 
11: loadref 0 // i
   Stack: 4 | &3 | 
12: assign
   Stack: 4 | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: load 0 // i
   Stack: 4 | 
15: push 3 // Terminal
   Stack: 4 | 3 | 
16: gt
   Stack: true | 
17: brfalse endif2 // goto endif
   Stack: 
18: br ende // goto
Parsed: [goto ende;
ende: goto realende;
__assert(false, "goto doesn't work");
realende:

] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    GotoStatement:
      Label:
        ende
  Statement:
    LabeledStatement:
      Label:
        ende
      Statement:
        GotoStatement:
          Label:
            realende
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                Literal:
                  BOOLEAN_LITERAL:
                    'false'
              Argument:
                Literal:
                  : goto doesn't work
  Statement:
    LabeledStatement:
      Label:
        realende
br ende // goto
ende: nop // 
br realende // goto
push false // false
assert
pop // discarge expression result for ExprStatement
realende: nop // 
0: br ende // goto
1: ende: nop // 
2: br realende // goto
3: push false // false
4: push "goto doesn't work" // Terminal
5: assert
6: pop // discarge expression result for ExprStatement
7: realende: nop // 
   Stack: 
0: br ende // goto
   Stack: 
2: br realende // goto
Parsed: [void foo()
{
  goto endoffoo;
  __assert(false, "goto in methods does not work");
endoffoo: ;
}
foo();
;
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    FunctionDeclDef:
      ClassDeclMethod:
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
        FunctionBlock:
          Block:
            Statement:
              GotoStatement:
                Label:
                  endoffoo
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    __assert
                  FuncSubscribeExpr:
                    Arguments:
                      ArgumentList:
                        Argument:
                          Literal:
                            BOOLEAN_LITERAL:
                              'false'
                        Argument:
                          Literal:
                            : goto in methods does not work
            Statement:
              LabeledStatement:
                Label:
                  endoffoo
                Statement:
                  EmptyStatement:
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          foo
        FuncSubscribeExpr:
          Arguments:
  Statement:
    EmptyStatement:

after function:
ClassDeclDef:
  TypeName:
    foo
  DerivedDef:
  ClassDeclOperator:
    ClassMemberAttr:
      'public'
      'static'
    ReturnType:
      FqTypeName:
        
    Operator:
      ()
    FunctionParamsDecl:
    FunctionBlock:
      Block:
        Statement:
          GotoStatement:
            Label:
              endoffoo
        Statement:
          ExprStatement:
            SubscribeExpr:
              VarName:
                __assert
              FuncSubscribeExpr:
                Arguments:
                  ArgumentList:
                    Argument:
                      Literal:
                        BOOLEAN_LITERAL:
                          'false'
                    Argument:
                      Literal:
                        : goto in methods does not work
        Statement:
          LabeledStatement:
            Label:
              endoffoo
            Statement:
              EmptyStatement:
Create Var this at idx: 0
foo this
__method_start: nop // 
br endoffoo // goto
push false // false
assert
pop // discarge expression result for ExprStatement
endoffoo: nop // 
push <undefined> // void return
ret  // 
Function operator_po_pc[
__method_start: nop // 
br endoffoo // goto
push false // false
push "goto in methods does not work" // Terminal
assert
pop // discarge expression result for ExprStatement
endoffoo: nop // 
push <undefined> // void return
ret  // 
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function foo[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "foo" // class name to initialize
init_clazz // 
push "foo" // class name
Create Var __tvar1 at idx: 0
clvr 0 // ClassName or object instance
store 0
load 0 // ClassName or object instance
push 1555130951 // function name: _0_operator_po_pc
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke_static
pop // discarge expression result for ExprStatement
0: push "foo" // class name to initialize
1: init_clazz // 
2: push "foo" // class name
3: clvr 0 // ClassName or object instance
4: store 0
5: load 0 // ClassName or object instance
6: push 1555130951 // function name: _0_operator_po_pc
7: push 67108880 // dmi flags = PUBLIC, argcount = 0
8: hash_invoke_static
9: pop // discarge expression result for ExprStatement
   Stack: 
0: push "foo" // class name to initialize
   Stack: foo | 
1: init_clazz // 
   Stack: 
2: push "foo" // class name
   Stack: foo | 
3: clvr 0 // ClassName or object instance
   Stack: foo | 
4: store 0
   Stack: 
5: load 0 // ClassName or object instance
   Stack: foo | 
6: push 1555130951 // function name: _0_operator_po_pc
   Stack: foo | 1555130951 | 
7: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: foo | 1555130951 | 67108880 | 
8: hash_invoke_static
   Stack: 
0: __method_start: nop // 
   Stack: 
1: br endoffoo // goto
   Stack: 
7: push <undefined> // void return
   Stack: Nil | 
8: ret  // 
   Stack: Nil | 
9: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="Statements_Test.ifStatement">Statements_Test.ifStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.gotoStatement] End Test
[AUNIT:STRT][Statements_Test.ifStatement] Start Test
Parsed: [int i = 0;
if (i < 10) i = 11; else i = 9;] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 0
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              i
            '='
            Literal:
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 9
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 0
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
            VarName:Sem=[i=int] ExprSem=[i=int]
              i
            '='
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
              VarName:Sem=[i=int] ExprSem=[i=int]
                i
              '='
              Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                : 9
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse elseblock1 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif1 // goto endif
elseblock1: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 0 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse elseblock1 // goto else block
11: push 11 // Terminal
12: loadref 0 // i
13: assign
14: pop // discarge expression result for ExprStatement
15: br endif1 // goto endif
16: elseblock1: nop // 
17: push 9 // Terminal
18: loadref 0 // i
19: assign
20: pop // discarge expression result for ExprStatement
21: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 0 // Terminal
   Stack: 0 | 
4: loadref 0 // i
   Stack: 0 | &0 | 
5: assign
   Stack: 0 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 0 | 
8: push 10 // Terminal
   Stack: 0 | 10 | 
9: lt
   Stack: true | 
10: brfalse elseblock1 // goto else block
   Stack: 
11: push 11 // Terminal
   Stack: 11 | 
12: loadref 0 // i
   Stack: 11 | &0 | 
13: assign
   Stack: 11 | 
14: pop // discarge expression result for ExprStatement
   Stack: 
15: br endif1 // goto endif
Parsed: [int i = 12;
if (i < 10) i = 11; else i = 9;] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 12
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:
            VarName:
              i
            '='
            Literal:
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 9
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 12
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        ExprStatement:
          AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
            VarName:Sem=[i=int] ExprSem=[i=int]
              i
            '='
            Literal:Sem=[byte=byte] ExprSem=[byte=byte]
              : 11
      ElseStatement:
        Statement:
          ExprStatement:
            AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
              VarName:Sem=[i=int] ExprSem=[i=int]
                i
              '='
              Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                : 9
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse elseblock1 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif1 // goto endif
elseblock1: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 12 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse elseblock1 // goto else block
11: push 11 // Terminal
12: loadref 0 // i
13: assign
14: pop // discarge expression result for ExprStatement
15: br endif1 // goto endif
16: elseblock1: nop // 
17: push 9 // Terminal
18: loadref 0 // i
19: assign
20: pop // discarge expression result for ExprStatement
21: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 12 // Terminal
   Stack: 12 | 
4: loadref 0 // i
   Stack: 12 | &0 | 
5: assign
   Stack: 12 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 12 | 
8: push 10 // Terminal
   Stack: 12 | 10 | 
9: lt
   Stack: false | 
10: brfalse elseblock1 // goto else block
   Stack: 
17: push 9 // Terminal
   Stack: 9 | 
18: loadref 0 // i
   Stack: 9 | &12 | 
19: assign
   Stack: 9 | 
20: pop // discarge expression result for ExprStatement
   Stack: 
21: endif1: nop // 
Parsed: [int i = 5;
if (i < 10) { if (3 < i) i = 2; else i = 4; }
] to
CodeText:
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 5
  Statement:
    IfStatement:
      RelationalExpr:
        VarName:
          i
        '<'
        Literal:
          : 10
      Statement:
        Block:
          Statement:
            IfStatement:
              RelationalExpr:
                Literal:
                  : 3
                '<'
                VarName:
                  i
              Statement:
                ExprStatement:
                  AssignmentExpr:
                    VarName:
                      i
                    '='
                    Literal:
                      : 2
              ElseStatement:
                Statement:
                  ExprStatement:
                    AssignmentExpr:
                      VarName:
                        i
                      '='
                      Literal:
                        : 4
Create Var i at idx: 0
CodeText:
 SymbolTable: [
  int i
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      ExprStatement:
        AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
          VarName:Sem=[i=int] ExprSem=[i=int]
            i
          '='
          Literal:Sem=[byte=byte] ExprSem=[byte=byte]
            : 5
  Statement:
    IfStatement:
      RelationalExpr:Sem=[bool=bool]
        VarName:Sem=[i=int] ExprSem=[i=int]
          i
        '<'
        Literal:Sem=[byte=byte] ExprSem=[byte=byte]
          : 10
      Statement:
        Block:
         SymbolTable: [
          int i
         ]
          Statement:
            IfStatement:
              RelationalExpr:Sem=[bool=bool]
                Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                  : 3
                '<'
                VarName:Sem=[i=int] ExprSem=[i=int]
                  i
              Statement:
                ExprStatement:
                  AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
                    VarName:Sem=[i=int] ExprSem=[i=int]
                      i
                    '='
                    Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                      : 2
              ElseStatement:
                Statement:
                  ExprStatement:
                    AssignmentExpr:Sem=[i=int] ExprSem=[i=int]
                      VarName:Sem=[i=int] ExprSem=[i=int]
                        i
                      '='
                      Literal:Sem=[byte=byte] ExprSem=[byte=byte]
                        : 4
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
load 0 // i
lt
brfalse endif1 // goto endif
load 0 // i
lt
brfalse elseblock2 // goto else block
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endif2 // goto endif
elseblock2: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
endif2: nop // 
endif1: nop // 
0: clvr 0 // i
1: push 0 // initialize local value
2: store 0 // initialize local value
3: push 5 // Terminal
4: loadref 0 // i
5: assign
6: pop // discarge expression result for ExprStatement
7: load 0 // i
8: push 10 // Terminal
9: lt
10: brfalse endif1 // goto endif
11: push 3 // Terminal
12: load 0 // i
13: lt
14: brfalse elseblock2 // goto else block
15: push 2 // Terminal
16: loadref 0 // i
17: assign
18: pop // discarge expression result for ExprStatement
19: br endif2 // goto endif
20: elseblock2: nop // 
21: push 4 // Terminal
22: loadref 0 // i
23: assign
24: pop // discarge expression result for ExprStatement
25: endif2: nop // 
26: endif1: nop // 
   Stack: 
0: clvr 0 // i
   Stack: 
1: push 0 // initialize local value
   Stack: 0 | 
2: store 0 // initialize local value
   Stack: 
3: push 5 // Terminal
   Stack: 5 | 
4: loadref 0 // i
   Stack: 5 | &0 | 
5: assign
   Stack: 5 | 
6: pop // discarge expression result for ExprStatement
   Stack: 
7: load 0 // i
   Stack: 5 | 
8: push 10 // Terminal
   Stack: 5 | 10 | 
9: lt
   Stack: true | 
10: brfalse endif1 // goto endif
   Stack: 
11: push 3 // Terminal
   Stack: 3 | 
12: load 0 // i
   Stack: 3 | 5 | 
13: lt
   Stack: true | 
14: brfalse elseblock2 // goto else block
   Stack: 
15: push 2 // Terminal
   Stack: 2 | 
16: loadref 0 // i
   Stack: 2 | &5 | 
17: assign
   Stack: 2 | 
18: pop // discarge expression result for ExprStatement
   Stack: 
19: br endif2 // goto endif
   Stack: 
26: endif1: nop // 
</pre>
<h2><a id="Statements_Test.switchStatement">Statements_Test.switchStatement</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> Cannot cast type [::acdk::aci::RBranchOp] to [::acdk::aci::RCode]<br>Called in:<br><pre>  called in <0x0>
  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::lang::ClassCastException::ClassCastException (acdk_core_d.dll)
  called in badCast (acdk_core_d.dll)
  called in dmi_cast (acdk_aal_d.dll)
  called in RefHolder<acdk::aal::CaseClause>::_init (acdk_aal_d.dll)
  called in RefHolder<acdk::aal::CaseClause>::RefHolder<acdk::aal::CaseClause> (acdk_aal_d.dll)
  called in acdk::aal::SwitchStatement::emitOpCode (acdk_aal_d.dll)
  called in acdk::aci::Code::emitOpCode (acdk_aal_d.dll)
  called in acdk::aci::Code::emitOpCode (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::Statements_Test::switchStatement (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::Statements_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.ifStatement] End Test
[AUNIT:STRT][Statements_Test.switchStatement] Start Test
Parsed: [int i = 2;
switch (i) {
case 1: i = 3; break;
case 2: i = 4; break;
}
__assert(i == 4, "switch failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        i
      VarInitializer:
        Literal:
          : 2
  Statement:
    SwitchStatement:
      VarName:
        i
      CaseClause:
        'case'
        Literal:
          : 1
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 3
        Statement:
          BreakStatement:
            'break'
      CaseClause:
        'case'
        Literal:
          : 2
        Statement:
          ExprStatement:
            AssignmentExpr:
              VarName:
                i
              '='
              Literal:
                : 4
        Statement:
          BreakStatement:
            'break'
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  VarName:
                    i
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : switch failed
Create Var i at idx: 0
Create Var __switchtestexpr1 at idx: 1
Code already postParsed: VarName: __switchtestexpr1
Code already postParsed: Literal: 
Code already postParsed: VarName: __switchtestexpr1
Code already postParsed: Literal: 
clvr 0 // i
push 0 // initialize local value
store 0 // initialize local value
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
clvr 1 // __switchtestexpr1
push 0 // initialize local value
store 1 // initialize local value
load 0 // i
loadref 1 // __switchtestexpr1
assign
pop // discarge expression result for ExprStatement
load 1 // __switchtestexpr1
eq
brfalse case2 // goto next switch
case_stmt3: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endswitch1 // break/continue
br case_stmt4 // goto next switch stm block
case2: nop // 
load 1 // __switchtestexpr1
eq
brfalse endswitch1 // goto next switch
case_stmt4: nop // 
loadref 0 // i
assign
pop // discarge expression result for ExprStatement
br endswitch1 // break/continue
[AUNIT:ERRR][Statements_Test.switchStatement] Error in Test: Statements_Test.switchStatement: Cannot cast type [::acdk::aci::RBranchOp] to [::acdk::aci::RCode]
</pre>
<h2><a id="Statements_Test.expressionIf">Statements_Test.expressionIf</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.switchStatement] End Test
[AUNIT:STRT][Statements_Test.expressionIf] Start Test
Parsed: [__assert((1 < 2 ? 3 : 4) == 3, "expressional if failed");
__assert((1 > 2 ? 3 : 4) == 4, "expressional if failed");
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ConditionalExpr:
                    RelationalExpr:
                      Literal:
                        : 1
                      '<'
                      Literal:
                        : 2
                    Literal:
                      : 3
                    Literal:
                      : 4
                  '=='
                  Literal:
                    : 3
              Argument:
                Literal:
                  : expressional if failed
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          __assert
        FuncSubscribeExpr:
          Arguments:
            ArgumentList:
              Argument:
                EqualityExpr:
                  ConditionalExpr:
                    RelationalExpr:
                      Literal:
                        : 1
                      '>'
                      Literal:
                        : 2
                    Literal:
                      : 3
                    Literal:
                      : 4
                  '=='
                  Literal:
                    : 4
              Argument:
                Literal:
                  : expressional if failed
lt
brfalse __expriffalse1 // expr if false
br __expriftrue1 // expr if true
__expriffalse1: nop // 
__expriftrue1: nop // 
eq
assert
pop // discarge expression result for ExprStatement
gt
brfalse __expriffalse2 // expr if false
br __expriftrue2 // expr if true
__expriffalse2: nop // 
__expriftrue2: nop // 
eq
assert
pop // discarge expression result for ExprStatement
0: push 1 // Terminal
1: push 2 // Terminal
2: lt
3: brfalse __expriffalse1 // expr if false
4: push 3 // Terminal
5: br __expriftrue1 // expr if true
6: __expriffalse1: nop // 
7: push 4 // Terminal
8: __expriftrue1: nop // 
9: push 3 // Terminal
10: eq
11: push "expressional if failed" // Terminal
12: assert
13: pop // discarge expression result for ExprStatement
14: push 1 // Terminal
15: push 2 // Terminal
16: gt
17: brfalse __expriffalse2 // expr if false
18: push 3 // Terminal
19: br __expriftrue2 // expr if true
20: __expriffalse2: nop // 
21: push 4 // Terminal
22: __expriftrue2: nop // 
23: push 4 // Terminal
24: eq
25: push "expressional if failed" // Terminal
26: assert
27: pop // discarge expression result for ExprStatement
   Stack: 
0: push 1 // Terminal
   Stack: 1 | 
1: push 2 // Terminal
   Stack: 1 | 2 | 
2: lt
   Stack: true | 
3: brfalse __expriffalse1 // expr if false
   Stack: 
4: push 3 // Terminal
   Stack: 3 | 
5: br __expriftrue1 // expr if true
   Stack: 3 | 
9: push 3 // Terminal
   Stack: 3 | 3 | 
10: eq
   Stack: true | 
11: push "expressional if failed" // Terminal
   Stack: true | expressional if failed | 
12: assert
   Stack: true | 
13: pop // discarge expression result for ExprStatement
   Stack: 
14: push 1 // Terminal
   Stack: 1 | 
15: push 2 // Terminal
   Stack: 1 | 2 | 
16: gt
   Stack: false | 
17: brfalse __expriffalse2 // expr if false
   Stack: 
21: push 4 // Terminal
   Stack: 4 | 
22: __expriftrue2: nop // 
   Stack: 4 | 
23: push 4 // Terminal
   Stack: 4 | 4 | 
24: eq
   Stack: true | 
25: push "expressional if failed" // Terminal
   Stack: true | expressional if failed | 
26: assert
   Stack: true | 
27: pop // discarge expression result for ExprStatement
</pre>
<h2><a id="WeakInvoke_Test.callAalObject">WeakInvoke_Test.callAalObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="green">Test OK with 0  Test Expressions</td></tr></table>
<br>Error output:<hr><pre>[AUNIT:ENDT][Statements_Test.expressionIf] End Test
[AUNIT:STRT][WeakInvoke_Test.callAalObject] Start Test
Parsed: [using acdk.lang;
class AClass {
  public int foo(String obj) { return 2; }
}AClass cls = new AClass();
try {
  cls->foo(42);
} catch (ParamsMismatchException ex) {
  System.out.println(ex.getMessage());
}
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    ClassDeclDef:
      TypeName:
        AClass
      DerivedDef:
      ClassDeclMethod:
        ClassMemberAttr:
          'public'
        ReturnType:
          FqTypeName:
            
        MethodName:
          foo
        FunctionParamsDecl:
          Parameter:
            FqTypeName:
              
            VarName:
              obj
        FunctionBlock:
          Block:
            Statement:
              ReturnStatement:
                Literal:
                  : 2
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        cls
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
  Statement:
    TryCatchStatement:
      Statement:
        Block:
          Statement:
            ExprStatement:
              SubscribeExpr:
                VarName:
                  cls
                MemberSubscribeExpr:
                  '->'
                  SubscribeExpr:
                    VarName:
                      foo
                    FuncSubscribeExpr:
                      Arguments:
                        Argument:
                          Literal:
                            : 42
      CatchBlock:
        FqTypeName:
          
        VarName:
          ex
        Statement:
          Block:
            Statement:
              ExprStatement:
                SubscribeExpr:
                  VarName:
                    System
                  MemberSubscribeExpr:
                    '.'
                    SubscribeExpr:
                      VarName:
                        out
                      MemberSubscribeExpr:
                        '.'
                        SubscribeExpr:
                          VarName:
                            println
                          FuncSubscribeExpr:
                            Arguments:
                              Argument:
                                SubscribeExpr:
                                  VarName:
                                    ex
                                  MemberSubscribeExpr:
                                    '.'
                                    SubscribeExpr:
                                      VarName:
                                        getMessage
                                      FuncSubscribeExpr:
                                        Arguments:
Create Var obj at idx: 0
acdk.lang.String obj
Create Var this at idx: 0
AClass this
acdk.lang.String obj
Create Var this at idx: 0
AClass this
Create Var cls at idx: 0
Create Var ex at idx: 0
__method_start: nop // 
ret  // return statement
Function foo[
__method_start: nop // 
push 2 // Terminal
ret  // return statement
]
__method_start: nop // 
push <undefined> // void return
ret  // 
Function AClass[
__method_start: nop // 
push <undefined> // void return
ret  // 
]
push "AClass" // class name to initialize
init_clazz // 
clvr 0 // cls
push Nil // initialize local value
store 0 // initialize local value
push "AClass" // class name
push 0 // dmi flags = 0, argcount = 0
new
loadref 0 // cls
assign
pop // discarge expression result for ExprStatement
try try1 // try label
load 0 // cls
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 1 // ClassName or object instance
push "foo" // function name
push 4296015888 // dmi flags = PUBLIC, argcount = 1
invoke
pop // discarge expression result for ExprStatement
br finally2 // goto finally
try1: nop // 
dup // safe exception
push "acdk.lang.ParamsMismatchException" // exception name to test for catching
instanceof // 
brfalse finally2 // goto next catch block
clvr 0 // ex
store 0
push "acdk.lang.System" // class name
push "out" // fieldname
push 0 // dmi flags
peek_static
Create Var __tvar1 at idx: 1
clvr 1 // ClassName or object instance
store 1
load 0 // ex
Create Var __tvar2 at idx: 2
clvr 2 // ClassName or object instance
store 2
load 2 // ClassName or object instance
push 1615806062 // function name: _3_getMessage
push 67108880 // dmi flags = PUBLIC, argcount = 0
hash_invoke
load 1 // ClassName or object instance
push 998516684 // function name: _t_println
push 4362076176 // dmi flags = PUBLIC, argcount = 1
hash_invoke
pop // discarge expression result for ExprStatement
catchend // clear exception
br finally2 // goto finally
finally2: nop // 
nop // 
0: push "AClass" // class name to initialize
1: init_clazz // 
2: clvr 0 // cls
3: push Nil // initialize local value
4: store 0 // initialize local value
5: push "AClass" // class name
6: push 0 // dmi flags = 0, argcount = 0
7: new
8: loadref 0 // cls
9: assign
10: pop // discarge expression result for ExprStatement
11: try try1 // try label
12: load 0 // cls
13: clvr 1 // ClassName or object instance
14: store 1
15: push 42 // Terminal
16: load 1 // ClassName or object instance
17: push "foo" // function name
18: push 4296015888 // dmi flags = PUBLIC, argcount = 1
19: invoke
20: pop // discarge expression result for ExprStatement
21: br finally2 // goto finally
22: try1: nop // 
23: dup // safe exception
24: push "acdk.lang.ParamsMismatchException" // exception name to test for catching
25: instanceof // 
26: brfalse finally2 // goto next catch block
27: clvr 0 // ex
28: store 0
29: push "acdk.lang.System" // class name
30: push "out" // fieldname
31: push 0 // dmi flags
32: peek_static
33: clvr 1 // ClassName or object instance
34: store 1
35: load 0 // ex
36: clvr 2 // ClassName or object instance
37: store 2
38: load 2 // ClassName or object instance
39: push 1615806062 // function name: _3_getMessage
40: push 67108880 // dmi flags = PUBLIC, argcount = 0
41: hash_invoke
42: load 1 // ClassName or object instance
43: push 998516684 // function name: _t_println
44: push 4362076176 // dmi flags = PUBLIC, argcount = 1
45: hash_invoke
46: pop // discarge expression result for ExprStatement
47: catchend // clear exception
48: br finally2 // goto finally
49: finally2: nop // 
50: nop // 
   Stack: 
0: push "AClass" // class name to initialize
   Stack: AClass | 
1: init_clazz // 
   Stack: 
2: clvr 0 // cls
   Stack: 
3: push Nil // initialize local value
   Stack: Nil | 
4: store 0 // initialize local value
   Stack: 
5: push "AClass" // class name
   Stack: AClass | 
6: push 0 // dmi flags = 0, argcount = 0
   Stack: AClass | 0 | 
7: new
   Stack: 
0: __method_start: nop // 
   Stack: 
1: push <undefined> // void return
   Stack: Nil | 
2: ret  // 
   Stack: AClass | 
8: loadref 0 // cls
   Stack: AClass | &Nil | 
9: assign
   Stack: AClass | 
10: pop // discarge expression result for ExprStatement
   Stack: 
11: try try1 // try label
   Stack: 
12: load 0 // cls
   Stack: AClass | 
13: clvr 1 // ClassName or object instance
   Stack: AClass | 
14: store 1
   Stack: 
15: push 42 // Terminal
   Stack: 42 | 
16: load 1 // ClassName or object instance
   Stack: 42 | AClass | 
17: push "foo" // function name
   Stack: 42 | AClass | foo | 
18: push 4296015888 // dmi flags = PUBLIC, argcount = 1
   Stack: 42 | AClass | foo | 4296015888 | 
19: invoke
   Stack: acdk/lang/ParamsMismatchException | 
23: dup // safe exception
   Stack: acdk/lang/ParamsMismatchException | acdk/lang/ParamsMismatchException | 
24: push "acdk.lang.ParamsMismatchException" // exception name to test for catching
   Stack: acdk/lang/ParamsMismatchException | acdk/lang/ParamsMismatchException | acdk.lang.ParamsMismatchException | 
25: instanceof // 
   Stack: acdk/lang/ParamsMismatchException | true | 
26: brfalse finally2 // goto next catch block
   Stack: acdk/lang/ParamsMismatchException | 
27: clvr 0 // ex
   Stack: acdk/lang/ParamsMismatchException | 
28: store 0
   Stack: 
29: push "acdk.lang.System" // class name
   Stack: acdk.lang.System | 
30: push "out" // fieldname
   Stack: acdk.lang.System | out | 
31: push 0 // dmi flags
   Stack: acdk.lang.System | out | 0 | 
32: peek_static
   Stack: acdk/io/PrintWriter | 
33: clvr 1 // ClassName or object instance
   Stack: acdk/io/PrintWriter | 
34: store 1
   Stack: 
35: load 0 // ex
   Stack: acdk/lang/ParamsMismatchException | 
36: clvr 2 // ClassName or object instance
   Stack: acdk/lang/ParamsMismatchException | 
37: store 2
   Stack: 
38: load 2 // ClassName or object instance
   Stack: acdk/lang/ParamsMismatchException | 
39: push 1615806062 // function name: _3_getMessage
   Stack: acdk/lang/ParamsMismatchException | 1615806062 | 
40: push 67108880 // dmi flags = PUBLIC, argcount = 0
   Stack: acdk/lang/ParamsMismatchException | 1615806062 | 67108880 | 
41: hash_invoke
   Stack: No matching function found: AClass::foo(byte)
 Following functions are defined:
	public:  int AClass::foo(::acdk::lang::RString obj)
 | 
42: load 1 // ClassName or object instance
   Stack: No matching function found: AClass::foo(byte)
 Following functions are defined:
	public:  int AClass::foo(::acdk::lang::RString obj)
 | acdk/io/PrintWriter | 
43: push 998516684 // function name: _t_println
   Stack: No matching function found: AClass::foo(byte)
 Following functions are defined:
	public:  int AClass::foo(::acdk::lang::RString obj)
 | acdk/io/PrintWriter | 998516684 | 
44: push 4362076176 // dmi flags = PUBLIC, argcount = 1
   Stack: No matching function found: AClass::foo(byte)
 Following functions are defined:
	public:  int AClass::foo(::acdk::lang::RString obj)
 | acdk/io/PrintWriter | 998516684 | 4362076176 | 
45: hash_invoke
No matching function found: AClass::foo(byte)
 Following functions are defined:
	public:  int AClass::foo(::acdk::lang::RString obj)

   Stack: Nil | 
46: pop // discarge expression result for ExprStatement
   Stack: 
47: catchend // clear exception
   Stack: 
48: br finally2 // goto finally
   Stack: 
50: nop // 
</pre>
<h2><a id="WeakInvoke_Test.callComObject">WeakInvoke_Test.callComObject</a></h2>
<table border=0 width="100%"><tr><td bgcolor="red">Test FAILED </td></tr></table>
Errors:<br>
<ul>
<li> 3,11: Cannot find semantic element: Visible<br>Called in:<br><pre>  called in acdk::lang::sys::BackTrace::BackTrace (acdk_core_d.dll)
  called in acdk::lang::Throwable::Throwable (acdk_core_d.dll)
  called in acdk::lang::Exception::Exception (acdk_core_d.dll)
  called in acdk::aci::CodeException::CodeException (acdk_aal_d.dll)
  called in acdk::aal::VarName::postParse (acdk_aal_d.dll)
  called in acdk::aal::MemberSubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::SubscribeExpr::postParse (acdk_aal_d.dll)
  called in acdk::aal::AssignmentExpr::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aci::Code::postParse (acdk_aal_d.dll)
  called in acdk::aal::AalInterpreter::parseTreeInterpret (acdk_aal_d.dll)
  called in tests::acdk::aal::WeakInvoke_Test::callComObject (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCaller<tests::acdk::aal::WeakInvoke_Test>::runTest (acdk_aal_Test_d.exe)
  called in acdk::tools::aunit::TestCase::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestSuite::run (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTest (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::executeTests (acdk_tools_aunit_d.dll)
  called in acdk::tools::aunit::TestRunner::testmain (acdk_tools_aunit_d.dll)
  called in acdk::lang::System::main (acdk_core_d.dll)
  called in main (acdk_aal_Test_d.exe)
  called in mainCRTStartup (acdk_aal_Test_d.exe)
  called in GetCurrentDirectoryW (kernel32.dll)
</pre></li>
</ul>
<br>Error output:<hr><pre>[AUNIT:ENDT][WeakInvoke_Test.callAalObject] End Test
[AUNIT:STRT][WeakInvoke_Test.callComObject] Start Test
Parsed: [using acdk.lang;
using acdkx.com;
ComObject o = new ComObject("Word.Application");
o.Visible = true;
int exitcode = 0;
acdk.lang.Thread.sleep(3);
o.Quit(exitcode);
] to
CodeText:
 SymbolTable: [
 ]
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    UsingDecl:
      FqTypeName:
        
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        o
      VarInitializer:
        NewExpr:
          FqTypeName:
            
          Arguments:
            Argument:
              Literal:
                : Word.Application
  Statement:
    ExprStatement:
      AssignmentExpr:
        SubscribeExpr:
          VarName:
            o
          MemberSubscribeExpr:
            '.'
            VarName:
              Visible
        '='
        Literal:
          BOOLEAN_LITERAL:
            'true'
  Statement:
    LVarDecl:
      FqTypeName:
        
      VarName:
        exitcode
      VarInitializer:
        Literal:
          : 0
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          acdk
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              lang
            MemberSubscribeExpr:
              '.'
              SubscribeExpr:
                VarName:
                  Thread
                MemberSubscribeExpr:
                  '.'
                  SubscribeExpr:
                    VarName:
                      sleep
                    FuncSubscribeExpr:
                      Arguments:
                        Argument:
                          Literal:
                            : 3
  Statement:
    ExprStatement:
      SubscribeExpr:
        VarName:
          o
        MemberSubscribeExpr:
          '.'
          SubscribeExpr:
            VarName:
              Quit
            FuncSubscribeExpr:
              Arguments:
                Argument:
                  VarName:
                    exitcode
Create Var o at idx: 0
[AUNIT:ERRR][WeakInvoke_Test.callComObject] Error in Test: WeakInvoke_Test.callComObject: 3,11: Cannot find semantic element: Visible
</pre>
</body></html>
